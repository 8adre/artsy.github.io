<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Artsy Engineering]]></title>
  <link href="http://artsy.net/categories/architecture/atom.xml" rel="self"/>
  <link href="http://artsy.net/"/>
  <updated>2015-08-24T12:19:43-04:00</updated>
  <id>http://artsy.net/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: Hybrid Apps]]></title>
    <link href="http://artsy.net/blog/2015/08/23/Cocoa-Architecture:-Hybrid-Apps/"/>
    <updated>2015-08-23T20:00:00-04:00</updated>
    <id>http://artsy.net/blog/2015/08/23/Cocoa-Architecture:-Hybrid-Apps</id>
    <content type="html"><![CDATA[<p>As a part of going through the design patterns we've found in the creation of the Artsy iOS apps, I'd like to talk a bit about <em>Hybrid Applications</em>. A hybrid application refers to an app that uses native code and web content intertwined. Our flagship iOS app, <a href="https://github.com/artsy/eigen">eigen</a> is a hybrid app, and it seems to get more and more hybrid-y each release. Let's talk a little bit about the pros and cons of this approach. <!-- more --></p>

<hr />

<h1>What is a Hybrid App</h1>

<p>I gave the widest possible definition above, so let's dig in as this can be a contentious. There is a whole spectrum of which an app can be classed as a hybrid app. This ranges from more or less web-tech everywhere to 100% Objective-C / Swift.</p>

<p>A great example of the furthest to the web-side is <a href="https://atom.io">ATOM</a>, the text editor. It's on the extreme side because all of the user interface is built using HTML + CSS, and almost all of the app is in javascript. The trade-off for them is that their developer can easy write cross-platform code, that will work reliably with technology that the vast majority of programmers use. This vastly reduces the barrier to entry for contributors and gives ATOM a really large community of programmers to draw from with respect to extending the app.</p>

<p>An example of a purely native application would be <a href="https://github.com/artsy/energy/">Energy</a>. It's over a hundred thousand plus lines of Objective-C. Yet under the hood, there's definitely some web-tech there. Prior to iOS7 <code>UILabel</code>s, <code>UITextField</code>s and <code>UITextField</code>s <a href="http://www.objc.io/issues/5-ios7/getting-to-know-textkit/">used WebKit for rendering</a>. Not to mention that when a Partner send's an email via Energy, the editor is a <code>UIWebView</code>. However, from the app developer's perspective they are creating native interactions that are consistent with the rest of the operating system's behavior.</p>

<h1>Eigen</h1>

<p>When we started building Eigen, it was very obvious that we had a Sisyphean task ahead of us. We wanted to take the core ideas of the Artsy website, <em>The Art World Online</em>, and convert it into mobile, <em>The Art World in Your Pocket</em>.</p>

<p>That's not impossible, but the mobile team was a fraction of the Artsy development team. Any new features added to the website would need a mobile equivalent, and given the speed in which web developer's can ship, we'd need to outnumber them to stand a chance at keeping up.</p>

<p>So, we opted for building a highly integrated mobile website at the same time, it would use the same design language as the iOS app and can act as a way for Android devices to access Artsy.</p>

<h1>Techniques for Doing It Well</h1>

<p>So we'll be talking about our <a href="https://github.com/artsy/eigen/blob/6bb44a01c1b23fb8e92c645c3091fd33725743c3/Artsy/View_Controllers/Web_Browsing/ARInternalMobileWebViewController.m"><code>ARInteralMobileViewContrller</code></a> - which currently relies on <code>UIWebView</code> but is in <a href="https://github.com/artsy/eigen/pull/606">the process of</a> migrating to <code>WKWebkit</code>.
- Scroll like an <a href="https://github.com/artsy/eigen/blob/6bb44a01c1b23fb8e92c645c3091fd33725743c3/Artsy/View_Controllers/Web_Browsing/ARExternalWebBrowserViewController.m#L39">iOS app</a> by setting the web view's <code>scrollView.decelerationRate = UIScrollViewDecelerationRateNormal</code>.
- Use a simple design language to avoid the <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/UncannyValley">uncanny valley</a>. Care about using the same <a href="https://github.com/artsy/Artsy-UILabels">typographical rules</a> on everything including tabs, buttons and switches.
- Take over navigation. This means pushing a <a href="https://github.com/artsy/eigen/blob/6bb44a01c1b23fb8e92c645c3091fd33725743c3/Artsy/View_Controllers/Web_Browsing/ARInternalMobileWebViewController.m#L180">new view controller</a> on the navigation stack every time a user intends to change context.
- Take over common OS features. We take over <a href="https://github.com/artsy/eigen/blob/master/Artsy/View_Controllers/Web_Browsing/ARInternalMobileWebViewController.m#L184-L190">social sharing</a>  instead of letting the web site send you to an external page, offering a native share sheet instead.</p>

<h1>Downsides</h1>

<p>When you choose developer ease over user experience it's important to take into consideration some of the downsides.
- Localisation is difficult. Cocoa offers a great localisation APIs. We can't use them, otherwise half of our app is correctly localised and the rest isn't.
- OS features like <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/TransitionGuide/AppearanceCustomization.html">Dynamic Type</a> are also a no-go.
- Conforming to the operating system's Human Interface Guidelines is more difficult, as you're relying less on foundations built with this in mind.
- Web tech is slower, and threading APIs are generally poor. A dfficulty here is that you are also complicating the technical stack upon which your app sits above. I often see Mac apps using a lot of web technologies using far more of my computer's resources than I'd like.</p>

<h1>Evolution</h1>

<p>One of the most interesting developments this year in the Cocoa world is Facebook's <a href="https://cocoapods.org/pods/React">react-native</a>, a bridge between web technology and native code that doesn't rely on using the <a href="http://www.quirksmode.org/dom/intro.html">traditional DOM</a> - freeing it from a lot of the common problems found in highly web-based apps.</p>

<p>We're pretty optimistic about it on the mobile team. We're not quite willing to jump head-first into a <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">pre-1.0 technology</a> again, but it shows a lot of promise.</p>

<p>The fact that we were able to ship an app at all was because we could build the parts that meant the most to us native, then rely on web technologies to cover the rest of the ground. By being pragmatic in our approach to using web tech, we have the chance to stand on the shoulders of giants.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: ARSwitchboard]]></title>
    <link href="http://artsy.net/blog/2015/08/18/Cocoa-Architecture:-Switchboard-Pattern/"/>
    <updated>2015-08-18T20:00:00-04:00</updated>
    <id>http://artsy.net/blog/2015/08/18/Cocoa-Architecture:-Switchboard-Pattern</id>
    <content type="html"><![CDATA[<p>As a part of going through the design patterns we've found in the creation of the Artsy iOS apps, I'd like to introduce the Switchboard pattern. This evolved quite naturally out of <a href="/blog/2015/08/15/Cocoa-Architecture:-Router-Pattern/">ARRouter</a> when applied to generating view controllers instead of API requests.  <!-- more --></p>

<hr />

<h1>Where we started</h1>

<p>In what must be one of my best named commits, <code>b9ff28</code> aka <em>"CREATING THE VOID"</em> introduced an <code>ARSwitchboard</code> to Eigen. Aside from this being the commit where I could finally write <code>[ARVoidViewController theVoid]</code> it added support for tapping an Artwork on the home-screen and going to another view controller.</p>

<p>We knew up-front that we needed to emulate the website's URL schemes, so we needed to come up with a way to support two ways of loading up a view controller. Here's what it looked like:</p>

<pre><code class="objc">@implementation ARSwitchBoard

+ (void)setupRouter {
    artsyHosts = [NSSet setWithObjects:@"art.sy", @"artsyapi.com", @"artsy.net", nil];

    [RCRouter map:@"/artwork/:id" to:self with:@selector(loadArtworkFromURL:)];
}

+ (void)navigateToURL:(NSURL *)url {
    if([self isInternalURL:url] &amp;&amp; [RCRouter canRespondToRoute:url.path]) {
        [RCRouter dispatch:url.path];
    } else {
//        [self openInternalBrowser:url];
    }
}

+ (BOOL)isInternalURL:(NSURL *)url {
    NSString * host = url.host;
    if(host &amp;&amp; [host hasPrefix:@"www"]) {
        host = [host substringFromIndex:3];
    }

    return (host &amp;&amp; [artsyHosts containsObject:host]);
}

#pragma mark -
#pragma mark Artworks

+ (void)loadAttachmentCollection:(AttachmentCollection *)collection {
    [[ARVoidViewController theVoid] loadArtworkViewWithAttachmentCollection:collection];
}

+ (void)loadArtwork:(Artwork *)artwork {
    AttachmentCollection * collection = [AttachmentCollection collectionWithItems:@[artwork] andIndex:0];
    [self loadAttachmentCollection:collection];
}

+ (void)loadArtworkFromURL:(NSDictionary *)options {
    [[ARVoidViewController theVoid] loadArtworkViewWithID:options[@"id"]];
}

@end
</code></pre>

<p>It shows the pattern's humble origins quite well. The <code>ARSwitchboard</code> provides an API that any object can call, and it will handle presenting the view controller. Offering an API that can either use arbitrary URLs or model objects.</p>

<h2>Where the pattern evolved</h2>

<p>I initially wrote this during my "Class methods look prettier" stage. Our <code>ARSwitchboard</code> has evolved into using instance methods, and it uses a sharedInstance. This makes writing tests for the routing extremely simple for <a href="https://github.com/artsy/energy/blob/master/ArtsyFolio%20Tests/Util/ARSwitchboardTests.m">easy use cases</a>, and possible <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy_Tests/App_Tests/ARSwitchBoardTests.m">for the complex</a>.</p>

<p>The pattern was established pretty well by the time it was integrated <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m">into Energy</a>. Some of it's highlights are:
- The sharedInstance is <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m#L20-L31">set up</a> with some of the other singletons, from that point on it only acts on properties it owns.
- It deals with setting up entire <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m#L229-L259">view hierarchies</a>. Not just pushing another view on to a <code>UINavigationController</code>.</p>

<h2>Internal Routing</h2>

<p>We try to make all view controllers that could represent a URL have two initializers; one that accepts a full model object and another that works off an ID. This means that we can provide as much context as we can initially, but can generate everything at runtime if you've come from a push notification or from another app.</p>

<p>We use an internal routing tool to do the heavy-lifting here, currently this is <a href="https://cocoapods.org/pods/JLRoutes">JLRoutes</a> which we use to map URLs to blocks and dictionaries.</p>

<h2>Difficulties</h2>

<p>With Eigen we're trying to map the whole data-set of Artsy into a single app, which likely an architecture post of it's own. However, one of the issues we're having that really strains this metaphor is ambiguity in the routing system. For us this crops up in two places:
- The URL <a href="https://github.com/artsy/eigen/pull/534">routing structure</a> you're mapping against can change.
- When one route could have <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy/App/ARSwitchBoard.m#L156">many types</a> of data.</p>

<p>Handling routes that changes is something we ended up building an <a href="https://github.com/artsy/echo/blob/master/app/api/v1/presenters/route_presenter.rb">API for</a>. It provides a JSON package of routes and names, and Eigen updates its routing internally.</p>

<p>Having one route represent multiple <em>potential</em> view controllers is tricky. We didn't want to introduce asynchronicity to the <code>ARSwitchboard</code>, so we use <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy/View_Controllers/Fair/ARProfileViewController.m#L55-L66">polymorphic view controllers</a>. This is a technique where the view controller returned then looks deeper into what it is representing and using child view controllers, embeds the true view controller inside itself.</p>

<h2>Future</h2>

<p>Like all patterns, our <code>ARSwitchboard</code> pattern is evolving. With Eigen we have  a complicated navigation stack, due to supporting app-wide tabs and hosting navigation controllers inside view controllers. This adds additional logic to pretty complicated code when we're dealing with URLs that could be root elements of a tab. So we are planning to eventually move the presentation aspect of the <code>ARSwitchboard</code> into a separate object.</p>

<h2>Alternatives</h2>

<p>We didn't need an <code>ARSwitchboard</code> in Eidolon. Which, so far always seems to be the exception in these architecture pattern posts. Instead we opted for Apple's <a href="http://www.objc.io/issues/15-testing/dependency-injection/#which-di-framework-should-i-use">Dependency Injection tool</a>, Interface Builder + Storyboards. Energy pre-dates Storyboards, and they didn't feel like a good fit for Eigen.</p>

<p>We found storyboards to be a really good replacement to this pattern when you have an established series of steps in your application with some well defined connections.</p>

<p>As an example, our on-boarding process for Eigen probably should have been storyboarded, as it's a series of view controllers pushed incrementally. However given that the rest of Eigen is essentially a web of interconnected view controllers, we'd be abusing the tool.</p>

<h2>Wrap up</h2>

<p>So the Switchboard is a way that we've managed to contain some of the complexity around having web-like abilities to jump between any two view controllers. This pattern makes it easy to stub a switchboard in tests, and to easily test the routing itself.</p>

<p>When I looked through some of the other open source iOS apps to compare the pattern, I couldn't find anything similar. So if you do have something similar, you should probably Open Source your app ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: ARRouter]]></title>
    <link href="http://artsy.net/blog/2015/08/15/Cocoa-Architecture:-Router-Pattern/"/>
    <updated>2015-08-15T00:00:00-04:00</updated>
    <id>http://artsy.net/blog/2015/08/15/Cocoa-Architecture:-Router-Pattern</id>
    <content type="html"><![CDATA[<p>I want to talk about a pattern that we've been using for the last few years on the Artsy Mobile team. This pattern pre-dates me joining Artsy by a few weeks, and was introduced into our codebase by <a href="http://90wpm.com">Ben Jackson</a>, this was the <code>ARRouter</code>'s first method:</p>

<pre><code class="objc">  + (NSURL *)newOAuthURLWithUsername:(NSString *)username password:(NSString *)password {
      NSDictionary *params = [[NSDictionary alloc] initWithObjectsAndKeys:
                              username, @"email",
                              password, @"password",
                              ARAuthClientID, @"client_id",
                              ARAuthSecret, @"client_secret",
                              @"credentials", @"grant_type",
                              nil];
      NSString *url_string = [[NSString alloc] initWithFormat:@"%@%@", AROAuthURL, [params queryString]];
      NSURL *url = [ARRouter newURLWithPath:url_string];
      [url_string release];
      [params release];
      return url;
  }
</code></pre>

<p>Yep, that's pre-ARC, pre-Dictionary Literals, memory-managed code. We took this pattern and rolled with it for the next 4 years, this article is about where we've taken it.</p>

<p>Within Eigen, <code>ARRouter</code> is one of our <a href="https://github.com/artsy/eigen/blob/904e8abfc11ce6ea4b6e81f0e02684b755a280c3/Artsy/Networking/ARRouter.m">biggest classes</a>, coming in at almost 1,000 lines of code. Whereas in Energy, it sits at a <a href="https://github.com/artsy/energy/blob/e51529250ede359c781042f222d5836eb9e8a979/Classes/Util/App/ARRouter.m">more reasonable</a> 300 lines. Eidolon does not have an ARRouter, what gives?</p>

<!-- more -->


<hr />

<h2>Pattern Evolution</h2>

<p>We started out with a Router object as being something that can take a model object, and return a <code>NSURL</code> corresponding to a server side end-point.</p>

<p>This worked pretty well, we shipped a 1.0 of Energy with this pattern. However, it become obvious that we were putting a lot of extra knowledge about the type and the parameters of request into classes whose responsibility was not generating a route. For example, user account creation, and user account deletion would use the same <code>NSURL</code> but have different HTTP methods.</p>

<p>We migrated our networking stack to using AFNetworking <code>1.0</code>, and started using CocoaPods instead of manually dragging and dropping code. With this in mind, we improved on the pattern and started returning <code>NSURLRequest</code>s which better encapsulate the server end-point request we were trying to map in the Router.</p>

<p>The pattern evolved when mixed with a <a href="http://cocoadocs.org/docsets/AFNetworking/1.3.4/Classes/AFHTTPClient.html">AFHTTPClient</a> to act as the base URL resolver, allowing us to easily switch between staging and production environments, and as a central point for hosting all HTTP headers. This meant it was trivial to generate authenticated <code>NSURLRequest</code>s.</p>

<p>As it is presently, this pattern is working. We've just wrapped up a new Pod, <a href="https://github.com/artsy/Artsy_Authentication">Artsy Authentication</a>. It's a library that has an <code>ARRouter</code> that behaves <a href="https://github.com/artsy/Artsy_Authentication/blob/master/Pod/Classes/ArtsyAuthenticationRouter.h">exactly like above</a>. We continue to build new apps with the pattern.</p>

<h2>Siblings</h2>

<p>This pattern is standing the test of time, but that doesn't mean we're not actively trying to experiment within the domain. There are three interesting offshoots from our work on <code>ARRouter</code> that are worth talking about.</p>

<h4>Got the Routes like Swagger</h4>

<p>The difference between Eigen's <code>ARRouter</code> and Energy's <code>ARRouter</code> is pretty simple. Eigen's networking scope is an order of magnitude larger. This is a reflection on the varied data that Eigen is interested in, while Energy has a tight scope on specifically Artsy Parter related data.</p>

<p>During the new year of 2015, I explored the <a href="https://github.com/orta/GotTheRoutesLikeSwagger">idea of programmatically generating</a> an <code>ARRouter</code> as a CocoaPod, and then using CocoaPods' subspecs to make it easy to define what collections of end-points you were interested in. This project is based on a standard in which an API is documented, <a href="http://swagger.io">Swagger</a>. This meant as an API consumer, I can generate the types of <code>NSURLRequest</code>s I would require from the API itself. It created files that looked like:</p>

<pre><code class="objc">// Generated by Routes Like Swagger - 31/12/14

@interface ARRouter (User)

/// Retrieve a user by id.
/// @return URLRequest for /api/v1/user/{id}.{format}

- (NSURLRequest *)getUserWithID:(NSString * )slug;

/// Update an existing user.
/// @return URLRequest for /api/v1/user/{id}.{format}

- (NSURLRequest *)updateUserWithID:(NSString * )slug;

... [snip] ...

@end
</code></pre>

<p>This was a pretty nice expansion of the pattern, but overall felt a bit over-engineered and so, it was left as just an experiment.</p>

<h4>Moya</h4>

<p>When we started an entirely fresh application, we noted down all the networking-related pain points felt from Eigen and Energy. The Router pattern was pretty good, but we were finding that we were having problems with the API consuming part of the <code>NSURLRequest</code>s. Mainly, a difficulty in testing, an inconsistency in how we would perform networking and that it didn't feel declarative.</p>

<p>Moya is our attempt at fixing this. I won't go into depth on what Moya is, we've <a href="/blog/2014/09/22/transparent-prerequisite-network-requests/">written articles</a> on this already. The part that is interesting is that it obviates an ARRouter by using a collection of Swift enums - forcing developers to include all necessary metadata an an end-point.</p>

<h4>HAL, and API v2</h4>

<p>The Router pattern relies on the idea that you know all the routes ahead of time, and add support for them as you build out each part of the app. <a href="http://stateless.co/hal_specification.html">HAL, a Hypermedia Application Layer</a> - can be approximated as being a self describing API. dB. wrote about it in <a href="/blog/2014/09/12/designing-the-public-artsy-api/">this blog post</a>.</p>

<p>This means that you ask the API how to get certain bits of data, and it will describe the ways in which you can access it.</p>

<p>Artsy's future APIs are using this, and the Router pattern is, more or less, totally deprecated in this world. This is what an artwork's JSON data looks like in v2:</p>

<pre><code class="json">{
  "id": "4d8b92bb4eb68a1b2c00044a",
  "created_at": "2010-11-15T16:32:38+00:00",
  "updated_at": "2015-08-16T09:26:26+00:00",
  "name": "Jeff Koons",
  "sortable_name": "Koons Jeff",
  "gender": "male",
  "birthday": "1955",
  "hometown": "York, Pennsylvania",
  "location": "New York, New York",
  "nationality": "American",
  "_links": {
    "curies": [
      {
        "name": "image",
        "href": "https://d32dm0rphc51dk.cloudfront.net/Uqad2mGhbNGhAUgb8bUvIA/{rel}",
        "templated": true
      }
  ],
  "thumbnail": {
    "href": "https://d32dm0rphc51dk.cloudfront.net/Uqad2mGhbNGhAUgb8bUvIA/four_thirds.jpg"
  },
  "image:self": {
    "href": "{?image_version}.jpg",
    "templated": true
  },
  "self": {
    "href": "https://api.artsy.net/api/artists/4d8b92bb4eb68a1b2c00044a"
  },
  "permalink": {
    "href": "http://www.artsy.net/artist/jeff-koons"
  },
  "artworks": {
    "href": "https://api.artsy.net/api/artworks?artist_id=4d8b92bb4eb68a1b2c00044a"
  },
  "published_artworks": {
    "href": "https://api.artsy.net/api/artworks?artist_id=4d8b92bb4eb68a1b2c00044a&amp;published=true"
  },
  "similar_artists": {
    "href": "https://api.artsy.net/api/artists?similar_to_artist_id=4d8b92bb4eb68a1b2c00044a"
  },
  "similar_contemporary_artists": {
    "href": "https://api.artsy.net/api/artists?similar_to_artist_id=4d8b92bb4eb68a1b2c00044a&amp;similarity_type=contemporary"
  },
  "genes": {
    "href": "https://api.artsy.net/api/genes?artist_id=4d8b92bb4eb68a1b2c00044a"
  }
  },
  "image_versions": [
    "four_thirds",
    "large",
    "square",
    "tall"
  ]
}
</code></pre>

<p>You can see that via the _links section, curies and self-referential urls, you can build network client which traverses the API without built-in implicit knowledge.</p>

<p>It's a really exciting pattern, and as client developers, we can work on improving standard API clients that work on all HAL APIs. Instead of something specific to Artsy's API. A lot of the most interesting work in the Cocoa space has been done by Kyle Fuller with <a href="https://cocoapods.org/pods/Hyperdrive">Hyperdrive</a>.</p>

<h3>Wrap Up</h3>

<p>Given that we're not writing applications against the v2 API, yet. The Router pattern is working fine for us at Artsy. It can be a really nice way to abstract out a responsibility that may currently be sitting inside a very large API client that might be worth extracting out.</p>

<p>Let us know what you think, send tweets to <a href="https://twitter.com/ArtsyOpenSource">@ArtsyOpenSource</a> on twitter. Ps. it's pronounced "rooter".</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rendering on the Server and Client in Node.js]]></title>
    <link href="http://artsy.net/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/"/>
    <updated>2013-11-30T22:38:00-05:00</updated>
    <id>http://artsy.net/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js</id>
    <content type="html"><![CDATA[<p><img src="/images/2013-12-18-rendering-on-the-server-and-client-in-node-dot-js/isomorphic.png" alt="Diagram of Shared Server/Client Architecture" /></p>

<p>At Artsy we've been building <a href="http://nodejs.org/">Node.js</a> applications that share code and rendering between the server and browser. We've seen many benefits from this -- pages load faster, we can optimize SEO, developers are more productive, and JavaScript coding is just an overall better experience.</p>

<p>Today we're happy to announce <a href="http://ezeljs.com/">Ezel</a>, our open source boilerplate we use to bootstrap our Node projects and the <a href="https://github.com/artsy/benv">various</a> <a href="https://github.com/artsy/backbone-super-sync">node</a> <a href="https://github.com/artsy/sharify">modules</a> that built up to it.</p>

<p>In his article, <a href="http://nerds.airbnb.com/isomorphic-JavaScript-future-web-apps/"><em>Isomorphic JavaScript: The Future of Web Apps</em></a>, Spike Brehm from AirBnB describes this growing trend well and we're excited to be a part of it. In this article I'll tell Artsy's story of moving from a single monolithic application to modular <a href="http://backbonejs.org/">Backbone</a> apps that run in Node and the browser and consume our external API.</p>

<!-- more -->


<h2>Growing Pains</h2>

<p><img src="/images/2013-12-18-rendering-on-the-server-and-client-in-node-dot-js/rails-evolution.png" alt="Evolution of Artsy SOA Diagramm" /></p>

<p>Artsy started as a mostly standard <a href="http://rubyonrails.org/">Rails</a> app almost three years ago. In these beginnings we were wildly productive and owe a lot of props to this great framework. However as time went on we started to deviate from the conventional Rails path until we were hardly leveraging much Rails at all. To support an early iOS app we used <a href="https://github.com/intridea/grape">Grape</a> to build an API. While building our API we wrote a lot of client-side JavaScript and soon integrated <a href="http://backbonejs.org/">Backbone</a> for organization. Eventually we cleanly separated our project into a single page Backbone app talking to our API all on inside of this original repository.</p>

<p>We knew we were outgrowing this monolithic project because we had some clear problems...</p>

<ul>
<li>Slow initial page loads because of lacking server-side rendering. Twitter <a href="https://blog.twitter.com/2012/improving-performance-twittercom">describes this problem well</a>.</li>
<li>Slow following client-side renders because of downloading large asset packages without clear ways to break them up.</li>
<li>SEO issues like building <a href="https://developers.google.com/webmasters/ajax-crawling/docs/specification">escaped fragment</a> pages in Ruby on the server while our users saw what JavaScript rendered on the client.</li>
<li>Maintaining duplicated Ruby/JavaScript code such as templates, date libraries, etc.</li>
<li>Very slow and brittle tests. We had a massive integration test suite consisting of over 3000 <a href="https://github.com/jnicklas/capybara">Capybara</a> tests that took hours to run because we lacked good JavaScript testing tools.</li>
<li>Poor mobile experience from trying to responsively scale down a large single page app with bloated and unused assets.</li>
<li>Slow asset compilation, server boot, and general build times. Productivity suffered greatly as more code was added to the same monolithic project.</li>
</ul>


<h2>There's Got to Be a Better Way</h2>

<p>A monolithic app that treats it's client-side code as a second class citizen was clearly not going to scale. Our poor mobile web experience was a good candidate to try something new. So we started building a separate mobile optimized website (m.artsy.net).</p>

<p>Some goals became clear:</p>

<ul>
<li>Better client-side tools from JavaScript testing to package managers.</li>
<li>Share rendering code server/client to reduce duplication and optimize initial page load.</li>
<li>Flexibility. We needed a way to divide our app into smaller chunks with smaller asset packages.</li>
</ul>


<h2>Choosing Technology</h2>

<p><img src="/images/2013-12-18-rendering-on-the-server-and-client-in-node-dot-js/tech.png" alt="Logos of Browserify, Express, and Backbone" /></p>

<p>Node was a clear choice because it made sharing rendering code server/client possible where other languages and frameworks struggle to do so. There were some existing Node projects that accomplish this such as <a href="http://derbyjs.com/">Derby</a> and <a href="https://github.com/airbnb/rendr">Rendr</a>. However, adopting these had challenges of their own including being difficult to integrate with our API, learning unnecessary conventions, or being early prototypes with lacking documentation.</p>

<p>We wanted an approach that breaks our app into smaller, more flexible, pieces. Not all of Artsy needs to be a thick-client app, or even use much client-side JavaScript at all. Adopting an existing solution and combining most of the server and client into a shared abstraction seemed like an unnecessary black box. After trying many other frameworks we found a combination of lower-level tools to be a clear winner.</p>

<p>We open sourced this combination of tools and patterns into <a href="http://ezeljs.com/">Ezel</a>. Ezel is a light-weight boilerplate project using <a href="http://expressjs.com/">Express</a> and <a href="http://backbonejs.org/">Backbone</a> for structure, and <a href="http://browserify.org/">Browserify</a> to compose modules that can be shared server/client.</p>

<h2>Sharing and Rendering Server/Client</h2>

<p><img src="/images/2013-12-18-rendering-on-the-server-and-client-in-node-dot-js/rendering.png" alt="Diagram of Server + Client Render" /></p>

<p>To share rendering code server/client we had to make sure our templates and objects being passed in to them could work the same server/client.</p>

<h3>Sharing Objects (Backbone Models)</h3>

<p><a href="http://browserify.org/">Browserify</a> lets you write modules that can run in Node or the browser. Since Backbone is able to be required on the server out of the box, it's easy to write models and collections that can be required on both sides with Browserify. However, there are two main speed bumps in doing this:</p>

<ol>
<li><p>Backbone uses AJAX for persistence.</p>

<p>We needed a Backbone.sync adapter that makes HTTP requests server-side, so we wrote one and <a href="https://github.com/artsy/backbone-super-sync">it's open sourced.</a></p></li>
<li><p>Data from the server needed to be shared in modules that are used server/client.</p>

<p>For instance, our API is an external URL stored in an environment variable. We needed to use this variable in a module that will be required on the server and the client with Browserify. <a href="http://backbonejs.org/#FAQ-bootstrap">Bootstrapping data</a> is a common technique to share data from the server by embedding JavaScript in the initial HTML and exposing that data globally to the client. To avoid exposing globals we open sourced a tiny module called <a href="https://github.com/artsy/sharify">sharify</a>.</p></li>
</ol>


<h3>Sharing Templates</h3>

<p>Browserify even lets you share non-JavaScript components server/client using <a href="https://github.com/substack/node-browserify#list-of-source-transforms">transforms</a>. To reuse our <a href="http://jade-lang.com/">jade</a> templates server/client it was a simple matter of using the <a href="https://github.com/OliverJAsh/node-jadeify2">jadeify</a> transform.</p>

<h3>All Together Now</h3>

<p>With templates and models require-able server/client, sharing rendering code became much simpler. Below is an example using the same artwork model and detail template server/client.</p>

<p>Shared Backbone "Artwork" model to be required server/client:</p>

<pre><code class="javascript models/artwork.js">var Backbone = require('backbone'),
    API_URL = require('sharify').data.API_URL;

module.exports = Artwork = Backbone.Model.extend({

  url: API_URL + '/api/v1/artwork'

});
</code></pre>

<p>Shared partial jade template used server/client:</p>

<pre><code class="jade templates/artwork-details.jade">h1= artwork.get('artist').name
h2= artwork.get('title')
</code></pre>

<p>Full server-side page template including the partial:</p>

<pre><code class="jade templates/artwork-page.jade">doctype 5
html
  head
    title Artsy | #{artwork.get('title')}
  body
    include artwork-details
    != sharify.script()
</code></pre>

<p>Route handler that uses the model server-side:</p>

<pre><code class="javascript app.js">//...
var Artwork = require('models/artwork.js');

app.get('/artwork/:id', function(req, res) {
  new Artwork({ id: req.params.id }).fetch({
    success: function(artwork) {
      // Boostrap artwork data into sharify
      res.locals.sharify.data.ARTWORK_JSON = artwork.toJSON();
      res.render('artwork-page', { artwork: artwork });
    }
  });
});
</code></pre>

<p>Client side code that requires the partial template and model:</p>

<pre><code class="javascript client.js">var Artwork = require('models/artwork.js'),
    ARTWORK_JSON = require('sharify').data.ARTWORK_JSON,
    detailsTemplate = require('templates/artwork-details.jade');

var artwork = new Artwork(ARTWORK_JSON);
artwork.on('change', function() {
  $('body').html(detailsTemplate({ artwork: artwork }));
});
</code></pre>

<h2>Developer Happiness</h2>

<p><img src="/images/2013-12-18-rendering-on-the-server-and-client-in-node-dot-js/so-much-win.png" alt="Happy Developer Image" /></p>

<p>Not only does sharing code server/client let you easily optimize page rendering for fast page loads, but development becomes a lot nicer because we can reuse server-side JavaScript tools including...</p>

<h3>Package Managers</h3>

<p>With Browserify we were able to use npm as a package manager for server or client-side dependencies. There are <a href="http://bower.io/">other</a> <a href="http://component.io/">package</a> <a href="http://jamjs.org/">managers</a> for the client-side. However, because we were already using npm (and npm supports git urls), we could usually point to the project hosted on npm or Github without having to fork it.</p>

<p>For projects that don't support CommonJS modules (or npm), often one can still use npm and requires like so:</p>

<pre><code class="json">"devDependencies": {
  "zepto": "git://github.com/madrobby/zepto.git#c074a94f0f26dc946f1c501f5f45d603adada44d"
}
</code></pre>

<pre><code class="javascript client.js">// Require the base Zepto library (attaches `Zepto` to window)
require('zepto/src/zepto.js');
// Attach Zepto's plugins
require('zepto/src/event.js');
require('zepto/src/detect.js');
// ....
</code></pre>

<h3>Testing</h3>

<p>Testing is light-years ahead because you can test all of your code in Node headless. I wrote <a href="/blog/2013/06/14/writing-headless-backbone-tests-with-node-dot-js/">an article</a> on this a while back, and now with Browserify it's even better.</p>

<p>Models, templates, and other modules that are shared server/client can be required into <a href="http://visionmedia.github.io/mocha/">mocha</a> and tested server-side without extra effort. For more view-like client-side code that depends on DOM APIs, pre-rendered HTML, etc., we open sourced a library called <a href="https://github.com/craigspaeth/benv">benv</a> to help build a fake browser environment in Node for testing.</p>

<h3>Modularity</h3>

<p>We wanted to avoid a monolithic organization that groups code by type such as "stylesheets", "javascripts", "controllers", etc.. Not only is this a maintenance problem as it makes boundaries of your app unclear, but it also affects your users because it encourages grouping assets into large monolithic packages that take a long time to download.</p>

<p>Instead, we borrowed a page from <a href="http://stackoverflow.com/questions/2472984/django-and-project-application-organization">Django</a> and broke up our project into smaller conceptual pieces called "apps" (small express sub-applications mounted into the main project) and "components" (portions of reusable UI such as a modal widget). This let us easily maintain decoupled segments of our project and build up smaller asset packages through Browserify's <code>require</code>s and <a href="http://learnboost.github.io/stylus/docs/import.html">Stylus</a>' <code>import</code>s. For more details on how this is done please check out <a href="http://ezeljs.com/">Ezel</a>, its <a href="https://github.com/artsy/ezel#project-vs-apps-vs-components">organization</a>, and <a href="https://github.com/artsy/ezel#asset-pipeline">asset pipeline</a> docs.</p>

<p>It's also worth noting, to avoid CSS spaghetti we followed a simple convention of name-spacing all of our classes/ids by the app or component name it was a part of. This was inspired by a <a href="http://philipwalton.com/articles/css-architecture/">blog post from Philip Walton</a>.</p>

<h2>Success!</h2>

<p>With this new architecture and set of Node tools we've seen enormous benefits compared to the pains of developing Backbone in a monolithic project with lacking JavaScript tools. Our mobile web experience is much better, we can render more content on the server for SEO and faster page loads, our test/build/deploy cycles went from hours to minutes, our developer on-boarding time went from days to minutes, and overall developer happiness has significantly improved.</p>

<p>It's an exciting time to be developing JavaScript apps and we will continue to open source our efforts wherever possible. Thanks and <a href="https://github.com/artsy">follow us on Github</a>!</p>
]]></content>
  </entry>
  
</feed>
