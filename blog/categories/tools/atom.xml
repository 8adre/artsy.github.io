<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tools | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2019-12-03T06:27:47+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building tools with empathy]]></title>
    <link href="http://artsy.github.io/blog/2019/12/03/building-tools-with-empathy/"/>
    <updated>2019-12-03T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/12/03/building-tools-with-empathy</id>
    <content type="html"><![CDATA[<p>As engineers, we're surrounded by problems. There are the problems to be solved that differentiate our business,
but there are also countless problems related solely with how we do work every day. It's those little things, the
daily annoyances, that can be some of the most rewarding problems to solve. It's not always about changing the
world or revolutionizing an industry.</p>

<p>Solving the minor frustrations can change your coworkers' day for the better and that's a powerful feeling.</p>

<p>It's also a task that should be taken on with the same care and consideration that you'd give to your users. Just
as we don't (or shouldn't) rush into product work without considering it from multiple angles, neither should we
dive into a workflow nor build a tool for our team without considering the risks and impact.</p>

<p>In this post I'm going to explore how to think about building tools with empathy and how we can maximize our impact
while minimizing disruptions.</p>

<!-- more -->


<a name="Understand.the.problem"></a>
<h2>Understand the problem</h2>

<a name="Understand.the.user"></a>
<h2>Understand the user</h2>

<a name="Know.the.risks"></a>
<h2>Know the risks</h2>

<a name="Set.it.up.for.success"></a>
<h2>Set it up for success</h2>

<a name="Over-communicate"></a>
<h2>Over-communicate</h2>

<p>There's an important lesson about change that I've learned recently. Often, the communication surrounding a change
is what dictates its perception. Great work can be soured by poor communication.</p>

<p>If you're to this point then you should have an idea of what you're doing, why you're doing it, who it helps, and
what may go wrong.</p>

<a name="Ship.it"></a>
<h2>Ship it</h2>

<a name="You.are.not.your.work"></a>
<h2>You are not your work</h2>

<p>I've saved this for last because it's a topic that I've struggled with a lot. When you're doing work you care about
it's easy to form personal attachments to that work. It's an expression of your self that you've put out in the
world hoping to create a positive impact. Inevitably though, things don't always work out how you expect. Maybe it
fails in a spectacular way... or maybe someone just doesn't like it. Whatever the case may be it can be hard not to
hear feedback about your work as feedback about you. If you've felt this before or you're feeling it now I just
want say, It's okay. Your feelings are valid. Feel what you feel, but then remember: You're more than just your
work. That setback is just an opportunity to learn and improve. It's just a tiny pebble from the mountain of work
you'll put out into the world.</p>

<p>The only failures are experiences that we don't learn from. So take that experience if it comes and give it the
time it needs. Reflect on it, feel it, and then think about what you could do better, learn from the experience,
and move past it. The next thing you do will be better for this experience.</p>

<a name="Wrapping.up"></a>
<h2>Wrapping up</h2>

<p>Now you know what you're building. You know who you're building it for and what their needs are. You have, to the
best of your knowledge, an understanding of what pitfalls to avoid. You've invested in the project so that it has
everything it needs to live on past your tenure. You've told your teammates all about it, showed it off in every
possible venue, and shipped it out to the world.</p>

<p>And with that friends, I bid you adieu.</p>

<p>Go out and build great things.</p>

<p>As my friends at Artsy always say, you've got this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Releasecop Tracks Stale Releases]]></title>
    <link href="http://artsy.github.io/blog/2015/09/01/releasecop-tracks-stale-releases/"/>
    <updated>2015-09-01T17:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/09/01/releasecop-tracks-stale-releases</id>
    <content type="html"><![CDATA[<p>Artsy practices a sort of <a href="http://en.wikipedia.org/wiki/Continuous_delivery">continuous delivery</a>. We keep release cycles short and the process of reviewing, testing, and deploying our software as reliable, fast, and automated as possible. (This blog has touched on these practices <a href="http://artsy.github.io/blog/categories/testing/">multiple</a> <a href="http://artsy.github.io/blog/categories/continuous-integration">times</a>.)</p>

<p>Usually, commits that have been reviewed and merged are immediately built and tested. Successfully built versions of the codebase are often automatically deployed to a staging environment. On an automated or frequent-but-manual basis, that version is deployed to a production environment. Thus, commits form a pipeline:</p>

<ul>
<li>From developers' working branches</li>
<li>To the master branch</li>
<li>Through a hopefully-successful build</li>
<li>To a staging environment</li>
<li>To production</li>
</ul>


<p>The number of apps and services we deploy has grown to <em>dozens</em> per team, so sometimes things fall through the cracks. We've been using <a href="https://github.com/joeyAghion/releasecop">Releasecop</a> for the last few months to get gentle email reminders when an environment could use a deploy.</p>

<!-- more -->


<pre><code>gem install releasecop
releasecop edit
</code></pre>

<p>This opens a <em>manifest</em> file where you can describe the sequence of git remotes and branches that make up your own release pipeline. For example:</p>

<pre><code>{
  "projects": {
    "charge": [
      { "name": "master", "git": "git@github.com:artsy/charge.git" },
      { "name": "staging", "git": "git@heroku.com:charge-staging.git" },
      { "name": "production", "git": "git@heroku.com:charge-production.git" }
    ],
    "gravity": [
      { "name": "master", "git": "git@github.com:artsy/gravity.git" },
      { "name": "master-succeeded", "git": "git@github.com:artsy/gravity.git", "branch": "master-succeeded" },
      { "name": "staging", "git": "git@github.com:artsy/gravity.git", "branch": "staging" },
      { "name": "production", "git": "git@github.com:artsy/gravity.git", "branch": "production" }
    ]
  }
}
</code></pre>

<p>The <code>charge</code> app is a typical deployment to Heroku. Work progresses from the <code>master</code> branch to a <code>charge-staging</code> app to a <code>charge-production</code> app. The <code>gravity</code> app is a more complicated, non-Heroku deployment. It updates git branches to reflect what has been merged (<code>master</code>), tested (<code>master-succeeded</code>), deployed to staging, and deployed to production.</p>

<p>Run the <code>releasecop check [app]</code> command to report the status of your apps' releases:</p>

<pre><code>$ releasecop check --all
charge...
  staging is up-to-date with master
  production is up-to-date with staging
gravity...
  master-succeeded is up-to-date with master
  staging is up-to-date with master-succeeded
  production is behind staging by:
    06ca969 2015-09-04 [config] Replace Apple Push Notification certificates that expire today. (Eloy Dur√°n)
    171121f 2015-09-03 Admin-only API for cancelling a bid (Matthew Zikherman)
    4c5feea 2015-09-02 install mongodb client in Docker so that import rake tasks can run (Barry Hoggard)
    95347d1 2015-08-31 Update to delayed_job cookbook that works with Chef 11.10 (Joey Aghion)
2 project(s) checked. 1 environment(s) out-of-date.
</code></pre>

<p>A nightly <a href="https://jenkins-ci.org/">Jenkins</a> job emails us the results, but a cron job could work equally well.</p>

<p><a href="https://github.com/joeyAghion/releasecop">Releasecop</a> reminds us to deploy ready commits and close the loop on in-progress work. We hope you find it useful. (Pull requests are welcome!)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Artsy Uses GitHub to Build Artsy]]></title>
    <link href="http://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/"/>
    <updated>2012-01-29T14:26:00+00:00</updated>
    <id>http://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy</id>
    <content type="html"><![CDATA[<p><a href="http://zachholman.com/">Zach Holman</a> gave a good talk on <a href="http://zachholman.com/talk/how-github-uses-github-to-build-github">How GitHub uses GitHub to build GitHub</a> at Rubyconf. It was great to hear how similar our own processes are at Artsy, with a few notable differences.</p>

<p>Artsy engineers store almost everything on GitHub. We use GitHub Wikis, but don't use GitHub Issues much. We work in 3-week sprints with <a href="http://pivotaltracker.com/">Pivotal Tracker</a> instead. This blog is on GitHub. And, of course, we have our own Hubot which feeds funny animated GIFs after each successful deploy to our IRC channel.</p>

<p>The most interesting part for me was around these two slides.</p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-pull.png" alt="Pull" /></p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-fork.png" alt="Fork" /></p>

<p>Zach emphasized that you don't need forks to make pull requests. While technically true, I find forks particularly useful to keep things clean.</p>

<p>At Artsy we use personal forks to work on features, create topical branches and make pull requests into the master from there. This is the workflow of the vast majority of open-source projects too. Now, Zach is right, you don't want to create any second class developers - our entire team has write access to the master. We use pull requests from forks to do peer code reviews, even for trivial things. I would typically make a pull request including the person I'd like to code review my changes in the title. Here's an example.</p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-pull-request.png" alt="Targeted Pull Request" /></p>

<p>(Notice the use of hash rocket. Zach, Ruby has transcended our lives too.)</p>

<p>Working on forks keeps developer branches away from "master". The main repository only has three branches: "master", "staging" and "production" and each developer can make up whatever branching strategy they like in individual forks.</p>

<p>Code reviews have nothing to do with hierarchy or organization, any developer will code review any other developer's work. We tend to avoid using the same person for two subsequent code reviews to prevent excessive buddying. Zach called his pull requests "collective experiments" - a place for active discussions, rejections and praise. I really like that. Each of my rejected pull requests has been a great learning experience.</p>
]]></content>
  </entry>
  
</feed>
