<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: community | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/community/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2019-04-12T20:21:43+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why does Artsy use Relay?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/10/omakase-relay/"/>
    <updated>2019-04-10T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/10/omakase-relay</id>
    <content type="html"><![CDATA[<p>When the mobile team at Artsy considered <a href="/blog/2016/08/15/React-Native-at-Artsy/">moving to React Native</a> back in 2016, one of the most compelling
cases for making that jump was Relay. This, it seems, is a dependency that is rarely used in the JS community and
we often find ourselves re-explaining this decision to new engineers during onboarding, and to the public at large.</p>

<p>Which makes this a perfect blog post topic, so let's have a deep dive into what makes Relay compelling for Artsy's
engineering team.</p>

<!-- more -->


<a name="What.problem.does.Relay.solve."></a>
<h1>What problem does Relay solve?</h1>

<p>Relay is an API client for GraphQL, it comes in two parts: a compiler and a set of front-end components. Relay aims
to provide a really tight binding between your GraphQL API and your view hierarchy. When you build data-driven
apps, Relay removes a whole suite of non-business logic from your application.</p>

<p>Relay handles:</p>

<ul>
<li>Data binding (API → props)</li>
<li>Cache management (invalidation, re-render live components with data updates, etc)</li>
<li>Consistent abstractions for bi-directional pagination</li>
<li>Multiple query consolidation (e.g. consolidate all API requests to one request)</li>
<li>UI best practices baked in (e.g. optimistic response rendering)</li>
<li>Declarative data mutation (describe how data should change, instead of doing it)</li>
<li>Compile-time query generation (removing runtime overhead and allowing you to persist queries)</li>
</ul>


<p>By taking the responsibilities of the grunt work for most complex apps and moving it into Relay you get
Facebook-scale best-practices and can build on top of that.</p>

<a name="How.does.it.work."></a>
<h1>How does it work?</h1>

<p>You write a set of Relay components, you always start with a <a href="https://facebook.github.io/relay/docs/en/query-renderer.html"><code>QueryRenderer</code></a> and a tree of either
<a href="https://facebook.github.io/relay/docs/en/fragment-container.html"><code>FragmentContainer</code></a>, <a href="https://facebook.github.io/relay/docs/en/refetch-container.html"><code>RefetchContainer</code></a> or <a href="https://facebook.github.io/relay/docs/en/pagination-container.html"><code>PaginationContainer</code></a>s. You mostly use
<code>FragmentContainer</code>s, so I'll focus on that here.</p>

<p>A <code>FragmentContainer</code> is based on a <a href="https://graphql.org/learn/queries/#fragments">GraphQL fragment</a>. If you've never used a fragment, they are an
abstraction that lets you declare shared field-selections on a specific GraphQL type to reduce duplication in your
queries. For example:</p>

<pre><code>query GetPopularArtistAndFeaturedArtist {
  featuredArtist {
    id
    name
    bio
  }
  popularArtist {
    id
    name
    bio
  }
}
</code></pre>

<p>To move this query to use fragments:</p>

<pre><code>query GetPopularArtistAndFeaturedArtist {
  featuredArtist {
    ...ArtistMetadata
  }
  popularArtist {
    ...ArtistMetadata
  }
}

fragment ArtistMetadata on Artist {
  id
  name
  bio
}
</code></pre>

<p>It's a tiny bit longer, but you have a guarantee that the data is consistent across both artists. Now that you have
a rough idea of what a GraphQL fragment is, let's look at what a <code>FragmentContainer</code> looks like. Here's a
simplified <a href="https://github.com/artsy/emission/blob/892af2621eef455388e074701cca747330de3b3f/src/lib/Scenes/Settings/MyProfile.tsx#L95">profile page</a> from the Artsy iOS app:</p>

<pre><code class="ts">import React from "react"
import { createFragmentContainer, graphql } from "react-relay"
import { MyProfile_me } from "__generated__/MyProfile_me.graphql"

interface Props extends ViewProperties {
  me: MyProfile_me
}

export class MyProfile extends React.Component&lt;Props&gt; {
  render() {
    return (
      &lt;View&gt;
        &lt;Header&gt;
          &lt;ProfilePhoto initials={this.props.me.initials} image={this.props.me.image} /&gt;
          &lt;Subheading&gt;{this.props.me.name}&lt;/Subheading&gt;
        &lt;/Header&gt;
        &lt;ButtonSection&gt;
          &lt;ProfileButton
            section="Selling"
            description="Sell works from your collection"
            onPress={startSubmission}
          /&gt;
          &lt;ProfileButton
            section="Account Details"
            description="Email, password reset, profile"
            onPress={goToUserSettings}
          /&gt;
        &lt;/ButtonSection&gt;
      &lt;/View&gt;
    )
  }
}

export default createFragmentContainer(MyProfile, {
  me: graphql`
    fragment MyProfile_me on Me {
      name
      image
      initials
    }
  `
})
</code></pre>

<p>There are three moving parts:</p>

<ul>
<li>The TypeScript interface <code>MyProfile_me</code>, generated by the compiler, which ensures we can only use fields that
were selected in the fragment</li>
<li>The <code>MyProfile</code> component, which is a vanilla React component</li>
<li>The exported <code>createFragmentContainer</code> which returns a higher-order component that wraps <code>MyProfile</code> and ties it
to a fragment on a <code>Me</code> type in GraphQL</li>
</ul>


<a name="Isolation"></a>
<h2>Isolation</h2>

<p>The React component <code>MyProfile</code> will be passed in props that directly tie to the fragment that was requested. In
Relay terms, this is called <a href="https://facebook.github.io/relay/docs/en/thinking-in-relay.html#data-masking">data masking</a> and it is one of the first hurdles for someone new to Relay to
<a href="https://en.wikipedia.org/wiki/Grok">grok</a>. In REST clients, and GraphQL API clients like Apollo Client, you make a request and that request is
passed through the React tree. E.g.</p>

<p></article>
<a href='/images/omakase-relay/tree.png' style="">
  <img src="/images/omakase-relay/tree.png" alt="REST inspired props" style="width:100%;">
</a>
<article class="post">
</p>

<p>This means most components know more about the request than it probably needs, as it may be needed to pass on to
the component's children. This can lead to over-fetching, or even worse, not knowing if you can delete or refactor
a component.</p>

<p>Data masking solves this by hiding data that the component didn't request. I've still yet to find the right visual
abstraction, but I feel this just about pays for itself.</p>

<p></article>
<a href='/images/omakase-relay/isolation.png' style="">
  <img src="/images/omakase-relay/isolation.png" alt="Relay isolation tree" style="width:100%;">
</a>
<article class="post">
</p>

<p>You let Relay be responsible for consolidating all your fragments into a query via the <code>QueryRenderer</code>, causing the
network request, and your response data to be passed your through your component hierarchy. This means Relay
powered components can be safely changed and drastically reduces the chance for unintended consequences elsewhere.</p>

<p>This isolation gives Artsy engineers the safety to work on projects with tens of contributors which regularly
change over time. Providing a guarantee that you can safely work in isolated parts of the codebase without accruing
technical debt.</p>

<p>Relay's container components mean that the components we create are nearly all focused only on the data-driven
aspects of rendering a subset of that GraphQL response into views. It's very powerful.</p>

<a name="Co-location"></a>
<h2>Co-location</h2>

<p>Relay helped us move to one file representing everything a component needed. Effectively a single file now handles
the styles, the actual view content hierarchy, and the exact parts of the API it needs to render itself.</p>

<p><img src="/images/omakase-relay/co-location.png"></p>

<p>In roughly that proportion too, though our most modern code uses the Artsy design system <a href="https://github.com/artsy/palette">Palette</a> which
drastically reduces the need for style in our components.</p>

<p>Co-location's biggest selling point is reducing <a href="https://en.wikipedia.org/wiki/Cognitive_load">cognitive load</a>,
having everything you need in one place makes it easier to understand how a component works. This makes code review
simpler, and lowers the barrier to understanding the entire systems at scale.</p>

<a name="Community"></a>
<h2>Community</h2>

<p>When we adopted Relay, there was no competition - we'd have just used the <code>fetch</code> API. Over time, <a href="https://www.apollographql.com">the Apollo
team</a> came up and really put a considerable amount of effort into lowering the barriers to entry, and
making it feasible to build complex apps easily.</p>

<p>As we hired a set of new engineers, the "Apollo vs Relay" debate came up. Interested in whether we would still
start with Relay today, we ran an audit last year of what it would take to re-create a lot of the infrastructure we
love in Relay atop of the (much more popular) Apollo GraphQL eco-system and saw it was reasonably feasible but
would require a considerable amount of work across many different plugins and tools. With Relay that's all packaged
into one tool, works consistently and has been proven with Facebook having tens of thousands of Relay components in
production.</p>

<p>It's worth highlighting the core difference in community engagement for Apollo vs Relay. Engineers working on
Apollo have great incentives to do user support, and improve the tools for the community - that's their businesses
value. Relay on the other hand is used in many places at Facebook, and the engineers on the team support internal
issues first. IMO, this is reasonable: Relay is an opinionated batteries-included framework for building user
interfaces, and ensuring it works with the baffling amount of JavaScript at Facebook is more or less all the team
has time for.</p>

<p>That leaves space for the OSS community to own their own problems. Notably there's been quite a lot of work going
on in the community-managed <a href="https://github.com/relay-tools">relay-tools</a> GitHub organization.</p>

<a name="Scale.Safety"></a>
<h2>Scale Safety</h2>

<p>Relay puts a lot of emphasis on ahead-of-time safety. The Relay compiler validates your queries against your
GraphQL schema, it emits Flow types for your fragment’s field selections–which we’ve extended to emit TypeScript
types instead, and there are strict naming systems enforced by the compiler. All of these help guide engineers to
build scalable codebases.</p>

<p>How this works in practice is that whenever you need to change the data a component requires, you edit the
fragment, the Relay compiler verifies your query, if successful then your TypeScript types are updated and you can
use the new property in your React component above. See below for a <a href="/images/omakase-relay/relay-process-720.mov">quick video</a> showing the Relay compiler
in action:</p>

<p></article>
<div>
<video controls style="margin: auto 20px; width:100%;">
  <source src="/images/omakase-relay/relay-process-720.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>
</div>
<article class="post">
</p>

<p>Moving all of these checks to be during dev-time means we can feel more confident in our deploys. This is
especially an issue in an iOS native codebase, when any deploy requires a review from Apple and roll-backs are
impossible.</p>

<a name="Cultural.Fit"></a>
<h2>Cultural Fit</h2>

<p>Relay fit well into our team because:</p>

<ul>
<li>We had engineers who were interested in contributing back and extending Relay to work for our cases</li>
<li>We had engineers that were used to the benefits of ahead-of-time error validation tools that compilers offer</li>
<li>We saw a lot of value in a tightly coupling our view structure to our user interface</li>
</ul>


<p>Relay is not without its shortcomings to users outside of Facebook, but Relay has definitely paid for its initial
and occasional complexity for the tightness of our codebases many years down the line.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is TypeScript?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/05/omakase-typescript/"/>
    <updated>2019-04-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/05/omakase-typescript</id>
    <content type="html"><![CDATA[<p>TypeScript is a language from Microsoft which builds on JavaScript. This post is a non-technical overview of what
JavaScript is, how TypeScript extends JavaScript and why we choose to adopt TypeScript at Artsy.</p>

<!-- more -->


<a name="What.is.JavaScript."></a>
<h2>What is JavaScript?</h2>

<p>First up, you can't describe TypeScript without talking about JavaScript. To create a website (and a bunch of other
types of things) you work in three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the
content that will appear on the page, CSS defines the visual style of the page, and JS defines the interactive
behaviours of the page.</p>

<p>We describe having these sets of skills as being a "front-end" developer. You have to understand those three
languages to present anything inside a web browser like Safari, Firefox or Chrome. So, given how popular the web
is, there is a massive demand for people who are good at using these three languages.</p>

<p>There is also the set of skills for the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending a raw data.) You
don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work. We
mostly build our back-ends in Ruby or JavaScript at Artsy.</p>

<a name="What.do.Programming.Languages.do."></a>
<h3>What do Programming Languages do?</h3>

<p>Programming languages are an interesting problem to solve. People read code many, many multiples of times more than
they write it - so developers create languages which are good at solving particular problems with a small amount of
code. Here's an example using JavaScript:</p>

<pre><code class="js">var name = "Danger"
console.log("Hello, " + name)
</code></pre>

<p>The first line makes a variable (a kind of box you can keep things in) and then the second line outputs text to the
console (think DOS, or the terminal) <code>"Hello, Danger"</code>. JavaScript is designed to work as a scripting language,
which means the code starts at the top of the file and then goes through line by line. To provide some contrast,
here is the <a href="https://repl.it/repls/VioletredGlisteningInfo">same behavior</a> in Java, which is built with different
language constraints:</p>

<pre><code class="java">class Main {
  public static void main(String[] args) {
    String name = "Danger";
    System.out.println("Hello, " + name);
  }
}
</code></pre>

<blockquote><p>Note: if you find the naming of Java and JavaScript confusing, it is (they are two completely separate
programming languages, no link at all.) JavaScript was <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">named that way</a> because Java was looking to be
really the next hot language (it did turn out that way for a decade or two, but now JavaScript is usually the
first language people have heard of.)</p></blockquote>

<p>Aside from having a lot more lines, the Java version comes with a lot of words that aren't necessarily about
telling the computer exactly what to do, e.g. <code>class Main {</code>, <code>public static void main(String[] args) {</code>, <code>}</code> and
<code>}</code> again. It also has semi-colons at the end of some lines. Java is aimed at building different things from
JavaScript, and these extra bits of code make sense within the constraints of building a Java app.</p>

<p>To get to my main point though, there is one standout line I'd like us to compare:</p>

<pre><code>// JavaScript
var name = "Danger"
// Java
String name = "Danger";
</code></pre>

<p>Both of these lines declare variables called <code>name</code> which contain the value <code>"Danger"</code>.</p>

<p>In JavaScript you use the abbreviation <code>var</code> to declare a variable. Meanwhile, in Java you need to say <em>what kind
of data</em> the variable contains. In this case the variable contains a <code>String</code>. (A string is a programming term for
a collection of characters. They <code>"look like this"</code>. This <a href="https://www.youtube.com/watch?v=czTWbdwbt7E">5m video</a>
is a good primer if you want to learn more.)</p>

<p>Both of these variables contain a string, but the difference is that in Java the variable can <em>only</em> ever contain a
<em>string</em>, because that's what we said when we created the variable. In JS the variable can change to be <em>anything</em>,
like a number, or a list of dates.</p>

<p>To illustrate:</p>

<pre><code class="js">// Before in JS
var name = "Danger"
// Also OK
var name = 1
var name = false
var name = ["2018-02-03", "2019-01-12"]

// Before in Java
String name = "Danger";
// Not OK, the code wouldn't be accepted by Java
String name = 1;
String name = false
String name = new String[]{"2018-02-03", "2019-01-12"};
</code></pre>

<p>These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was
originally designed to be a small programming language which handled simple interactions on websites. Java on the
other hand was built specifically to make big apps which could run on any computer. Their needs had different
scales, so the language required programmers write different types of code.</p>

<p>Java required programmers to be more explicit with the values of their variables because the programs they expected
people to build were more complex. While JavaScript opted for ease of reading, and aimed to do less.</p>

<a name="What.is.TypeScript."></a>
<h3>What is TypeScript?</h3>

<p>TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above,
let's compare the scripts for "Hello, Danger" in JavaScript vs TypeScript:</p>

<pre><code class="js">// JavaScript
var name = "Danger"
console.log("Hello, " + name)

// TypeScript
var name = "Danger"
console.log("Hello, " + name)

// Yep, you're not missing something, there's no difference
</code></pre>

<p>Due to TypeScript's aim to only <em>extend</em> JavaScript, your normal JavaScript code should work fine with TypeScript.
The things TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are
used in your code, a bit like Java.</p>

<pre><code class="diff">- var name = "Danger"
+ var name: string = "Danger"
console.log("Hello, " + danger)
</code></pre>

<p>This extra <code>: string</code> allow the reader to be certain that <code>name</code> will only be a string. Annotating your variables
also gives TypeScript the chance to verify this for you. This is <em>very</em> useful because keeping track of changes
like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds,
that's a lot to keep track of. Types help programmers be more confident about their code because types catch
mistakes.</p>

<p>Simply speaking, we call these annotations "Types". Hence the name <i>Type</i>Script. The tag-line for TypeScript
is "JavaScript which scales" which is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is. This means you have less need to
understand how every change affects the rest of the program.</p>

<p>In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was
fine because the size and complexities of the programs being built were constrained to just the front-end of
websites. Today though, JavaScript is being used everywhere:</p>

<ul>
<li>Apps like Slack, or Spotify for your computer are built in mostly JavaScript</li>
<li>Some iOS apps, including Artsy's are mostly JavaScript</li>
<li>The back-end and front-end of Artsy.net are JavaScript</li>
</ul>


<p>These are all considerably more complicated to build and understand, adding types drastically reduces the
complexity of making improvements to those programs.</p>

<a name="Why.does.Artsy.use.TypeScript."></a>
<h3>Why does Artsy use TypeScript?</h3>

<p>Artsy definitely isn't the size of Microsoft! Artsy is about 30 engineers, and Microsoft are about 60,000. However,
some of our problems are the same. Developers at Artsy build apps which are made up of thousands of files. A change
to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond
and causing ripples to spread out to the bank.</p>

<p>Typically, the need to ensure there are no bugs is less of a problem for people building websites. Websites are
easy to make changes to, because if you change the site - everyone gets the update instantly. We also build our iOS
app with JavaScript, but a change to our app requires Apple to review the changes and for users to download the new
version from the App Store.</p>

<p>This means that the iOS team needs to have more checks that everything is OK before shipping the app to the world.
Using TypeScript gives our team the ability to feel good that the changes we have made are only the changes we
want.</p>

<p>TypeScript isn't the only programming language to tackle the problem of making JavaScript code safer, but it's the
one with the biggest community, allows people to re-use their JavaScript knowledge, can be added in small steps,
and has really good tools to help developers work faster.</p>

<p>These qualities made it worth adding an extra tool to our developers' toolbelt, and we're not the only ones because
TypeScript is growing to be <a href="https://www.wired.com/story/typescript-microsoft-javascript-alternative-most-popular">one of the most popular programming languages in the world</a> with almost 6
million downloads a week.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peril Architecture Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive/"/>
    <updated>2019-04-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive</id>
    <content type="html"><![CDATA[<p>For the <a href="/blog/2017/09/04/Introducing-Peril/">last two years</a>, we've used <a href="https://github.com/danger/peril">Peril</a> to automate quite a lot of process at Artsy. You can see
a full overview of what <a href="https://github.com/artsy/README/blob/master/culture/peril.md">we automate in <code>artsy/README</code></a>. As a service, Peril is a bit of an iceberg
of complexity, most tooling-y developers at Artsy have <a href="https://github.com/artsy/peril-settings/graphs/contributors">contributed</a> to our user-land Dangerfiles
but very few have touched the server itself.</p>

<p>To lower that barrier, I gave our Engineering team a run through of how the server works and how a lot of the
pieces come together. Jump <a href="https://www.youtube.com/watch?v=3HNmiNHCvdA">to YouTube</a> for the video, or click more
for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/3HNmiNHCvdA ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy, 3 years later]]></title>
    <link href="http://artsy.github.io/blog/2019/03/17/three-years-of-react-native/"/>
    <updated>2019-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/17/three-years-of-react-native</id>
    <content type="html"><![CDATA[<p>On Valentine's day in 2014, @alloy made our first commit moving the Artsy Mobile team to JavaScript, and paving the
way to the <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">shared Omakase JavaScript stack across web + iOS</a>. We've done a write-up at <a href="/blog/2016/08/15/React-Native-at-Artsy/">6 months</a>, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/">1 year</a>,
<a href="/blog/2018/03/17/two-years-of-react-native/">2 years</a> and at 2.5 years we collaborated on a React Native conference with Facebook which features a <a href="http://artsy.net/x-react-native">very long
Q&amp;A</a> session with the people who worked on, and with our React Native stack.</p>

<p>Our experience has been really positive building a single platform data-driven app. We've been able to drastically
increase the number of contributors to the codebase and with minimal guidance, web-developers are able to be
productive and ship features to our iOS apps.</p>

<p>That said, for this 3 year anniversary, I want to dive deeper into some of the less positive aspects of our
transition. We think these trade-offs are worth it, and that this may be what a successful cultural transition
eventually looks like for some companies.</p>

<!-- more -->


<a name="De-nativification"></a>
<h2>De-nativification</h2>

<p>When adopting React Native, we de-emphasized iOS as a unique platform for Artsy.</p>

<p>From an engineering team's perspective, we think of it as skill <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#de-silo-engineers">de-siloing</a>. Prior to the move, if you
were on the mobile team you only worked on the iOS apps. This meant you had a limited scope to make change at
Artsy. This comes from two factors:</p>

<ul>
<li>Skills in Obj-C and Swift are only useful in the context of Apple's platforms.</li>
<li>Internally and externally, Artsy is considered a website first.</li>
</ul>


<p>Within 2 years we had de-siloed mobile engineering completely. We started with a team of 5 experienced native iOS
developers and by the end everyone had very solid skills across the board in JavaScript, React, GraphQL and the
build tools we'd need to make it all come together. These engineers kept their native skills, but they became
frozen in time.</p>

<p>With time, we redistributed the native engineers across many teams, with the native Engineers effectively acting as
a conduit for ensuring that we keep quality high and providing guidance to the rest of that team on how to make it
feel right. A simple way to think of it, is that the native engineer's job was to make sure we still conformed to
the <a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human Interface Guidelines</a> to ensure
the user experience is consistent with the platform and the user’s expectations.</p>

<p>We're reasonably lucky here too, the mobile team at Artsy has pre-dominantly hired folks interested in improving
behind-the-scenes (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">Roads and Bridges</a> style) infrastructure. Once we had wrapped up the move, we effectively
took all of our native product developers and moved them into JavaScript platform infrastructure roles.</p>

<p>This was one of the major blocking points for AirBnB's adoption of React Native, specifically their native teams
felt uncomfortable at the introduction of JavaScript and a whole new toolchain inside their apps. There are people
who really love being a product developer in a native codebase, and React Native as a technology will de-value that
as more work would happen in JavaScript.</p>

<p>(Note: this is a gross simplification, and me reading between the lines, you should read from the horse’s mouth and
check out <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">Airbnb’s posts</a> (and <a href="https://ashfurrow.com/blog/airbnb-and-react-native-expectations/">Ash's continuation</a> on the subject ))</p>

<p>After a year of adopting React Native, the ex-mobile team used to joke that no-one enjoyed working in the native
codebase anymore. They still did. Three years down the line, with most screens now in React Native, that's not a
joke anymore.</p>

<p>This has consequences.</p>

<a name="Platform.Concerns"></a>
<h2>Platform Concerns</h2>

<p>De-siloing our mobile team obviously wasn't without its risk. In expanding the scope of our mobile engineering
team, and opening up the iOS app for contributions to the rest of the company we:</p>

<ul>
<li>Moved the engineers with a native focus to act more like platform engineers vs product engineers.</li>
<li>Had iOS native platform engineers with the skills to now also work on the web's platform.</li>
</ul>


<p>This is what started to make our third year tricky. In Artsy, web is the <a href="https://en.wikipedia.org/wiki/The_squeaky_wheel_gets_the_grease">squeaky wheel</a>.</p>

<p>After figuring out the JavaScript infrastructure for React Native on iOS, we replicated that infrastructure on the
web to consolidate tooling and ideas across all of Artsy. We call that infrastructure for both <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">the Artsy
Omakase</a>. Maintaining, and keeping the infrastructure up-to-date on the web side is a much bigger task and
requires a lot more engineering time.</p>

<p>The web-aspect of the Omakase has more client consumers (1 iOS app vs 3 large websites), and its corresponding repo
has more than double the number of commits per day on average. The web team has its own people running and
improving infrastructure, which affects the iOS side too.</p>

<p>We explicitly worked towards shared common infrastructure across all front-end at Artsy. It wasn't surprising when
the aspect with the most company focus became much larger and more complex. What creates tricky constraints are
that the few people with the interest and skills to work on our React Native infrastructure also happen to have the
skills to work on the web problems too.</p>

<p>Those web problems tend to be a lot more valuable to the business.</p>

<p>There's some work that can be done to benefit both, but in the last year it has been hard to prioritise
iOS-specific platform work. For example, it took almost a year to get around to upgrading our version of React
Native. This is a pretty risky place to be for a platform which we care about.</p>

<p>At the end of 2018, we came to the conclusion that this was something we wanted to work to improve. So, we
specifically brought back an explicit iOS-specific culture to Artsy - when we split our front-end practice into web
and <a href="https://github.com/artsy/README/commit/95c9b93ab966ed269b5ebd9f0bdec8d2434bab52#diff-342d3433f36fbedadc5a8f167985fdf3">iOS</a>.</p>

<p>Maybe this is a small admission of failure to the idea of a purely de-silo'd team, but realistically while product
work across the two front-ends teams is consistent - the platform concerns just aren't.</p>

<a name="Keeping.up.with.the.Jobs."></a>
<h2>Keeping up with the Jobs'</h2>

<p>As individual developers, it's much less important for us to keep up to date with the latest Apple developer news.
WWDCs and iOS releases just kinda happen, and we keep moving independently. We still write native code to make use
of any iOS API available when we need to, but right now we don’t go out of our way to try to make use of all the
shiny new things when they are released.</p>

<p>This is a side-effect to the openness of the JavaScript toolchain, and our ability to contribute and fix a lot of
our own problems at JavaScript level instead of needing to dive deeper into the native side to work on problems. We
still support iOS 9, and have very little incentive to bump it - new APIs from Apple just aren't that interesting
anymore.</p>

<p>Without a focused iOS team, it's not easy to pitch for iOS specific projects. This means that features like moving
to Apple's new app store review API or using iOS features which don't exist on web get spoken about in meetings,
but never started. This lack of a focused team makes it really hard to implement fixes to e.g. bad App Store
reviews.</p>

<p>That said, in the last year we did manage to ship a pretty hefty <a href="/blog/2018/03/18/ar/">ARKit feature</a> - which is a positive
example of an iOS-specific feature which is both forward-thinking tech and a super great fit for Artsy's product.
React Native basically played no part in that.</p>

<a name="Community.Disconnection"></a>
<h2>Community Disconnection</h2>

<p>There are maybe four communities at play if you're doing React Native:</p>

<ul>
<li>JavaScript (Babel/TypeScript/Storybooks/VSCode)</li>
<li>React (Relay/Styled Components)</li>
<li>React Native (Mostly people creating cross-platform tools)</li>
<li>Native (Obj-C/Swift/CocoaPods/fastlane etc)</li>
</ul>


<p>It's hard to keep on-top of any one community, and it's very hard to keep on track of four. Realistically, if you
want to be writing apps at the level of quality we want to - you need to, though.</p>

<p>Artsy's principal of <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">owning our dependencies</a> means involved in all of these communities, however it's
hard to engage in the native community with too much excitement anymore. Most of their problems aren't the same as
ours anymore, and the dependencies we want to improve live in the JavaScript realms.</p>

<a name="Universal.Issues."></a>
<h2>Universal Issues?</h2>

<p>Are these the kind of problems most teams would have? It depends, with React Native at Artsy our focus on:</p>

<ul>
<li>Offering a consistent way to write code across web and iOS, which doesn’t water down either platform.</li>
<li>Ensuring we are able to meaningfully own our dependencies across the stacks.</li>
</ul>


<p>Means that we took on some technical and cultural debt, specifically around the platform aspect of our native
codebase. There are a few levers we can use to fix some of these issues:</p>

<ul>
<li>Let iOS be a bit more webby, by using more JavaScript instead of enforcing stricter platform standards.</li>
<li>Use more of the React Native community’s infra-structure, we generally don't use React Native JavaScript
dependencies. These dependencies usually are cross-platform on Android and iOS which tends to mean making
compromises per-platform. Often we are forcing ourselves into extra work to ensure platform consistency.</li>
<li>Find a way to ensure clearer engineering and product ownership for iOS at Artsy.</li>
<li>Hire more iOS infrastructure engineers to allow for a better mix of native infra vs JavaScript product engineers.</li>
</ul>


<p>How and if we'll tweak these levers will make for an interesting retrospective. Till then, I'd like to finish with
a showcase of some of the React Native work we shipped over the course of the last 4 months:</p>

<p></article>
<a href='/images/react-native-3/rn_3_1.jpg' style="">
  <img src="/images/react-native-3/rn_3_1.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p></article>
<a href='/images/react-native-3/rn_3_2.jpg' style="">
  <img src="/images/react-native-3/rn_3_2.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p>We wouldn't have been able to ship this without React Native.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Public Speaking - Part 2: Where To Start?]]></title>
    <link href="http://artsy.github.io/blog/2016/03/14/public-speaking-part2-where-to-start/"/>
    <updated>2016-03-14T11:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/03/14/public-speaking-part2-where-to-start</id>
    <content type="html"><![CDATA[<p>So you’ve decided <a href="http://artsy.github.io/blog/2016/03/09/public-speaking-part1-is-it-for-me/">you’d like to give speaking a go</a>, or perhaps you were always interested. By now you’re probably wondering where to start.</p>

<p>There are various options depending on what you’re looking for. Would you prefer a smaller, intimate audience or would you like to reach far and wide? Is the topic of your choice suited for a quick talk or would you rather discuss it at length? Let’s have a look.</p>

<!-- more -->


<a name="In-house...Workplace.Knowledge.Share"></a>
<h3>In-house / Workplace Knowledge Share</h3>

<p>Lots of workplaces dedicate some time to knowledge sharing nowadays (and if yours doesn’t, see if you can start one!). They can be technical, for instance at Artsy we host a technical Lunch and Learn weekly. They could also be on any topic, like <a href="https://www.artsy.net/article/natalia-maldonado-introduction-to-office-meditation-5-steps-to-peace-of-mind-at-work">meditation</a>. Anywhere between 5 and 15 minutes in length is common, and they are a perfect opportunity to talk about things you know well. This could be centred around your day to day work, spreading the knowledge to decrease <a href="https://en.wikipedia.org/wiki/Bus_factor">the bus factor</a>, or something from your personal life. I’ve given a talk on <a href="https://speakerdeck.com/mennenia/colour-theory">colour theory in painting</a> once.</p>

<p>If you have a workplace you feel comfortable at, this is definitely a good place to start.</p>

<p>One of the key elements in public speaking that is often forgotten is the fact that the audience wants you to succeed. They’re not there to poke holes or boo you off stage. They are curious to see what you have to say and learn from you. Give them that opportunity.</p>

<p>Even if your goal is towards speaking at bigger events, any chance at practicing and putting together a well flowing talk is good and shouldn’t be ignored.</p>

<a name="Local.meet-ups"></a>
<h3>Local meet-ups</h3>

<p>If you’re in a city that has a thriving meet-up scene, you may want to put your name forward to speak on a certain topic. A UK meet-up, <a href="http://www.meetup.com/NSLondon/">NSLondon</a>, is a great example of this. Many different members of the community have spoken, and it’s created a lovely atmosphere where it feels like you’re exchanging interesting tidbits of information continuously. Also for newcomers it’s created a welcoming atmosphere, as the people speaking are often people they know or “just like them”.</p>

<p>If you have a meet-up with a similar positive vibe, there’s no reason not to have a chat with the organisers and see what the next steps would be. It might even be well worth practicing a talk here, for when you’ve got a bigger event coming up and you would like feedback. Bare in mind, the audience wants you to succeed!</p>

<p>Sidenote — if your city does not (yet) have a great meet-up, it’s well worth starting one.</p>

<a name="Conferences"></a>
<h3>Conferences</h3>

<p>Often considered the most intimidating of all. People have purchased tickets and possibly travelled from far. The audience is usually in the hundreds, occasionally even more than a thousand. Even the most experienced speakers can get a bit nervous for this.</p>

<p>Funnily enough, my first ever talk, since starting out as a developer, was at a <a href="http://www.iosdevuk.com/">conference</a>. It happened to have a very friendly atmosphere and really wasn’t that scary. I can’t stress enough that, yes, the audience wants you to succeed. I remember talking through my introduction and seeing all the curious, attentive faces. They were there because they were interested. They cared for what I had to say.</p>

<p>I will say that this doesn’t necessarily mean you should go talk about anything your heart desires. Ultimately the attendees are there to learn, so it’s only fair that as speakers you’d tailor your presentation towards your audience. But more on that in Part 3.</p>

<p>To be considered, often conference organisers ask people to submit a CfP (Call for Papers / Call for Proposals). This is your chance to submit details on what you’d like to present on, although they may <a href="http://www.osfeels.com/talk-ideas/">give you suggestions</a>. You usually want to include a preliminary talk title, an abstract, and a bit of background on yourself. If you’ve done any talks before and they happen to have been recorded, it’s worth including the video or otherwise previous slidedecks.</p>

<p>As for how CfPs then get chosen depends on the conference. Most of the time the organisational committee selects talks from the proposal list. Some conferences have <a href="http://www.altconf.com">an independent panel</a> review anonymised proposals or have a system in place where <a href="http://cfp.uikonf.com/about">the community votes</a>. Once it’s been decided, they will get back in touch with you.</p>

<p>Usually conferences are swarmed with CfPs so please don’t be discouraged if it takes a few tries to get picked. It’s understandable to feel rejected and give up, but bare in mind that a friend of mine felt this way yet kept applying. He got his break at NSSpain 2014, and now is incredibly active in the <a href="http://www.meetup.com/swift-language/">San Francisco Swift</a> meet-up scene. All of this got the ball rolling and now he's given talks all around the world. <a href="https://twitter.com/simjp">You might even have heard of him</a>.</p>

<a name="Lightning.talks"></a>
<h3>Lightning talks</h3>

<p>If a CfP is a bit too much to prepare at the moment (we’re all busy) or you didn’t get in, another option is to give a lightning talk if the conference of your choice has slots. When done well, they are great.</p>

<p>A lightning talk is usually capped at 5 minutes, and gives you the time and space to cover one thing well. The best ones I’ve heard, have had one main message to convey and did so excellently.</p>

<p>They require a bit of planning as you <a href="http://quoteinvestigator.com/2012/04/28/shorter-letter/">want to be concise</a>, but will be done before you know it and gives the audience a great point of reference to engage with you. Not to mention that sometimes you might get asked to do a full talk based off these.</p>

<a name="Preparing.content"></a>
<h3>Preparing content</h3>

<p><a href="http://artsy.github.io/blog/2016/03/09/public-speaking-part1-is-it-for-me/">Choosing to publicly speak</a> and where is only half the battle. Deciding the content, formulating an abstract, talk title, and slides are not trivial. But fear not, Part 3 in this series will have you covered. Stay tuned!</p>
]]></content>
  </entry>
  
</feed>
