<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: graphql | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-01-15T14:43:23+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Better GraphQL Error Handling I - Using Custom Directives]]></title>
    <link href="http://artsy.github.io/blog/2020/01/13/graphql-custom-directives/"/>
    <updated>2020-01-13T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2020/01/13/graphql-custom-directives</id>
    <content type="html"><![CDATA[<p>This will be the first in a series of posts about how we used advanced GraphQL tooling and functionality to better
handle errors occurring during query resolution, and better equip clients to reason about such errors.</p>

<p>The goal is to describe our current approach, but also do a deep dive into specific ways we've extended our
<a href="https://github.com/artsy/metaphysics">GraphQL server</a> to help us accomplish that. If you are an interested GraphQL
user, you may find this useful, even if some of the larger context specifically around how we are using it to help
standardize error handling doesn't apply.</p>

<!-- more -->


<a name="Introduction.and.Initial.Context"></a>
<h2>Introduction and Initial Context</h2>

<p>At Artsy, we use GraphQL as our API language of choice. In particular,
<a href="https://artsy.github.io/blog/2018/05/08/is-graphql-the-future/">as</a>
<a href="https://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">we've described</a>
<a href="https://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql/">before</a>, we have an orchestration
layer speaking GraphQL, which is what our front-end clients talk to. The GraphQL orchestration layer wraps up
access to several backend services, which are made accessible via a combination of data loaders and
<a href="https://www.apollographql.com/docs/apollo-server/features/schema-stitching/">schema stitching</a>.
<a href="https://www.apollographql.com/docs/apollo-server/federation/introduction/">Apollo Federation</a> is another tool
people are using to bring together disparate backends when using GraphQL in an orchestration layer.</p>

<p>Now, consider the following query, which is a realistic one you might see when accessing a 'product' page.</p>

<pre><code class="javascript">{
  artwork(id: "andy-warhol-skull") {
    mainContentStuff
    biographicalData
    userReviews {
        ...
    }  # Accesses a back-end reviews service
    ...
  }
}
</code></pre>

<p>Part of the <a href="https://graphql.github.io/graphql-spec/">GraphQL spec</a> advises that one should return a 2XX status
code, even if there are exceptions raised when resolving your query. A non-2XX status code from a GraphQL server
would indicate an error with the server itself. Errors that occur during query resolution can be consolidated and
placed in the <code>errors</code> key of the response. This is all
<a href="https://graphql.github.io/graphql-spec/draft/#sec-Errors">advised by the spec</a>, and so is found in most GraphQL
implementations.</p>

<p>Given that this query likely backs a product page, some questions about possible error handling behavior that
immediately arise:</p>

<ul>
<li>If there are multiple fields erroring, which error (if any) is reported to the user?</li>
<li>How does the UI decide whether an error is recoverable? That is, if the <code>mainContentStuff</code> field for a view has
errored, that's probably not recoverable, and appropriate feedback should be displayed. But, if user reviews are
unavailable at this time, it's likely you might still want to render the main view, but with that section
appropriately handled. Is there a generic way to handle this?</li>
</ul>


<a name="Using.a.Directive.to.Eliminate.Ambiguity"></a>
<h2>Using a Directive to Eliminate Ambiguity</h2>

<p>We decided to allow our UI components to declare, using a GraphQL directive, one and only one field in a query to
optionally be the 'principal field'. That is, this is the field that, if there are any errors resolving it, should
result in an entire view rendering an appropriate error state. For web, this means a non-2XX status code and
resulting error page. Any errors occurring in field resolution of non-principal fields should still result in a 2XX
to the user, and the UI should be able to gracefully recover from the missing data. Since we use
React/Relay/GraphQL, and GraphQL queries are colocated with UI components, a GraphQL directive is particularly
useful.</p>

<p>Rewriting the above query, we might do something like:</p>

<pre><code class="javascript">{
  artwork(id: "andy-warhol-skull") {
    mainContentStuff @principalField
    biographicalData
    userReviews {
        ...
    }  # Accesses a back-end reviews service
    ...
  }
}
</code></pre>

<p>This would mean that any errors occuring in resolving <code>mainContentStuff</code> would result in either a 500 status code
and error page to the user, or possibly a more specific error and status code. However, any errors occurring in
resolving user reviews or other fields, would not cause a 500 and error page. Instead, there would be a 200 and the
UI would render. This means that our UI components should generally be defensive about their incoming props being
<code>null</code> (which is likely what you'd see when the corresponding field errors during query resolution). Using
TypeScript and
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html">strict null checking</a> can help
make your UI bulletproof to these sorts of issues.</p>

<p>With this context, let's look at how we implement a custom <code>@principalField</code> GraphQL directive. Future posts in
this series talking about custom GraphQL functionality will likely skip this intro section.</p>

<a name="Implementing.a.Custom.GraphQL.Directive"></a>
<h2>Implementing a Custom GraphQL Directive</h2>

<p>First, we have a new directive that we'd like to add to our schema. That is, we'd like a client to be able to
specify <code>@principalField</code> alongside any field, and have that query be validated correctly by the server. You can
<a href="https://metaphysics-staging.artsy.net/?query=%7B%0Aartwork(id%3A%22andy-warhol-skull%22)%20%40nonExistentDirective%7B%0A%20%20id%0A%7D%7D">see for yourself</a>
how <a href="https://github.com/graphql/graphql-js">graphql-js</a> and
<a href="https://github.com/graphql/express-graphql">express-graphql</a> respond when an unknown directive is specified. Your
GraphQL server implementation may look slightly different.</p>

<p>Turns out, that's pretty easy to do in <code>graphql-js</code>. We declare a variable of type <code>GraphQLDirective</code>, which
operates on a <code>DirectiveLocation.FIELD</code> location:</p>

<pre><code class="javascript">const PrincipalFieldDirective = new GraphQLDirective({
  name: "principalField",
  locations: [DirectiveLocation.FIELD]
})
</code></pre>

<p>and then when we create our schema, we pass this in as <code>directives</code>. Since this will overwrite the
<a href="https://www.apollographql.com/docs/apollo-server/schema/directives/">default directives</a>, we need to append ours.</p>

<p>Something like:</p>

<pre><code class="javascript">import { specifiedDirectives } from "graphql"

new GraphQLSchema({
  directives: [...specifiedDirectives, PrincipalFieldDirective],
  query: ...
  ...
})
</code></pre>

<p>In terms of the SDL for your schema, this is equivalent to the following line:</p>

<pre><code>directive @principalField on FIELD
</code></pre>

<p>That's it! You've successfully added a new directive to your schema. At this point, your GraphQL server will
properly validate and allow a <code>@principalField</code> directive specified by a client alongside any field. Now, we do
want to ensure that if this directive is used, it only appears once in your query. We can accomplish this with a
custom GraphQL validation, which we'll cover in the next post.</p>

<p>So now, how should we implement the functionality of this directive? We decided that we want to use the
<a href="https://github.com/graphql/graphql-spec/blob/master/spec/Section%207%20--%20Response.md#response-format">extensions</a>
part of our GraphQL response to carry this data, a free-form map of data up to the implementor, which is a perfect
fit for this type of optional additional information. If an error occurs in a field tagged with the directive, we
want the response to look something like:</p>

<pre><code class="json">{
  "data": {
    ...
  },
  "extensions": {
    "principalField": {
      "error": ...
    }
  }
}
</code></pre>

<p>In <code>express-graphql</code>, we'll need a method appropriate for the
<a href="https://github.com/graphql/express-graphql#options">extensions</a> option. That looks like:</p>

<pre><code class="javascript">const principalFieldDirectiveExtension = ({ documentAST, result }) =&gt; {
  const path = getPrincipalFieldDirectivePath(documentAST)
  if (path.length) {
    const error = result.errors.find(e =&gt; isEqual(e.path, path))
    if (error) return { principalField: error }
  }
}
</code></pre>

<p>If there is a field designated with the principal field directive, and there is an error at that same path, we'll
return that information, otherwise do nothing.</p>

<p>That's it! We have one additional helper we need to write, <code>getPrincipalFieldDirectivePath</code>. This builds an array
of all the fields encountered to get to one tagged with our directive. It matches the way the
<a href="https://graphql.github.io/graphql-spec/June2018/#sec-Errors">path of an error</a> is constructed by the server, which
enables us to determine if a particular error was associated with a field tagged with the directive.</p>

<p>That looks like:</p>

<pre><code class="javascript">import { visit, BREAK, DocumentNode } from "graphql"

export const getPrincipalFieldDirectivePath = (documentNode: DocumentNode): string[] =&gt; {
  const path: string[] = []
  visit(documentNode, {
    Field: {
      enter(node) {
        const name = (node.alias || node.name).value
        path.push(name)
      },
      leave() {
        path.pop()
      }
    },
    Directive(node) {
      if (node.name.value === "principalField") {
        return BREAK
      }
    }
  })

  return path
}
</code></pre>

<p>This uses a <a href="https://graphql.org/graphql-js/language/#visit">GraphQL visitor</a> to traverse our query, and build up
an array of field names. We can exit early with that path if we encounter our directive.</p>

<a name="Example.Query"></a>
<h2>Example Query</h2>

<p>Let's take a look at how you can use this in practice, in order to help standardize when and with what status a UI
can inform the user of an error.</p>

<p>Something like:</p>

<pre><code>{
  artwork(id: "andy-warhol-skull") @principalField {
    userReviews {
      notes
    }
    contents
    ...
  }
}
</code></pre>

<p>results in:</p>

<pre><code class="json">{
  "data": {
    "artwork": null
  },
  "extensions": {
    "principalFieldError": {
      "httpStatusCode": 404
    }
  }
}
</code></pre>

<p>and the UI can immediately return an appropriate message to the user, if the artwork is not found. If fetching the
artwork is successful, but there's an issue with the reviews, the response will look like:</p>

<pre><code class="json">{
  "data": {
    "artwork": {
      "userReviews": null,
      "contents": ...
    }
  }
}
</code></pre>

<p>We can make sure that our UI components (likely Relay containers) corresponding to <code>userReviews</code> are defensive
about that incoming prop being <code>null</code>. Most likely a zero state ("No Reviews Found"), or just skipping the section
entirely, is appropriate.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>In this way, we can standardize on and remove ambiguity about how a UI handles one or more errors in query
resolution and exactly when such an error should be propagated and made user-facing. We can help ensure that our
UI's are resilient to errors occurring in a leaf.</p>

<p>In the next post, we'll look at how we can write a GraphQL validation rule to ensure that a client specifies at
most one field with the <code>@principalField</code> directive. After that, we'll take a look at how you can successfully
parse and support GraphQL query resolution errors occurring in a variety of contexts such as during stitching.
Putting this altogether, we hope you will come away with a better understanding of how to extend your GraphQL
server with your own custom behaviors, and in particular how we've used these to better log/propagate/present the
potential errors occurring during a query.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From TSLint to ESLint, or How I Learned to Lint GraphQL Code]]></title>
    <link href="http://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint/"/>
    <updated>2019-01-29T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint</id>
    <content type="html"><![CDATA[<p>At the beginning of January we discovered an interesting note in <a href="https://github.com/Microsoft/TypeScript/issues/29288">TypeScript's roadmap</a> about linting:</p>

<blockquote><p>In a survey we ran in VS Code a few months back, the most frequent theme we heard from users was that the linting
experience left much to be desired. Since part of our team is dedicated to editing experiences in JavaScript, our
editor team set out to add support for both TSLint and ESLint. However, we noticed that there were a few
architectural issues with the way TSLint rules operate that impacted performance. Fixing TSLint to operate more
efficiently would require a different API which would break existing rules (unless an interop API was built like
what wotan provides).</p>

<p>Meanwhile, ESLint already has the more-performant architecture we're looking for from a linter. Additionally,
different communities of users often have lint rules (e.g. rules for React Hooks or Vue) that are built for
ESLint, but not TSLint.</p>

<p>Given this, our editor team will be focusing on leveraging ESLint rather than duplicating work. For scenarios
that ESLint currently doesn't cover (e.g. semantic linting or program-wide linting), we'll be working on sending
contributions to bring ESLint's TypeScript support to parity with TSLint. As an initial testbed of how this works
in practice, we'll be switching the TypeScript repository over to using ESLint, and sending any new rules
upstream.</p></blockquote>

<p>At Artsy we've been using TSLint for a few years now; it's worked well for us, and we've even written our own
<a href="https://github.com/relay-tools/tslint-plugin-relay">custom rules</a>. However, given the vastness of the JS ecosystem
and how fast it moves, it's easy to recognize this announcement as an exciting moment for tooling simplicity.</p>

<!-- more -->


<p>To give an example, anyone who has built a culture around Airbnb's
<a href="https://github.com/airbnb/javascript">JavaScript style guide</a> will instantly recognize the conundrum they're in
when migrating to TypeScript:</p>

<p><img width="100%" alt="a reddit user discovers their linting rules no longer work" src="https://user-images.githubusercontent.com/236943/51884369-d845b380-233b-11e9-9d2f-102cc8a3a78b.png"></p>

<p>This means that teams maintaining legacy JavaScript codebases will no longer have to <em>also</em> maintain
<a href="https://github.com/palantir/tslint-react">two</a> <a href="https://github.com/yannickcr/eslint-plugin-react">versions</a> of often nearly <a href="https://github.com/prettier/tslint-plugin-prettier">identical</a>
<a href="https://github.com/prettier/prettier-eslint">rule-sets</a>. All of the aggregate culture that builds up around linting can now be shared in a
forward and backward facing way, making the often-daunting process of migrating a codebase from JavaScript to
TypeScript a much easier sell.</p>

<p>With this in mind we wanted to give the new officially-sanctioned <a href="https://github.com/typescript-eslint/typescript-eslint">typescript-eslint</a> project a
spin and document our findings.</p>

<a name="Setup"></a>
<h3>Setup</h3>

<p>To get started, install the necessary dependencies:</p>

<pre><code class="sh">$ yarn install -D eslint typescript @typescript-eslint/eslint-plugin
</code></pre>

<p>Then create a new <code>.eslintrc.js</code> and add a bit of setup:</p>

<pre><code class="js">module.exports = {
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint"],
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parserOptions: {
    ecmaVersion: 6,
    project: "./tsconfig.json",
    sourceType: "module"
  }
}
</code></pre>

<p>Note that <code>parserOptions.project</code> points to your <code>tsconfig.json</code> file:</p>

<pre><code class="json">{
  "compilerOptions": {}
}
</code></pre>

<p>Next, add a bit of TypeScript to a file</p>

<pre><code class="sh">$ echo "export const foo: any = 'bar'" &gt; index.ts
</code></pre>

<p>and run the linter:</p>

<pre><code class="sh">$ yarn eslint . --ext .ts,.tsx

~/index.ts
  1:12  warning  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

✖ 1 problem (0 errors, 1 warnings)
</code></pre>

<p>Very nice!</p>

<p>Now lets expand the example a bit and add something more sophisticated, which in Artsy's use-case is commonly
GraphQL:</p>

<pre><code class="sh">$ yarn add -D eslint-plugin-graphql graphql-tag apollo
</code></pre>

<p>Update <code>tsconfig.json</code> and let it know we'll be using <code>node</code> for imports:</p>

<pre><code class="json">{
  "compilerOptions": {
    "moduleResolution": "node"
  }
}
</code></pre>

<p>In <code>.eslintrc.js</code> add these rules (while noting the addition of <code>graphql</code> to <code>plugins</code> and
<code>graphql/template-strings</code> under <code>rules</code>):</p>

<pre><code class="js">const path = require("path")

module.exports = {
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint", "graphql"],
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parserOptions: {
    ecmaVersion: 6,
    project: "./tsconfig.json",
    sourceType: "module"
  },
  rules: {
    "graphql/template-strings": [
      "error",
      {
        schemaJsonFilepath: path.resolve(__dirname, "./schema.json"),
        tagName: "graphql"
      }
    ]
  }
}
</code></pre>

<p>For GraphQL to know what to lint, we'll need a schema. Thankfully the
<a href="https://etmdb.com/graphql">Ethiopian Movie Database</a> has our back :)</p>

<pre><code class="sh">$ yarn apollo service:download --endpoint https://etmdb.com/graphql
  ✔ Loading Apollo Project
  ✔ Saving schema to schema.json
✨  Done in 2.18s.
</code></pre>

<p>Back in <code>index.ts</code>, add this bit of code:</p>

<pre><code class="js">import graphql from "graphql-tag"

export const MovieQuery = graphql`
  query MoveQuery {
    allCinemaDetails(before: "2017-10-04", after: "2010-01-01") {
      edges {
        nodez {
          slug
          hallName
        }
      }
    }
  }
`
</code></pre>

<p>And run the linter:</p>

<pre><code class="sh">$ yarn eslint . --ext .ts,.tsx

~/index.ts
  7:9  error  Cannot query field "nodez" on type "CinemaDetailNodeEdge". Did you mean "node"?  graphql/template-strings

✖ 1 problem (1 error, 0 warnings)
</code></pre>

<p>Ahh yes, I meant <a href="https://i.redd.it/tfugj4n3l6ez.png"><code>node</code></a>.</p>

<a name="Bonus:.VSCode.Integration"></a>
<h3>Bonus: VSCode Integration</h3>

<p>As developers, we like our tools to work for us, and in 2019 the tool that <em>seems</em> to do that best just happens to
be a brilliant open source product from Microsoft. There were a couple unexpected configuration issues when we were
setting this up, but thankfully they're easy fixes.</p>

<pre><code class="sh">$ mkdir .vscode &amp;&amp; touch .vscode/settings.json
</code></pre>

<p>Then add a couple settings:</p>

<pre><code class="json">{
  "editor.formatOnSave": true,
  "eslint.autoFixOnSave": true,
  "eslint.validate": [
    {
      "language": "javascript",
      "autoFix": true
    },
    {
      "language": "javascriptreact",
      "autoFix": true
    },
    {
      "language": "typescript",
      "autoFix": true
    },
    {
      "language": "typescriptreact",
      "autoFix": true
    }
  ],
  "tslint.enable": false
}
</code></pre>

<p>Format on save, fix on save, <em>autofix</em> on save, tell ESLint to recognize <code>.ts</code> (and <code>.tsx</code>, for the React folks)
then disable <code>tslint</code> so that <code>eslint</code> can do its thing:</p>

<p><img width="698" alt="eslint displaying graphql error in VSCode IDE" src="https://user-images.githubusercontent.com/236943/51884366-d380ff80-233b-11e9-8128-6c39e210dd31.png"></p>

<p>Now ESLint will show you right where your GraphQL error is from within VSCode. Pretty sweet.</p>

<p>Be sure to read <a href="https://eslint.org/blog/2019/01/future-typescript-eslint">The future of TypeScript on ESLint</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL: Union vs. Interface]]></title>
    <link href="http://artsy.github.io/blog/2019/01/14/graphql-union-vs-interface/"/>
    <updated>2019-01-14T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/14/graphql-union-vs-interface</id>
    <content type="html"><![CDATA[<p>At Artsy we’ve been moving towards GraphQL for all of our new services. Acknowledging GraphQL is a relatively new
technology, we faced some challenging questions as we were developing one our most recent services.</p>

<p>Naively as my first attempt to define GraphQL types and schemas, I naturally tried to map our database models to
GraphQL types. While this may work for lot of cases, we may not be utilizing some of the useful features that come
with GraphQL that can make the consuming our data a lot easier.</p>

<a name="GraphQL:.Interface.or.Union."></a>
<h2>GraphQL: Interface or Union?</h2>

<p>Think of the case where we are trying to expose search functionality and the result of our search can be either a
<code>Book</code> , <code>Movie</code> or <code>Album</code>. One way to think about this is to have our search query return something like:</p>

<!-- more -->


<pre><code class="js">search(term: "something") {
  books {
    id
    title
    author
  }
  movies {
    id
    title
    director
  }
  albums {
    id
    name
  }
}
</code></pre>

<p>While ☝️ works, we can’t rank the result based on relevance in one result set. Ideally, we would return one result
set that can have different types in it. A naive approach for this could be to only return one type in the results:</p>

<pre><code class="js">search(term: "something") {
  results {
    id
    name
    author   // when a book
    director // when a movie
    title    // when a movie/book
  }
}
</code></pre>

<p>We could have a single object that has all these values as optional properties:</p>

<pre><code class="js">type Result {
  id: ID!
  name: String!

  // All of the optional data, available as nullable types
  author: String
  director: String
  title: String
}
</code></pre>

<p>But returning these Result objects would be very messy on the server and for clients, plus it would undermine using
GraphQL's type system.</p>

<p>There are two main solutions in the GraphQL toolkit for this problem:
<a href="https://graphql.org/learn/schema/#union-types">Unions</a> and
<a href="https://graphql.org/learn/schema/#interfaces">Interfaces</a>.</p>

<a name="Union"></a>
<h3>Union</h3>

<p>GraphQL interfaces are useful to solve problems like above where we want to have the returned type possibly from
different types.</p>

<p>For this to work, we can define a <code>Union</code> type that can resolve to either one of <code>Book</code>, <code>Movie</code> or <code>Album</code> and
then each type can have its own set of fields.</p>

<p>In <code>graphql-ruby</code> you can define Unions with:</p>

<pre><code class="ruby">class Types::Movie &lt; Types::BaseObject
  field :id, ID, null: false
  field :title, String, null: false
  field :director, String, null: false
end

class Types::Book &lt; Types::BaseObject
  field :id, ID, null: false
  field :title, String, null: false
end

class Types::Album &lt; Types::BaseObject
  field :id, ID, null: false
  field :name, String, null: false
end

class SearchResultUnionType &lt; Types::BaseUnion
  description 'Represents either a Movie, Book or Album'
  possible_types Book, Movie, Album
  def self.resolve_type(object, _context)
    case object
    when Movie then Types::Movie
    when Book then Types::Book
    when Album then Types::Album
    else
      raise "Unknown search result type"
    end
  end
end
</code></pre>

<p>With the above change you can now query for search results and use specific fragments for different result type:</p>

<pre><code class="js">query {
  search(term: "something") {
    ... on Movie {
      __typename
      id
      title
    }
    ... on Book {
      __typename
      id
      title
    }
    ... on Album {
      __typename
      id
      name
    }
  }
}
</code></pre>

<pre><code class="json">{
  "data": [
    {
      "__typename": "Movie",
      "id": 1,
      "title": "Close-Up"
    },
    {
      "__typename": "Album",
      "id": 2,
      "name": "Dark Side Of The Moon"
    }
  ]
}
</code></pre>

<a name="Interface"></a>
<h3>Interface</h3>

<p>Unions are useful when we are trying to group different types together in one field. Now let’s think of the case
where we are trying to expose models of the same Type that can have different fields populated.</p>

<p>For example a music <code>Instrument</code> can have strings or not. If it has strings we want to mention how many strings it
has in <code>numberOfStrings</code> field. For any non-string instrument this field would be <code>null</code> in the database.</p>

<p>One way to do this is to have the <code>Instrument</code> Type always have <code>numberOfStrings</code> and in the case of non-string
instruments return <code>nil</code>. Sample result for this would be:</p>

<pre><code class="json">{
  "data": [
    {
      "id": 1,
      "name": "Guitar",
      "numberOfStrings": 6
    },
    {
      "id": 2,
      "name": "Drums",
      "numberOfStrings": null
    }
  ]
}
</code></pre>

<p>The above solution would work, but it will add extra work on the clients to decide if <code>numberOfStrings</code> is even
applicable to this current instrument or not.</p>

<p>The more GraphQL approach for this would be to use an <code>Interface</code>. We can define a generic <code>Instrument</code> interface and
have all the common fields between all instruments defined there. Then we can have each specific category of
instruments define its own special fields and then access those specific fields using fragments.</p>

<p>In <code>graphql-ruby</code> you can define an Interface with:</p>

<pre><code class="ruby">module Types::InstrumentInterface
  include Types::BaseInterface

  description 'A Musical Instrument'
  graphql_name 'Musical Instrument'

  field :id, ID, null: false
  field :name, String, null: false
  field :category, String, null: false

  definition_methods do
    def resolve_type(object, _context)
      case object.category
      when "string" then Types::StringInstrument
      when "drums" then Types::DrumInstrument
      else
        raise 'Unknown instrument type'
      end
    end
  end
end
</code></pre>

<p>Then we can have our specific types implementing this interface.</p>

<pre><code class="ruby">class Types::StringInstrument &lt; Types::BaseObject
  implements Types:: InstrumentInterface

  field :number_of_strings, Integer, null: false
end
</code></pre>

<p>For types that don’t have any extra field, they can just reuse everything from interface.</p>

<pre><code class="ruby">class Types::DrumInstrument &lt; Types::BaseObject
  implements Types:: InstrumentInterface
end
</code></pre>

<p>This way the query for getting instruments can look like</p>

<pre><code class="ruby">query {
  instruments {
    id
    name
    category
    ... on StringInstrument {
       numberOfStrings
    }
  }
}
</code></pre>

<p>Sample response can look like</p>

<pre><code class="json">{
  "data": [
    {
      "id": 1,
      "name": "Guitar",
      "category": "StringInstrument",
      "numberOfStrings": 6
    },
    {
      "id": 2,
      "name": "Drums",
      "category": "StringInstrument"
    }
  ]
}
</code></pre>

<p>One issue we found after doing the above was, since this way we don’t reference <code>StringInstrument</code> and <code>DrumInstrument</code>
types anywhere in our schema, they actually don’t end up showing in the generated schema. For them to show up we
have to add them as <code>orphan_types</code> in the interface. So the interface definition will look like:</p>

<pre><code class="ruby">module Types::InstrumentInterface
  include Types::BaseInterface

  description 'A Music Album'
  graphql_name 'Album'

  field :id, ID, null: false
  field :name, String, null: false
  field :category, String, null: false

  ## Changes
  orphan_types Types::StringInstrument, Types::DrumInstrument

  definition_methods do
    def resolve_type(object, _context)
      case object.category
      when "string" then Types::StringInstrument
      when "drums" then Types::DrumInstrument
      else
        raise 'Unknown instrument type'
      end
    end
  end
end
</code></pre>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>The biggest learning experience for us was to realize that with GraphQL we have the option to decouple our database
modeling with how the data is exposed to consumers. This way when designing our persistence layer, we can focus on
the needs of that layer and then separately think about whats the best way to expose the data to the outside world.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL Stitching 101]]></title>
    <link href="http://artsy.github.io/blog/2018/12/11/GraphQL-Stitching/"/>
    <updated>2018-12-11T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/12/11/GraphQL-Stitching</id>
    <content type="html"><![CDATA[<p>Micro-Services make sense for an engineering team of our size. You can scope a domain of your business to
particular small unit of abstraction like an API. Doing so makes it easy to work in isolation, experiment with new
ideas and evolve in many directions.</p>

<p>We've been <a href="http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/#Artsy.Technology.Infrastructure.2017.-.Splitting.the.Monolith">carefully pushing</a> for years to move away from our single monolithic API, to a collection of
smaller, more focused projects. Our <a href="https://github.com/artsy/README/blob/master/culture/highlights.md#highlights">highlights docs</a> showcase this well. The movement to smaller composable
services works great from an isolated platform/systems perspective but can be a bit tricky to handle with front-end
clients. Until 2018, the way that we've addressed the growing complexity in our service later has been to migrate
the complexity inside our main GraphQL API, <a href="https://github.com/artsy/metaphysics/">metaphysics</a>. Metaphysics is our GraphQL API gateway that
consolidates many API sources into a single service, then extending and interleaving and their data to make clients
easier to write.</p>

<p>However, as more services have been created, and grown - so has metaphysics. This creates a worrying trend, as the
growth of code in metaphysics isn't quite linear.</p>

<p>Our main line-of-thought on how to address this is via GraphQL schema stitching. We've been <a href="https://github.com/artsy/metaphysics/pull/809">running
experiments</a> in stitching for over a year, and have have been running with stitching enabled in production for
a few months.</p>

<!-- more -->


<a name="What.is.Schema.Stitching."></a>
<h2>What is Schema Stitching?</h2>

<p>The core idea behind schema stitching is that because GraphQL talks in type systems, you should be able to merge
type systems from many GraphQL APIs into a single source of truth. Schema stitching came out at the <a href="https://dev-blog.apollodata.com/graphql-tools-2-0-with-schema-stitching-8944064904a5">end of
2017</a> via the <a href="https://github.com/apollographql/graphql-tools/"><code>graphql-tools</code></a> and became production-<a href="https://dev-blog.apollodata.com/the-next-generation-of-schema-stitching-2716b3b259c0">ready in April
2018</a>.</p>

<p>We started experimenting on staging last year and would occasionally run into edge-case issues. This meant the
state of the project would ebb &amp; flow between being blocked, or no-one having the bandwidth to work on it. This was
fine, because our aim was <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#incremental-revolution">incremental evolutions over bold revolution</a>.</p>

<p>Before we dive into implementation details, here's a quick glossary of terms before we start:</p>

<ul>
<li><strong>GraphQL <a href="https://graphql.org/learn/schema/#type-system">Type</a></strong> - the shape of an object exposed from your GraphQL API</li>
<li><strong>GraphQL Schema</strong> - a representation of your GraphQL's type system, containing all types and fields on them</li>
<li><strong>GraphQL Resolver</strong> - every field accessed in a query resolves to a corresponding value, the function doing that
is a resolver</li>
<li><strong>Schema Merging</strong> - taking two GraphQL schemas, and merging all the types and resolvers into one schema</li>
<li><strong>Schema Stitching</strong> - extending a GraphQL Schema programmatically, with the ability to delegate to merged
schemas</li>
</ul>


<p>Stitching is one of the end-goals, but merging may be enough for a lot of cases. Both of the two launch posts above
give a much more in-depth explanation of how everything comes together, but these should be enough for this post.</p>

<a name="How.Do.We.Do.It."></a>
<h2>How Do We Do It?</h2>

<p>We have 5 GraphQL APIs inside the Artsy ecosystem, our aim is to cautiously include these APIs inside metaphysics.
We don't need the entire contents of those APIs, and as you'll learn - we couldn't do that even if we wanted.</p>

<p>The technique we settled on was:</p>

<ol>
<li>Download the schema of each external API into metaphysics' source code</li>
<li>Have each schema trimmed to just the essentials that we need today</li>
<li>Merge in each schema incrementally</li>
<li>Stitch in any desired schema changes</li>
</ol>


<p>Let's dig, with some code into how we do each of these steps.</p>

<a name="Downloading.Schemas"></a>
<h4>Downloading Schemas</h4>

<p>We created a <a href="https://github.com/artsy/metaphysics/blob/1423ee39f8e348805710080a4857e6575d3ddade/scripts/dump-remote-schema.js#L15-L25">pretty minimal script</a> which can be run periodically from a developer's computer.</p>

<pre><code class="js">const destination = "src/data"

const httpConvectionLink = createHttpLink({
  fetch,
  uri: urljoin("https://convection-staging.artsy.net/api", "graphql")
})

introspectSchema(httpConvectionLink).then(schema =&gt; {
  fs.writeFileSync(
    path.join(destination, "convection.graphql"),
    printSchema(schema, { commentDescriptions: true })
  )
})
</code></pre>

<p>The script uses an <a href="https://www.apollographql.com/docs/link/links/http.html">apollo-http-link</a> to grab our schema, and store it in our repo, see
<a href="https://github.com/artsy/metaphysics/blob/master/src/data/convection.graphql"><code>src/data/convection.graphql</code></a>. This means that when someone wants to update to a new version of the
schema, it will go through code review and a normal testing-flow. The trade-off being that it will always be out of
date a little bit, but you can make guarantees about the current schema. This is a reasonable trade-off, as GraphQL
schemas <a href="https://graphql.org/learn/best-practices/#versioninghttps://graphql.org/learn/best-practices/#versioning">should always</a> be forward compatible for queries, and when someone wants to use a new field from another
service they can move the schema definition from <a href="https://github.com/artsy/README/issues/31">the git repo</a>.</p>

<p>This file is the <a href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51">GraphQL SDL</a> representations of the entire type system for that schema. This means we have a
local copy of the schemas, so we can use it for tests for the next few steps.</p>

<a name="Schema.Manipulation"></a>
<h4>Schema Manipulation</h4>

<p>Each API writes for their own domain. This can be problematic when you use a <code>User</code> in one API, which isn't generic
enough to be a <code>User</code> in a global API of all services combined. When thinking about this problem, we created a
<a href="https://github.com/artsy/README/blob/master/playbooks/graphql-schema-design.md#notes">guide for ourselves</a> on how to think about schema design at local and global level.</p>

<p>We use a few of <a href="https://www.apollographql.com/docs/graphql-tools/schema-transforms.html">the transform APIs</a> available in graphql-tools to make the merges work. The first
approach is to force a namespace by prefixing the merged Types with their domain.</p>

<pre><code class="js">export const executableConvectionSchema = async () =&gt; {
  const convectionLink = createConvectionLink()
  const convectionTypeDefs = readFileSync("src/data/convection.graphql", "utf8")

  // Setup the default Schema
  const schema = await makeRemoteExecutableSchema({
    schema: convectionTypeDefs,
    link: convectionLink
  })

  // Remap the names of certain types from Convection to fit in the larger
  // metaphysics ecosystem.
  const remap = {
    Submission: "ConsignmentSubmission",
    Category: "ConsignmentSubmissionCategoryAggregation",
    Asset: "ConsignmentSubmissionCategoryAsset",
    State: "ConsignmentSubmissionStateAggregation",
    SubmissionConnection: "ConsignmentSubmissionConnection"
  }

  // Return the new modified schema
  return transformSchema(schema, [
    new RenameTypes(name =&gt; {
      const newName = remap[name] || name
      return newName
    })
  ])
}
</code></pre>

<p>Another example is to outright remove almost everything in the schema, and to only allow Types and fields which we
know to be useful.</p>

<pre><code class="js">export const executableGravitySchema = async () =&gt; {
  const gravityTypeDefs = readFileSync("src/data/gravity.graphql", "utf8")

  const gravityLink = createGravityLink()
  const schema = await makeRemoteExecutableSchema({
    schema: gravityTypeDefs,
    link: gravityLink,
  })

  // Types which come from Gravity which MP already has copies of.
  // In the future, these could get merged into the MP types.
  const blacklistedTypes = ["Artist", "Artwork"]

  // Gravity's GraphQL contains a bunch of objects and root fields that will conflict
  // with what we have in MP already, this lets us bring them in one by one
  const whitelistedRootFields = ["Query", "recordArtworkView"]

  // Return the new modified schema
  return transformSchema(schema, [
    new FilterRootFields((_type, name) =&gt; {
      return !whitelistedRootFields.includes(name)
    }),
    new FilterTypes(type =&gt; {
      return !blacklistedTypes.includes(type.name)
    }),
    // snip
  ])
})
</code></pre>

<p>We can write tests for this by running <a href="https://github.com/artsy/metaphysics/blob/1423ee39f8e348805710080a4857e6575d3ddade/src/lib/stitching/lib/getTypesFromSchema.ts">a query which returns all of the types</a> in a schema, and validating
what exists:</p>

<pre><code class="js">import { executableGravitySchema } from "../schema"
import { getTypesFromSchema } from "lib/stitching/lib/getTypesFromSchema"

it("Does not include blacklisted types", async () =&gt; {
  const gravitySchema = await executableGravitySchema()
  const gravityTypes = await getTypesFromSchema(gravitySchema)

  expect(gravityTypes).not.toContain("Artist")
  expect(gravityTypes).not.toContain("Artwork")
})
</code></pre>

<p>This one is interesting, we <em>don't</em> want the version of <code>Artist</code> and <code>Artwork</code> from Gravity's GraphQL
implementation - because the hand-rolled <code>Artwork</code> and <code>Artist</code> types which lives in the source code of Metaphysics
right now is a combination of many sources, and front-end-client specific code.</p>

<p>If we allowed the <code>Artist</code> or <code>Artwork</code> to overwrite the existing implementations it would be a massively breaking
change. For example, compare the Artwork type from <a href="https://github.com/artsy/metaphysics/blob/51939d1f8eb0d5a60e6e888bf701e082a9ee3731/src/data/gravity.graphql#L14-L29">Gravity's GraphQL</a> (5 fields) vs <a href="https://github.com/artsy/metaphysics/blob/51939d1f8eb0d5a60e6e888bf701e082a9ee3731/_schema.graphql#L723-L889">Metaphysics'
GraphQL</a> (~90 fields) accidentally switching the types would cripple our front-ends.</p>

<a name="Merging.Schemas"></a>
<h4>Merging Schemas</h4>

<p>There are two classes of schemas involved in our stitching. Local Schemas, which is our existing schema (e.g. the
resolver live inside the current source code), and Remote Schemas (e.g. where you make an API request to run those
resolvers). <a href="https://github.com/artsy/metaphysics/blob/1423ee39f8e348805710080a4857e6575d3ddade/src/lib/stitching/mergeSchemas.ts#L9-L39">Merging a schema</a> has a pretty small API surface and doesn't mind which type of schemas you
merge together.</p>

<pre><code class="js">import { mergeSchemas as _mergeSchemas } from "graphql-tools"
import { executableGravitySchema } from "lib/stitching/gravity/schema"
import { executableConvectionSchema } from "lib/stitching/convection/schema"
import { executableLewittSchema } from "lib/stitching/lewitt/schema"

import localSchema from "../../schema"

export const mergeSchemas = async () =&gt; {
  const convectionSchema = await executableConvectionSchema()
  const gravitySchema = await executableGravitySchema()

  const mergedSchema = _mergeSchemas({
    schemas: [gravitySchema, localSchema, convectionSchema]
  })

  return mergedSchema
}
</code></pre>

<p>It's a pretty simple composition model, makes it real easy to do some verification tests using the same techniques
as above.</p>

<a name="Stitching.Schemas"></a>
<h4>Stitching Schemas</h4>

<p>The next step from merging is stitching. Stitching is about taking the merged schemas and taking data from one and
re-applying it via another API. For example, we have a consignments API (for when you want to sell a work at
auction) and a consignment references the artwork's artist. These live inside an API called convection.</p>

<p>In this case, the consignment has an <code>artist_id</code> which represents an <code>Artist</code> type which lives in metaphysics. We
would like to stitch an Artist in from the local schema, into a <code>ConsignmentSubmission</code> which has come in from a
remote schema.</p>

<p>The API works by using <a href="https://github.com/graphql/graphql-js/pull/1117">Type Extensions</a> which are a way of opening up an existing Type and adding new fields
on it. We want to be working with the highest level abstraction, which in this case is directly writing <a href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51">GraphQL
SDL</a> (basically writing the interface) and then hooking that up to its resolvers.</p>

<p>Here's what that looks like in our app:</p>

<pre><code class="js">export const consignmentStitchingEnvironment = (
  localSchema: GraphQLSchema,
  convectionSchema: GraphQLSchema
) =&gt; ({
  // The SDL used to declare how to stitch an object
  extensionSchema: `
    extend type ConsignmentSubmission {
      artist: Artist
    }
  `,

  // Resolvers which correspond to the above type extension
  resolvers: {
    ConsignmentSubmission: {
      artist: {
        // The required query to get access to the object, e.g. we have to
        // request `artist_id` on a ConsignmentSubmission in order to access the artist
        // at all
        fragment: `fragment SubmissionArtist on ConsignmentSubmission { artist_id }`,
        // The function to handle getting the Artist data correctly, we
        // use the root query `artist(id: id)` to grab the data from the local
        // metaphysics schema
        resolve: (parent, _args, context, info) =&gt; {
          const id = parent.artist_id
          return info.mergeInfo.delegateToSchema({
            schema: localSchema,
            operation: "query",
            fieldName: "artist",
            args: {
              id,
            },
            context,
            info,
            transforms: (convectionSchema as any).transforms,
          })
        },
      },
    },
  },
})
</code></pre>

<p>This file consolidates the two steps of merging and then stitching:</p>

<pre><code class="diff">export const mergeSchemas = async () =&gt; {
  const convectionSchema = await executableConvectionSchema()
+ const convectionStitching = consignmentStitchingEnvironment(localSchema, convectionSchema)

  const gravitySchema = await executableGravitySchema()

  // The order should only matter in that extension schemas come after the
  // objects that they are expected to build upon
  const mergedSchema = _mergeSchemas({
    schemas: [
      gravitySchema,
      localSchema,
      convectionSchema,
+      convectionStitching.extensionSchema,
+    ],
+    resolvers: {
+      ...convectionStitching.resolvers,
+    },
  })

  return mergedSchema
}
</code></pre>

<p>We extend the merge schema function to also include the SDL for our stitching, and de-structure in the extension
resolvers. We're still exploring how to write <em>useful</em> tests for this part.</p>

<a name="Validating.your.changes"></a>
<h2>Validating your changes</h2>

<p>We had some useful tools which were used to make the switch to using schema-stitching in production.</p>

<ol>
<li><p><strong>Stored Queries</strong></p>

<p>In order to validate that the runtime behavior of our queries wasn't changing, we used the <a href="https://github.com/artsy/emission/pull/999">persistent
queries</a> generated by our iOS app Emission to create JSON dumps of the results of many API calls in both
stitched and un-stitched environments in a script and compared the results.</p></li>
<li><p><strong>SDL dump comparison</strong></p>

<p>We can use the GraphQL type system to validate our changes don't break clients. We used a schema dump script to
validate the type system was the same across stitched and un-stitched environments.</p></li>
</ol>


<a name="Alternatives"></a>
<h2>Alternatives</h2>

<p>Our stitching implementation used metaphysics as a local schema - e.g. the merging and the stitching occurred
inside the same source code as our main GraphQL API. This wasn't the only way we cold achieve a single source of
truth, I explored an alternative which is to treat all schemas as remote schemas. Basically having an API gateway
in-front of our API gateway. I called it <a href="https://github.com/orta/incorporeal">incorporeal</a>, it's actually a tiny amount of code - a testament to
modern GraphQL techniques in JavaScript.</p>

<p>The advantage here is that we take reduce the acceleration of growing complexity in Metaphysics completely, because
the merging and stitching occurs outside of it. Metaphysics is merged and stitched in, just as all our other APIs
are.</p>

<p>The downside is that it's another hop to get what you want, and changes could require being updated in more places.
We'd be able to use the above ideas for validating that the API is working as expected.</p>

<a name="In.Production"></a>
<h2>In Production</h2>

<p>Today we stitch all new APIs by default, see <a href="https://github.com/artsy/metaphysics/pull/1327">Kaws' integration</a> PR. We're <em>slowly</em> trying to retro-actively
migrate existing APIs into stitching and then deleting the existing code, but that's real tricky when those APIs
are being used or use advanced features of GraphQL.</p>

<p>We've been using GraphQL <a href="https://github.com/artsy/metaphysics/commit/50b23f1738b9fa9757ff83c2d1e0d265c70e4e90">since mid-2015</a> and we've also used it with Relay for the past two years, this has
meant we have quite a few interesting edge cases in our use of the GraphQL. We got in touch with <a href="https://www.freiksenet.com">Mikhail
Novikov</a> and he contracted to help us with most of these issues and I'd strongly recommend doing the same (with
any OSS dependency, but that's, like, just my opinion man.)</p>

<p>GraphQL Stitching solves the problem of API consolidation in a really well thought out abstraction, and I consider
it one of the most interesting avenues of exploration into what GraphQL will be in the future (see <a href="http://artsy.github.io/blog/2018/05/08/is-graphql-the-future/">Is GraphQL The
Future?</a> for a more philosophical take also.)</p>

<!-- prettier-ignore-start -->




<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where art thou, my error?]]></title>
    <link href="http://artsy.github.io/blog/2018/10/19/where-art-thou-my-error/"/>
    <updated>2018-10-19T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/10/19/where-art-thou-my-error</id>
    <content type="html"><![CDATA[<p><em>Note: This is the text of a presentation given at <a href="https://graphql-finland.fi">GraphQL Finland 2018</a>, as such the
language may in some cases be slightly awkward for a blog post. You can find those slides on
<a href="https://speakerdeck.com/alloy/where-art-thou-my-error">Speaker Deck</a>.</em></p>

<p>GraphQL is still in its early stages and thus these are very exciting times, indeed! Traditionally the GraphQL team
has taken the approach of defining the bare minimum in the specification that was deemed needed and otherwise
letting the community come-up with defining problems and experimenting with solutions for those. One such example
is how metadata about the location in the graph where errors occurred during execution were <a href="https://github.com/facebook/graphql/pull/230">added to the
specification</a>.</p>

<p>This is great in the sense that we still have the ability, as a community, to shape the future of a GraphQL
specification that we all <em>want</em> to use, but on the other hand it also means that we may need to spend significant
amounts of time on thinking about these problems and iterating. Seeing as we all strive to have backwards
compatible schemas, it’s of great importance that we know of the various iterations that people have experimented
with and what the outcome was.</p>

<p>This is our story of thinking about and working with errors, thus far.</p>

<!-- more -->


<p>NOTE: Throughout this talk I’ll use ‘query execution’ to indicate executing a GraphQL document, be it a query or
mutation operation. I have a hard time relating to ‘document execution’, mostly because I don’t see others using
it, but perhaps I’ve just missed it. Come at me, at the bar, and set me straight!</p>

<a name="Errors.vs.errors"></a>
<h2>Errors vs errors</h2>

<p>First of all, I want to take a step back and talk about errors in general. The nomenclature around these can get
confusing, suffice to say that during this session we’ll talk about these two types:</p>

<ul>
<li><p>Errors that occur during query execution, that were unexpected, and <em>could</em> lead to corrupted data. We’ll refer
to these as (top-level) ‘GraphQL errors’, going forward.</p>

<p>These could be due to hardware failures, such as running out of memory or disk space, network failures, or
unexpected upstream data etc.</p>

<p>When these occur, <code>graphql-js</code> will return <code>null</code> for the field that triggered the error and serialize the error
into the top-level <code>errors</code> list, next to the successful response <code>data</code>. (Presumably other implementations
follow this reference implementation.)</p></li>
</ul>


<pre><code class="json">{
  "data": {
    "artwork": {
      "artist": {
        "name": "Vincent van Gogh",
        "leftEarSize": null
      }
    }
  },
  "errors": [
    {
      "message": "An unexpected error occurred",
      "path": ["artwork", "artist", "leftEarSize"]
    }
  ]
}
</code></pre>

<ul>
<li><p>Exceptions to these are errors that are <em>known</em> to occur and are expected to be handled by the user of an API.
We’ll refer to these as ‘exceptions’, going forward.</p>

<p>By default these are treated equally by <code>graphql-js</code> to top-level GraphQL errors, if uncaught.</p></li>
</ul>


<p>We will <strong>not</strong> be speaking about errors that occur <em>outside</em> of query execution, such as network failures reaching
the GraphQL server, parsing a syntactically incorrect document, or passing variables that don’t satisfy the
type-system; as these will all lead to a query being rejected wholesale and are solve-able using traditional means,
such as a <code>4xx</code> HTTP status code or <code>5xx</code> in some cases.</p>

<a name="What.is.the.problem.we...re.trying.to.solve."></a>
<h2>What is the problem we’re trying to solve?</h2>

<p>Because with GraphQL we’re usually requesting data for multiple resources, there may be a situation where some
fields resolve successfully and some may fail. This is also why, when using an HTTP transport layer, the advice is
to always respond with a HTTP 200 (ok) status. Determining how to process the response is left up to the client.</p>

<p>So how <em>do</em> we model errors in such a way that they can be meaningful and in context of their origin?</p>

<ul>
<li><p>What if you want to render partial data?</p>

<ul>
<li><p>Maybe the failed data is unrelated to other components that you were also requesting data for.</p>

<p><img src="/images/2018-10-19-where-art-thou-my-error/partial-data-unrelated-annotated.png" alt="Unrelated component" /></p></li>
<li><p>Or the data that failed was part of a list and other entries can still be rendered just fine.</p>

<p><img src="/images/2018-10-19-where-art-thou-my-error/partial-data-list-annotated.png" alt="Partial list data" /></p></li>
</ul>
</li>
<li><p>Or what if you’d (additionally) like to communicate the error in your interface?</p>

<ul>
<li><p>When the query is in response to a mutation and you’d like to communicate input validation failures.</p>

<p><img src="/images/2018-10-19-where-art-thou-my-error/mutation-validation-error.png" alt="Surface validation error" /></p></li>
</ul>
</li>
</ul>


<a name="Possible.solutions"></a>
<h2>Possible solutions</h2>

<a name="Top-level.GraphQL.errors.and.treating.an.entire.response.as.unusable.when.such.errors.exist"></a>
<h3>Top-level GraphQL errors and treating an entire response as unusable when such errors exist</h3>

<p>Some clients, such as Apollo and Relay Classic, have made the decision to reject a response entirely, by default,
if any top-level GraphQL errors exist. This is because clients can really only fully assume that the response data
is incomplete, not whether or not your application could handle that case.</p>

<p>This may be an ok solution when you’re starting out or all the requested data is part of a single holistic view,
but it quickly breaks down when you want a little more than that.</p>

<a name="Top-level.GraphQL.errors.with.extra.metadata"></a>
<h3>Top-level GraphQL errors with extra metadata</h3>

<p>GraphQL errors only have a single field in <a href="https://facebook.github.io/graphql/draft/#sec-Errors">the specification</a> to provide context around the cause of
the error, which is the <code>message</code> field. However, <a href="https://facebook.github.io/graphql/draft/#sec-Response-Format">the specification</a> also defines a top-level
<code>extensions</code> key, which may hold a map of freeform data for the schema implementors to extend the protocol however
they see fit.</p>

<p>Apollo Server 2.0, for instance, <a href="https://blog.apollographql.com/full-stack-error-handling-with-graphql-apollo-5c12da407210">introduced standardized errors</a> you can throw from your
resolvers, which end up being serialized into the <code>extensions</code> map. An example they give is for bad user input:</p>

<pre><code class="js">import { UserInputError } from "apollo-server"

const resolvers = {
  Query: {
    events(root, { zipCode }) {
      // do custom validation for user inputs
      const validationErrors = {}
      if (!isValidZipCode(zipCode)) {
        validationErrors.zipCode = "This is not a valid zipcode"
      }
      if (Object.keys(validationErrors).length &gt; 0) {
        throw new UserInputError("Failed to get events due to validation errors", { validationErrors })
      }
      // actually query events here and return successfully
      return getEventsByZipcode(zipCode)
    }
  }
}
</code></pre>

<p>Seeing as these extensions are freeform, however, this builds an <strong>implicit</strong> contract between the server and
client that then needs to be abstracted away by additional client code. This is unfortunate, when you think about
it, because GraphQL is meant to explicitly express shapes of data.</p>

<p>The Apollo team acknowledges this by adding:</p>

<blockquote><p>While convenient, the weakness of this approach is that the format of the validation error messages is not
captured by your schema, making it brittle to changes. Unless you maintain tight control of both server and
client, you should keep the error responses as simple as possible.</p>

<p>For mutations, it can be worthwhile defining these validation errors as first class citizens within your schema.</p></blockquote>

<p>(Which we’ll address next.)</p>

<a name="Make..mutation..error.metadata.part.of.schema.as.separate.fields"></a>
<h3>Make (mutation) error metadata part of schema as separate fields</h3>

<p>One <a href="https://www.apollographql.com/docs/guides/schema-design.html#mutation-responses">commonly suggested approach</a> around mutations is to define status metadata on the
response type next to the field of the affected entity. For example, a response type could look like:</p>

<pre><code>type UpdateArtworkMutationResponse {
  success: Boolean!
  message: String!
  artwork: Artwork
}
</code></pre>

<p>Here there’s a boolean that indicates success, an extra message that sheds context on the situation when a failure
occurs, and finally the <code>artwork</code> that an update was attempted to be made to.</p>

<p>Adding these fields to the same namespace makes sense when we’re thinking of the failure case, but what about the
success case? Do we really need a <code>success</code> boolean to indicate that updates to the <code>artwork</code> were made? What
purpose serves the <code>message</code> field, other than possibly being a sign of an overly positive schema that sends you
happy messages?</p>

<p>Finally, this approach only really works for mutations, as their return type acts as a distinct root type to start
a query from. It would be hard to imagine how to apply this to queries.</p>

<a name="Make.error.metadata.part.of.schema.as.separate.field"></a>
<h3>Make error metadata part of schema as separate field</h3>

<p>Similarly, <a href="https://itnext.io/the-definitive-guide-to-handling-graphql-errors-e0c58b52b5e1">another suggested approach</a> is to add an additional <code>error</code> field to the type in
question, which then describes the error that occurred. The previous example could be rewritten like so:</p>

<pre><code>type GenericError {
  message: String!
}

type UpdateArtworkMutationResponse {
  error: GenericError
  artwork: Artwork
}
</code></pre>

<p>If <code>error</code> is not <code>null</code>, something went wrong. This cleans up the namespace a bit, but more importantly this
approach can be applied to queries too:</p>

<pre><code>type PublishedArtworkNotification {
  artwork: Artwork
}

type PublishedArtworkNotificationsPayload {
  error: GenericError
  notifications: [PublishedArtworkNotification]
}

type Query {
  publishedArtworkNotificationsPayload: PublishedArtworkNotificationsPayload!
}
</code></pre>

<p>Neat.</p>

<p>However, and this may just be our use-case, we don’t have partial data at these stages. We’ve either resolved the
data or we have an error. Hence, this approach would mean we’d always have an unneeded <code>null</code> field, which pollutes
the namespace of the type unnecessarily.</p>

<p>Side-note: if you don’t control the server schema, and are using a client that can extend a server schema on the
client, you could try to retrofit top-level GraphQL errors to these suggested error fields into the schema where
they occurred based on the error <code>path</code>, as shown <a href="https://github.com/facebook/relay/issues/1913#issuecomment-358636018">here</a>.</p>

<a name="Recap"></a>
<h2>Recap</h2>

<p>So to quickly recap, ideally we want a solution to:</p>

<ul>
<li>Use GraphQL: Utilize GraphQL to explicitly describe the error data.</li>
<li>In context: Present the error data exactly where the error occurred in the schema.</li>
<li>All operations: Work for both mutations and queries.</li>
<li>Explicit status: Be concise and encourage ‘clean’ types; that is, no pollution of namespaces with fields only
needed in some cases.</li>
</ul>


<a name="Make.exceptions.first-class.citizens.of.your.schema"></a>
<h3>Make exceptions first-class citizens of your schema</h3>

<p>To that end, the final approach we’ll be discussing, and the one that we at Artsy have started adopting, is to give
exceptions their own type and return those instead of the success type, when they occur. To do this we make use of
a union of both the success and the exception type (or multiples thereof) and then query for those.</p>

<p>The benefits are:</p>

<ul>
<li><p>You can further model the exception in an explicit and introspect-able way.</p>

<p>For example, in the case of an HTTP failure to an upstream service, your exception type could include an integer
status-code field and document it as such.</p></li>
</ul>


<pre><code>type Artwork {
  title: String!
}

type HTTPError {
  message: String!
  statusCode: Int!
}

union ArtworkOrError = Artwork | HTTPError

type Query {
  artworkOrError(id: ID!): ArtworkOrError
}
</code></pre>

<pre><code>query {
  artworkOrError("mona-lisa") {
    ... on Artwork {
      title
    }
    ... on HTTPError {
      statusCode
    }
  }
}
</code></pre>

<ul>
<li>You know exactly where the exception occurred in the graph.</li>
</ul>


<pre><code>type Artist {
  artworksOrErrors: [ArtworkOrError]
}

type Query {
  artist(id: ID!): Artist
}
</code></pre>

<pre><code>query {
  artist("leonardo-da-vinci") {
    artworksOrErrors {
      ... on Artwork {
        title
      }
      ... on HTTPError {
        statusCode
      }
    }
  }
}
</code></pre>

<ul>
<li>You can use it for both mutations and queries.</li>
</ul>


<pre><code>type UpdateArtworkMutationResponse {
  artworkOrError: ArtworkOrError
}
</code></pre>

<ul>
<li>All fields will always be captured in the single <code>artworkOrError</code> field <em>or</em>, if no information about the error
is needed, you simply don’t query for it and get back <code>null</code> instead.</li>
</ul>


<pre><code>query {
  artworkOrError("mona-lisa") {
    ... on Artwork {
      title
    }
  }
}
</code></pre>

<a name="How.we.encode.it.into.our.schema"></a>
<h2>How we encode it into our schema</h2>

<p>I should preface this by clearly stating that while have been thinking about this problem for a while now, only
recently have we started rolling these changes out into our schema, so some of these are not yet discoverable in
<a href="http://github.com/artsy/metaphysics">our open-source GraphQL service</a>.</p>

<a name="Types"></a>
<h3>Types</h3>

<p>As shown before, we define a union of the actual result type <em>and</em> the error type. However, we additionally (will)
define a set of error interfaces, which make it possible for clients to query for errors in a more generic way.</p>

<pre><code>interface Error {
  message: String!
}

interface HTTPError {
  message: String!
  statusCode: Int!
}

type HTTPErrorType implements Error &amp; HTTPError {
  message: String!
  statusCode: Int!
}

type Artwork {
  title: String!
}

union ArtworkOrError = Artwork | HTTPErrorType

type Query {
  artworkOrError(id: ID!): ArtworkOrError
}
</code></pre>

<p>We can now still query as shown in the earlier examples:</p>

<pre><code>query {
  artworkOrError("mona-lisa") {
    ... on Artwork {
      title
    }
    ... on HTTPError {
      message
      statusCode
    }
  }
}
</code></pre>

<p>…but we can now also have generic error components that would query like so:</p>

<pre><code>query {
  artworkOrError("mona-lisa") {
    ... on Artwork {
      title
    }
    ...GenericErrorComponent
    ...GenericHTTPErrorComponent
  }
}

fragment GenericErrorComponent on Error {
  message
}

fragment GenericHTTPErrorComponent on HTTPError {
  message
  statusCode
}
</code></pre>

<p>For the record, we have <em>not</em> yet put these interfaces into production, so the nomenclature is not set in stone yet
and I’d love to hear your input on this. Is <code>Error</code> <em>too</em> generic to use as the base error type? Is there a nicer
naming pattern that would allow us to avoid having to suffix concrete types of an error interface with <code>...Type</code>?</p>

<p>Side-note: there’s <a href="https://github.com/facebook/graphql/pull/373">an RFC</a> to the GraphQL specification that would make it possible to
have interfaces implement other interfaces, thus removing the need to keep repeating the fields of
super-interfaces. This RFC has recently been moved to the draft stage, yay!</p>

<a name="Field.naming"></a>
<h3>Field naming</h3>

<p>As you may have noticed, we’re calling these fields <code>something</code> <em>or</em> <code>error</code>. We are mostly doing this to stay
backwards compatible with our existing schema. While we could certainly add exception types to existing union
fields, we can’t change a single type field into a union type field without breaking compatibility.</p>

<p>Instead we may now have 2 versions of a given field:</p>

<ul>
<li>one with the single type field which is nullable, in case an exception occurred</li>
</ul>


<pre><code>query {
  artwork("mona-lisa") {
    title
  }
}
</code></pre>

<ul>
<li>and another that has the error union type</li>
</ul>


<pre><code>query {
  artworkOrError("mona-lisa") {
    ... on Artwork {
      title
    }
    ... on HTTPError {
      statusCode
    }
  }
}
</code></pre>

<p>This duplication is slightly unfortunate, from a clean schema design perspective, but it’s similar to an existing
pattern in the community. For instance, many schemas provide 2 ways to retrieve lists:</p>

<ul>
<li>one as an immediate list:</li>
</ul>


<pre><code>type Query {
  artworks: [Artwork]
}
</code></pre>

<ul>
<li>and one as a ‘connection’ (as defined by the <a href="https://facebook.github.io/relay/graphql/connections.htm">Relay Connection specification</a>)</li>
</ul>


<pre><code>type ArtworkEdge {
  node: Artwork
}

type ArtworksConnection {
  edges: [ArtworkEdge]
}

type Query {
  artworksConnection: ArtworksConnection
}
</code></pre>

<p>So the jury is still out on whether or not that’s a bad way to name things. We’ll have to see after using this for a
while.</p>

<a name="Downside.of.using.a.union"></a>
<h3>Downside of using a union</h3>

<p>One notable downside is that GraphQL scalar types can <em>not</em> be included in unions. Thus, if you have scalar fields
that could lead to exceptions, you will have to ‘box’ those in object types.</p>

<pre><code>type ArtworkPurchasableBox {
  value: Boolean!
}

union ArtworkPurchasableOrError = ArtworkPurchasableBox | HTTPError

type Artwork {
  currentlyPurchasableOrError: ArtworkPurchasableOrError
}
</code></pre>

<p>This is definitely a case where the pattern of defining 2 fields, one with and one without exception types, comes
in handy. Having to always query through the box type is inelegant, to put it softly.</p>

<p>Side-note: there actually is <a href="https://github.com/facebook/graphql/issues/215">an open RFC</a> to the specification to allow scalars in unions, but
it’s still in stage 0 and is in need of a champion in order to proceed. We may end up trying to do so, based on our
actual experiences with these cases where they may need to be boxed.</p>

<a name="Example.of.how.we.consume.query.errors"></a>
<h3>Example of how we consume query errors</h3>

<pre><code class="ts">import { OrderStatus_order } from "__generated__/OrderStatus_order.graphql"
import React from "react"
import { createFragmentContainer, graphql } from "react-relay"

interface Props {
  order: OrderStatus_order
}

const OrderStatus: React.SFC&lt;Props&gt; = ({ order: orderStatusOrError }) =&gt;
  orderStatusOrError.__typename === "OrderStatus" ? (
    &lt;div&gt;
      {orderStatusOrError.deliveryDispatched
        ? "Your order has been dispatched."
        : "Your order has not been dispatched yet."}
    &lt;/div&gt;
  ) : (
    &lt;div className="error"&gt;
      {orderStatusOrError.code === "unpublished"
        ? "Please contact gallery services."
        : `An unexpected error occurred: ${orderStatusOrError.message}`}
    &lt;/div&gt;
  )

export const OrderStatusContainer = createFragmentContainer(
  OrderStatus,
  graphql`
    fragment OrderStatus_order on Order {
      orderStatusOrError {
        __typename
        ... on OrderStatus {
          deliveryDispatched
        }
        ... on OrderError {
          message
          code
        }
      }
    }
  `
)
</code></pre>

<a name="Example.of.how.we.consume.mutation.errors"></a>
<h3>Example of how we consume mutation errors</h3>

<pre><code class="ts">import { SubmitOrder_order } from "__generated__/SubmitOrder_order.graphql"
import { SubmitOrderMutation } from "__generated__/SubmitOrderMutation.graphql"
import { Router } from "found-relay"
import React from "react"
import { commitMutation, createFragmentContainer, graphql, RelayProp } from "react-relay"

interface Props {
  order: SubmitOrder_order
  relay: RelayProp
  router: Router
}

const SubmitOrder: React.SFC&lt;Props&gt; = props =&gt; (
  &lt;button
    onClick={() =&gt; {
      commitMutation&lt;SubmitOrderMutation&gt;(props.relay.environment, {
        mutation: graphql`
          mutation SubmitOrderMutation($input: SubmitOrder!) {
            submitOrder(input: $input) {
              orderStatusOrError {
                __typename
                ... on OrderStatus {
                  submitted
                }
                ... on OrderError {
                  message
                  code
                }
              }
            }
          }
        `,
        variables: { input: { orderID: props.order.id } },
        onCompleted: ({ submitOrder: { orderStatusOrError } }, errors) =&gt; {
          if (orderStatusOrError.__typename === "OrderStatus") {
            props.router.push(
              `/orders/${props.order.id}/${orderStatusOrError.submitted ? "submitted" : "pending"}`
            )
          } else {
            alert(
              orderStatusOrError.code === "unpublished"
                ? "Please contact gallery services."
                : `An unexpected error occurred: ${orderStatusOrError.message}`
            )
          }
        }
      })
    }}
  /&gt;
)

export const SubmitOrderContainer = createFragmentContainer(
  SubmitOrder,
  graphql`
    fragment SubmitOrder_order on Order {
      id
    }
  `
)
</code></pre>

<!--

### Show example of factory code that produces both single and union typed fields

TODO

-->


<a name="Final.thoughts"></a>
<h2>Final thoughts</h2>

<p>As stated before, we having only recently begun rolling out these changes into our production schema. However, much
thought and experimentation has gone into this to ensure we will be able to address all of <em>our</em> needs, at least.</p>

<p>I would love to hear other people’s thoughts on this and definitely feedback if they try to adopt it themselves. As
a community we should openly iterate together, as much as possible, as we try to make the future of GraphQL a great
one and put legit questions to ‘REST’ ;)</p>

<p>For now, I’ll leave you with this message from some internet ‘rando’:</p>

<blockquote><p>@alloy That diff makes a lot of sense to me. I've also seen user errors as a field on the mutation result, but I
like that union makes it explicit that there was either success or failure and in the case of failure provides
rich information that's in your app's domain.</p></blockquote>

<p>-- <a href="https://twitter.com/leeb/status/1020054709694943232">Lee Byron</a></p>
]]></content>
  </entry>
  
</feed>
