<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-02-24T20:35:24+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[At Long Last: A Log Out Button]]></title>
    <link href="http://artsy.github.io/blog/2020/01/15/ios-logout-button-at-last/"/>
    <updated>2020-01-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2020/01/15/ios-logout-button-at-last</id>
    <content type="html"><![CDATA[<p>In 2013, Artsy shipped the first version of our iOS app. Typical for an early-day startup, the app was a "minimum
viable product" (with a big emphasis on "minimum"). One of the features that didn't make the cut was something you
expect to see in most apps: a log out button.</p>

<p>When I joined Artsy a year later, there was still no log out button. And there would be no log out button for
another six years, until today.</p>

<p>I want to talk about this quirk of our app, from both product and technical perspectives. Why wasn't this already
in our app? Why was it so difficult to build? These are interesting questions, and their answers shed light on how
products mature over time. I also want to talk about how we finally managed to prioritize this kinda weird feature
request (spoilers: it was our company-wide hackathon). Let's go!</p>

<!-- more -->


<p>When I say that our app doesn't have a log out button, that's a bit of a fib: it <em>does</em> have a log out button... in
the admin-only debug menu. The reason why this isn't a user-facing feature is that the final step of this
admin-only log out feature is a call to <code>exit(0)</code>, effectively crashing the app. That's <em>one</em> way to make sure that
user-specific state doesn't pollute your app's runtime, but of course it would be ridiculous for a user-facing log
out button to crash the app. The only other way to log out was to uninstall the app, which is <em>not</em> something we
want to encourage users to do.</p>

<p>So Artsy staff could log out of the app, but our normal users couldn't. This quirk was acceptable in the early days
of our app, but as the years wore on, it became less of a quirk and more of a product limitation. Even three months
after creating our new Mobile Experience team, we hadn't yet prioritized this feature. Let's
<a href="https://en.wikipedia.org/wiki/Five_whys">dive into this question</a> a little bit.</p>

<p>The log out button hadn't been prioritized. <strong>Why?</strong> To be honest, we had – and still have – a lot of work to do to
improve the app (<a href="http://artsy.net/jobs">we're hiring, by the way</a>). Among the high-impact work we've been
shipping, the log out button simply never made the cut. <strong>Why?</strong> It turns out be quite complicated to implement a
log out button in our app. <strong>Why?</strong> To answer that, we need to step back and think about software development and
requirements gathering, generally.</p>

<p>Experienced software developers will tell you that it's far, far easier to build a piece of software with a feature
in mind <em>from the start</em> than it is to take an existing piece of software and add something to it that it was never
intended to do. For our app, logging out was something it was never intended to do, and so adding it was
technically difficult. <strong>Why?</strong></p>

<p>Because of <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">state</a>.
When you log in to our app, the state of the app changes: we get a user ID and access token from the Artsy API and
our code assumes that these values never change. This is further complicated by the fact that our app is split into
two pieces: the native code (written in Objective-C and Swift) and the React Native code (written in TypeScript).
You can effectively think of these as <em>two</em> apps that interoperate with each other. The state now has to be managed
across <em>two</em> pieces of software, further complexifying the work to add a log out button.</p>

<p>Returning to the idea of developing features in mind from the start (versus adding them after the fact), our React
Native codebase had always assumed a logged-in user. Adding support for this later on was too difficult (indeed,
our solution was to
<a href="https://github.com/artsy/emission/pull/2027/files#diff-0cc174f9197fd0b06ecbd2eaa0247833R1020">invalidate the entire React Native runtime upon log out</a>).
This wasn't a limitation of React Native, but rather it was a limitation of how we chose to organize our code. If
we'd added a log out button earlier in the product lifetime, it wouldn't have been so difficult. The longer we
waited, the more and more code we wrote that implicitly relied upon our existing limitations.</p>

<p>In this way, the <em>absence</em> of a feature had gained its own inertia. The missing feature became a present absence,
and I think there's more to think about there – maybe for another blog post.</p>

<p>So what we had was a difficult technical problem that wasn't <em>that</em> high of priority and didn't have an obvious
solution. Our product team wasn't feeling the pain, but our colleagues who interface more directly with our users
<em>were</em> feeling it.</p>

<p>Artsy kicked off 2020 with a company-wide Hackathon. We run these events roughly once a year, and they provide a
great opportunity for engineers and non-engineers to work together to build something over a few days. Maybe it's a
brand-new piece of software to help us do our jobs better. Maybe it's a new zine to collect our favourite artworks
from the site? And maybe, just maybe, it's a long-neglected user feature that never made the cut in prioritization
meetings.</p>

<p>Among all the ideas that Artsy staff submitted for the Hackathon, the Artsy iOS Log Out button received the third
most votes.</p>

<p><img src="/images/2020-01-15-ios-logout-button-at-last/idea.png" alt="Screenshot of our Hackathon ideas board" /></p>

<p>I sat down with another Mobile Experience engineer, Brian, and the people who submitted the Hackathon idea. If we
were going to build this, it was worth doing right, so we asked questions and learned more about why users need a
log out button at all. I'll spare you the details, but it suffices to say that I learned a lot.</p>

<p>Brian and I worked on the feature, digging into the internals of our app and the interop between native and React
Native code. Our solution wasn't necessarily the "best" solution, but it worked within the assumptions that the app
has already made. Here's roughly the plan we set out with.</p>

<p>On the React Native side of the app, build a settings screen with the log out button:</p>

<ul>
<li>When the user taps the button, post a notification through <code>NSNotificationCenter</code>.</li>
<li>Also, show the user who they are logged in <em>as</em> on this screen.</li>
</ul>


<p>On the native side of the app, listen for the notification and take the following steps when it's fired:</p>

<ol>
<li>Tear down the React Native bridge (invalidate it and release it).</li>
<li>Tear down the native user interface (set singleton instance to <code>nil</code>).</li>
<li>Get a fresh unauthenticated API token.</li>
<li>Use the token to show the sign in/up flow (set the window's <code>rootViewController</code> property).</li>
</ol>


<p>Invalidating the React Native bridge is quite a dramatic action to take, but it's effective. We chose this solution
because it allows our React Native code to continue assuming that the user ID and access token never change (during
its lifetime, anyway).</p>

<p>We had a few other items to follow-up on, mostly reference cycles that were holding onto invalid singleton
instances in-memory. Here's the log out button in action:</p>

<p><img src="/images/2020-01-15-ios-logout-button-at-last/logout.png" alt="Screenshot of our new log out button!" /></p>

<p>We learned a tonne about the React Native bridge, the existing architecture of our app, and how we'd like to see
that mature going forward.</p>

<p>I said earlier that the longer we waited, the harder it was to build this log out button because more and more of
our existing code relied upon assumptions that the log out button would break. Now that we <em>do</em> hav a log out
button, <em>new code we write needs to take it into account</em>. The assumptions coders can make about this codebase are
shifting over time – this is an experience that I never appreciated while working on minimum viable products. I'm
trying to lean into these shifts and use them to drive further modernizations in our codebase. For instance, I'm
already thinking ahead to how everything will work once our sign in/up flow is moved from Objective-C to React
Native (since the user ID and access token <em>will</em> need to be mutable state).</p>

<p>In case you're curious, all our iOS code is open source. The work to add a log out button is totally open source in
<a href="https://github.com/artsy/emission/pull/2027">these</a> <a href="https://github.com/artsy/eigen/pull/2977">two</a> pull requests.</p>

<p>Any organization structure will lead to features falling through cracks. It just happens, it's the nature of
structured organizations. What we've learned at Artsy is that Hackathons (and cross-team collaboration in general)
are effective "escape hatches" for important-but-not-urgent work to get prioritized. They help our colleagues in
Engineering and other teams get to know each other, get to know our business, and find out what kind of features
our users need – even less-than-glamorous features, like a log out button.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Learning Group]]></title>
    <link href="http://artsy.github.io/blog/2019/12/03/ios-learning-group/"/>
    <updated>2019-12-03T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/12/03/ios-learning-group</id>
    <content type="html"><![CDATA[<p>Regular readers of our blog might be familiar with <a href="https://www.cultureamp.com">Culture Amp</a>, a tool Artsy uses to
collect anonymous feedback and take action on cultural issues (we most recently discussed the tool
<a href="https://artsy.github.io/blog/2019/04/19/having-a-coffee-with-every-engineer/">in this blog post</a>). At a
company-wide level, Culture Amp has helped guide everything from Artsy's evolving culture, to our physical work
spaces, to our support for remote work. At an engineering-team level, we've also been using Culture Amp to guide
our choices in technology, documentation, and training.</p>

<p>In this blog post I'll be detailing a recent learning course we ran to share knowledge about how Artsy builds iOS
software for our entire engineering team.</p>

<!-- more -->


<p>Let's start at the beginning. Earlier this year, Artsy Engineering ran a survey through Culture Amp to get answers
to the following questions:</p>

<ol>
<li>What is our team's opinion on our current technology choices?</li>
<li>What is our team's familiarity with or preparedness for our current technology?</li>
<li>Where are the areas of strength and opportunities for both learning and teaching?</li>
</ol>


<p>There are a lot of things we learned from this survey, and among them was a desire for engineers to better
understand how to build iOS software at Artsy. With a nudge (and support!) from our <em>Peer Learning Working Group</em>,
I set out to create a learning plan. I wasn't starting from scratch – we already ran a few learning groups on
topics ranging from Scala fundamentals to React Hooks. We used the lessons learned from <em>those</em> experiences to
define and deliver a learning plan.</p>

<p>I started by booking five sessions, spread out by a week. I picked a time that was a good fit for as many engineers
as possible, and I scheduled them a month ahead to give people a chance to move their schedules around. Scheduling
them up front was important, to give learners a sense of what to expect; previous learning groups had suffered from
inconsistent schedules, which led to intermittent attendance. I also asked each Tech Lead to make sure at least one
engineer from their team attended.</p>

<p>Next was the actual curriculum. In the spirit of "proudly discovered elsewhere", we actually looked at using
existing learning resources that someone else had already developed. However, since
<a href="https://artsy.github.io/series/react-native-at-artsy/">our iOS stack is a bit unique</a> and I was keen to keep
honing my own skills as a technical educator, we decided to make our own. With the help of our Peer Learning
Working Group, we set learning objectives for the five sessions. Here was the original plan:</p>

<ul>
<li><strong>Week 1</strong>: This week, we will cover how iOS software is developed, QA'd, and deployed. By the end of this
session, all participants should be able to pull the latest code from <a href="https://github.com/artsy/eigen">Eigen</a>
(our native iOS repo) and <a href="https://github.com/artsy/emission">Emission</a> (our React Native repo), see their work
in an iOS simulator, and link the two projects together.</li>
<li><strong>Week 2</strong>: This week, we will cover what makes React Native distinct from React on the web, as well as how Artsy
leverages shared infrastructure (such as our design-system, <a href="https://github.com/artsy/palette">Palette</a>) to make
it easier for engineers to work in either one.</li>
<li><strong>Week 3</strong>: This week, we will cover how to create a new view controller. View controllers are the main unit of
composition for native iOS apps, and we integrate our "Scene" React components <em>as</em> view controllers. This
includes routing between view controller, from both native Objective-C and React Native code.</li>
<li><strong>Week 4</strong>: This week, we will create our own React component to fit within the new view controller from Week 3.
This will be a Relay container, fetching data from our GraphQL API,
<a href="https://github.com/artsy/metaphysics">Metaphysics</a>. We will cover how to fetch data, how to <em>re</em>-fetch data, as
well as how Eigen and Emission integrate together to provide client-side API response caches (both Relay and
others).</li>
<li><strong>Week 5</strong>: This is the final week. Participants are asked to bring an iOS bug from their product team's backlog
that they would like to fix. Pairing is encouraged.</li>
</ul>


<p>Things mostly went to plan. I made sure to provide the learning resources at least a day or two ahead of each
session; this let me respond to feedback from the previous week, and also gave learners a chance to review
materials ahead of time.</p>

<p>Every session was recorded for anyone who missed it. We had a shared Slack channel set up for questions, so
engineers could help each other. I also made sure to provide weekly office hours: this was space for people who
missed sessions to catch up, or to just dig into concepts in more detail. I'll return to the topic of office hours
later in this post.</p>

<p>Around the time of the learning group, I was reading
<em><a href="https://www.amazon.com/Make-Stick-Science-Successful-Learning/dp/0674729013/ref=sr_1_1?keywords=making+it+stick&amp;qid=1575314498&amp;sr=8-1">Make It Stick: The Science of Successful Learning</a></em>.
The book is written for people who want to improve their own learning skills, but it was <em>very</em> helpful to read as
I was developing and delivering this curriculum. Here are a few lessons that I learned from the book that were
helpful while teaching engineers at Artsy about how we build iOS software:</p>

<ul>
<li>If someone tries to do something themselves <em>before</em> being told how to do it, the attempt will strengthen their
understanding of the underlying concept. To put this into practice, I would often ask learners questions that I
didn't expect they could answer yet, and the resulting discussion was always worthwhile.</li>
<li>Interleaving different concepts together helps learners form connections between those concepts. This was
especially important, since a big motivator for using React Native at Artsy was to share skills between web and
iOS codebases. As an example of putting this into practice, I interleaved a discussion of
<a href="https://relay.dev">Relay</a> into our curriculum; I hoped to show learners both a new perspective of Relay, as well
as show them how familiar writing React Native code was to writing React web code.</li>
<li>Allowing for some forgetting to take place before reviewing concepts will
<a href="https://njcideas.wordpress.com/2017/09/22/the-cognitive-science-of-studying-massed-practice-vs-spaced-practice/">help strengthen learner's understanding</a>.
To put this into practice, I would return to topics from a few weeks ago to cement their understanding with
learners.</li>
</ul>


<p>I had to push through some discomfort as an educator, too. Each session ended with homework questions, which we
reviewed at the top of the next session. I would ask each question and then just sit there, in awkward silence,
while everyone looked around for someone to answer. Eventually, inevitably, someone would.</p>

<p>All of the learning materials
<a href="https://github.com/artsy/README/tree/master/resources/mobile/learning-group">are open source</a>. While the materials
are mostly specific to Artsy, they may be of help to others. And regardless, we want to adhere to our
<a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#open-source-by-default">Open Source by Default</a>
principle.</p>

<p>We learned quite a lot from delivering this curriculum – lessons we can apply to our next learning group:</p>

<ul>
<li>Learners appreciated the weekly schedule set upfront, affirming what we learned from previous learning groups.</li>
<li>Learners appreciated having access to the materials ahead of time.</li>
<li>Learners appreciated having the sessions recorded, to be reviewed later (or watched, in case they missed the
session).</li>
<li>Learners appreciated having office hours available; even though the office hours weren't well-attended, learners
appreciated having access to them if they needed to.</li>
<li>Learners even appreciated the awkward silences while I waited for an answer to my questions. (One survey
respondent described it as "like pulling teeth, but helpful.")</li>
<li>Learners are varied in how they want to learn. Some liked going through things together. Some thought we went too
slow. Still others thought we should expect learners to do more work ahead of class.</li>
</ul>


<p>This last point is worth expanding upon. While everyone learns differently, there is a distinction between what
<em>feels</em> effective and what <em>is</em> effective. I tried to structure the course so that it was accessible to as many
types of learners as possible: some like to review materials ahead of time, some like to have them on hand during
the session, etc. Some are in-person, others are remote, still others are reviewing the recording. I could write
another blog post about learning styles, but for now it suffices to say that I aimed for <em>inclusion</em> of as many
different learners as possible while also recognizing that I can't make everyone happy.</p>

<p>As I enter a new chapter of my own career, leading Artsy's new Mobile Experience team, it was helpful to return to
some fundamentals; to get familiar with technology choices that we made years ago
(<a href="https://ashfurrow.com/blog/swift-vs-react-native-feels/">choices which I originally resisted</a>); and to learn from
learners' perspectives as beginners. The future of iOS software at Artsy is very bright, and now every product team
is more prepared than ever to deliver user experiences that are of a quality worthy of art.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peril Architecture Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive/"/>
    <updated>2019-04-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive</id>
    <content type="html"><![CDATA[<p>For the <a href="/blog/2017/09/04/Introducing-Peril/">last two years</a>, we've used <a href="https://github.com/danger/peril">Peril</a> to automate quite a lot of process at Artsy. You can see
a full overview of what <a href="https://github.com/artsy/README/blob/master/culture/peril.md">we automate in <code>artsy/README</code></a>. As a service, Peril is a bit of an iceberg
of complexity, most tooling-y developers at Artsy have <a href="https://github.com/artsy/peril-settings/graphs/contributors">contributed</a> to our user-land Dangerfiles
but very few have touched the server itself.</p>

<p>To lower that barrier, I gave our Engineering team a run through of how the server works and how a lot of the
pieces come together. Jump <a href="https://www.youtube.com/watch?v=3HNmiNHCvdA">to YouTube</a> for the video, or click more
for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/3HNmiNHCvdA ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy, 3 years later]]></title>
    <link href="http://artsy.github.io/blog/2019/03/17/three-years-of-react-native/"/>
    <updated>2019-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/17/three-years-of-react-native</id>
    <content type="html"><![CDATA[<p>On Valentine's day in 2014, @alloy made our first commit moving the Artsy Mobile team to JavaScript, and paving the
way to the <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">shared Omakase JavaScript stack across web + iOS</a>. We've done a write-up at <a href="/blog/2016/08/15/React-Native-at-Artsy/">6 months</a>, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/">1 year</a>,
<a href="/blog/2018/03/17/two-years-of-react-native/">2 years</a> and at 2.5 years we collaborated on a React Native conference with Facebook which features a <a href="http://artsy.net/x-react-native">very long
Q&amp;A</a> session with the people who worked on, and with our React Native stack.</p>

<p>Our experience has been really positive building a single platform data-driven app. We've been able to drastically
increase the number of contributors to the codebase and with minimal guidance, web-developers are able to be
productive and ship features to our iOS apps.</p>

<p>That said, for this 3 year anniversary, I want to dive deeper into some of the less positive aspects of our
transition. We think these trade-offs are worth it, and that this may be what a successful cultural transition
eventually looks like for some companies.</p>

<!-- more -->


<a name="De-nativification"></a>
<h2>De-nativification</h2>

<p>When adopting React Native, we de-emphasized iOS as a unique platform for Artsy.</p>

<p>From an engineering team's perspective, we think of it as skill <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#de-silo-engineers">de-siloing</a>. Prior to the move, if you
were on the mobile team you only worked on the iOS apps. This meant you had a limited scope to make change at
Artsy. This comes from two factors:</p>

<ul>
<li>Skills in Obj-C and Swift are only useful in the context of Apple's platforms.</li>
<li>Internally and externally, Artsy is considered a website first.</li>
</ul>


<p>Within 2 years we had de-siloed mobile engineering completely. We started with a team of 5 experienced native iOS
developers and by the end everyone had very solid skills across the board in JavaScript, React, GraphQL and the
build tools we'd need to make it all come together. These engineers kept their native skills, but they became
frozen in time.</p>

<p>With time, we redistributed the native engineers across many teams, with the native Engineers effectively acting as
a conduit for ensuring that we keep quality high and providing guidance to the rest of that team on how to make it
feel right. A simple way to think of it, is that the native engineer's job was to make sure we still conformed to
the <a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human Interface Guidelines</a> to ensure
the user experience is consistent with the platform and the user’s expectations.</p>

<p>We're reasonably lucky here too, the mobile team at Artsy has pre-dominantly hired folks interested in improving
behind-the-scenes (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">Roads and Bridges</a> style) infrastructure. Once we had wrapped up the move, we effectively
took all of our native product developers and moved them into JavaScript platform infrastructure roles.</p>

<p>This was one of the major blocking points for AirBnB's adoption of React Native, specifically their native teams
felt uncomfortable at the introduction of JavaScript and a whole new toolchain inside their apps. There are people
who really love being a product developer in a native codebase, and React Native as a technology will de-value that
as more work would happen in JavaScript.</p>

<p>(Note: this is a gross simplification, and me reading between the lines, you should read from the horse’s mouth and
check out <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">Airbnb’s posts</a> (and <a href="https://ashfurrow.com/blog/airbnb-and-react-native-expectations/">Ash's continuation</a> on the subject ))</p>

<p>After a year of adopting React Native, the ex-mobile team used to joke that no-one enjoyed working in the native
codebase anymore. They still did. Three years down the line, with most screens now in React Native, that's not a
joke anymore.</p>

<p>This has consequences.</p>

<a name="Platform.Concerns"></a>
<h2>Platform Concerns</h2>

<p>De-siloing our mobile team obviously wasn't without its risk. In expanding the scope of our mobile engineering
team, and opening up the iOS app for contributions to the rest of the company we:</p>

<ul>
<li>Moved the engineers with a native focus to act more like platform engineers vs product engineers.</li>
<li>Had iOS native platform engineers with the skills to now also work on the web's platform.</li>
</ul>


<p>This is what started to make our third year tricky. In Artsy, web is the <a href="https://en.wikipedia.org/wiki/The_squeaky_wheel_gets_the_grease">squeaky wheel</a>.</p>

<p>After figuring out the JavaScript infrastructure for React Native on iOS, we replicated that infrastructure on the
web to consolidate tooling and ideas across all of Artsy. We call that infrastructure for both <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">the Artsy
Omakase</a>. Maintaining, and keeping the infrastructure up-to-date on the web side is a much bigger task and
requires a lot more engineering time.</p>

<p>The web-aspect of the Omakase has more client consumers (1 iOS app vs 3 large websites), and its corresponding repo
has more than double the number of commits per day on average. The web team has its own people running and
improving infrastructure, which affects the iOS side too.</p>

<p>We explicitly worked towards shared common infrastructure across all front-end at Artsy. It wasn't surprising when
the aspect with the most company focus became much larger and more complex. What creates tricky constraints are
that the few people with the interest and skills to work on our React Native infrastructure also happen to have the
skills to work on the web problems too.</p>

<p>Those web problems tend to be a lot more valuable to the business.</p>

<p>There's some work that can be done to benefit both, but in the last year it has been hard to prioritise
iOS-specific platform work. For example, it took almost a year to get around to upgrading our version of React
Native. This is a pretty risky place to be for a platform which we care about.</p>

<p>At the end of 2018, we came to the conclusion that this was something we wanted to work to improve. So, we
specifically brought back an explicit iOS-specific culture to Artsy - when we split our front-end practice into web
and <a href="https://github.com/artsy/README/commit/95c9b93ab966ed269b5ebd9f0bdec8d2434bab52#diff-342d3433f36fbedadc5a8f167985fdf3">iOS</a>.</p>

<p>Maybe this is a small admission of failure to the idea of a purely de-silo'd team, but realistically while product
work across the two front-ends teams is consistent - the platform concerns just aren't.</p>

<a name="Keeping.up.with.the.Jobs."></a>
<h2>Keeping up with the Jobs'</h2>

<p>As individual developers, it's much less important for us to keep up to date with the latest Apple developer news.
WWDCs and iOS releases just kinda happen, and we keep moving independently. We still write native code to make use
of any iOS API available when we need to, but right now we don’t go out of our way to try to make use of all the
shiny new things when they are released.</p>

<p>This is a side-effect to the openness of the JavaScript toolchain, and our ability to contribute and fix a lot of
our own problems at JavaScript level instead of needing to dive deeper into the native side to work on problems. We
still support iOS 9, and have very little incentive to bump it - new APIs from Apple just aren't that interesting
anymore.</p>

<p>Without a focused iOS team, it's not easy to pitch for iOS specific projects. This means that features like moving
to Apple's new app store review API or using iOS features which don't exist on web get spoken about in meetings,
but never started. This lack of a focused team makes it really hard to implement fixes to e.g. bad App Store
reviews.</p>

<p>That said, in the last year we did manage to ship a pretty hefty <a href="/blog/2018/03/18/ar/">ARKit feature</a> - which is a positive
example of an iOS-specific feature which is both forward-thinking tech and a super great fit for Artsy's product.
React Native basically played no part in that.</p>

<a name="Community.Disconnection"></a>
<h2>Community Disconnection</h2>

<p>There are maybe four communities at play if you're doing React Native:</p>

<ul>
<li>JavaScript (Babel/TypeScript/Storybooks/VSCode)</li>
<li>React (Relay/Styled Components)</li>
<li>React Native (Mostly people creating cross-platform tools)</li>
<li>Native (Obj-C/Swift/CocoaPods/fastlane etc)</li>
</ul>


<p>It's hard to keep on-top of any one community, and it's very hard to keep on track of four. Realistically, if you
want to be writing apps at the level of quality we want to - you need to, though.</p>

<p>Artsy's principle of <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">owning our dependencies</a> means involved in all of these communities, however it's
hard to engage in the native community with too much excitement anymore. Most of their problems aren't the same as
ours anymore, and the dependencies we want to improve live in the JavaScript realms.
4</p>

<a name="Universal.Issues."></a>
<h2>Universal Issues?</h2>

<p>Are these the kind of problems most teams would have? It depends, with React Native at Artsy our focus on:</p>

<ul>
<li>Offering a consistent way to write code across web and iOS, which doesn’t water down either platform.</li>
<li>Ensuring we are able to meaningfully own our dependencies across the stacks.</li>
</ul>


<p>Means that we took on some technical and cultural debt, specifically around the platform aspect of our native
codebase. There are a few levers we can use to fix some of these issues:</p>

<ul>
<li>Let iOS be a bit more webby, by using more JavaScript instead of enforcing stricter platform standards.</li>
<li>Use more of the React Native community’s infra-structure, we generally don't use React Native JavaScript
dependencies. These dependencies usually are cross-platform on Android and iOS which tends to mean making
compromises per-platform. Often we are forcing ourselves into extra work to ensure platform consistency.</li>
<li>Find a way to ensure clearer engineering and product ownership for iOS at Artsy.</li>
<li>Hire more iOS infrastructure engineers to allow for a better mix of native infra vs JavaScript product engineers.</li>
</ul>


<p>How and if we'll tweak these levers will make for an interesting retrospective. Till then, I'd like to finish with
a showcase of some of the React Native work we shipped over the course of the last 4 months:</p>

<p></article>
<a href='/images/react-native-3/rn_3_1.jpg' style="">
  <img src="/images/react-native-3/rn_3_1.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p></article>
<a href='/images/react-native-3/rn_3_2.jpg' style="">
  <img src="/images/react-native-3/rn_3_2.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p>We wouldn't have been able to ship this without React Native.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Secrets in a React Native App]]></title>
    <link href="http://artsy.github.io/blog/2018/06/15/cocoapods-keys-react-native/"/>
    <updated>2018-06-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/06/15/cocoapods-keys-react-native</id>
    <content type="html"><![CDATA[<!--
Iɴᴛʀᴏᴅᴜᴄᴛɪᴏɴ
-->


<p>Hi! I'm Erik, a software engineer on the Purchase team. One of the most visible payoffs from Artsy's investments in React Native <a href="https://artsy.github.io/search/?q=react+native">over the past two years</a> has been the opening up of our mobile codebase to contributors like myself coming primarily from web stacks. It's nice to be able to build mobile interfaces with the same declarative API used by so many of our web projects, but sometimes we still need to bridge the divide to our Objective-C and Swift ecosystem. One such case: replacing the app secrets typically loaded from a deploy environment or web developer's <a href="https://www.npmjs.com/package/dotenv">dotenv</a> file.</p>

<!-- more -->


<!--
Mᴀɪɴ Bᴏᴅʏ
-->


<p><a href="https://github.com/artsy/emission">Emission</a> is Artsy's React Native component library. It contains its own native app in the <code>/Example</code> folder, which uses <a href="https://artsy.github.io/blog/2015/01/21/cocoapods-keys-and-CI/">cocoapods-keys</a> to store secrets while still letting us code in the open. In order to expose these keys to our React Native components, however, we must do a fair bit of setup. Here's a straightforward how-to that also makes a quick tour through the iOS ecosystem for web developers looking at the React Native JavaScript runtime today.</p>

<p>Links to examples below come from <a href="https://github.com/artsy/emission/pull/1086/commits/4a2a3e9260e97d791536cf38376a06b0ad0946a8">this commit</a> which adds a key for the Stripe API to Emission. When we are finished, a client app (<code>/Example</code>, <a href="https://github.com/artsy/eigen">Eigen</a>, etc.) will be able to initialize Emission with this secret, which will in turn make it available to React Native components.</p>

<a name="Steps"></a>
<h2>Steps</h2>

<a name="L1..Add.the.key.to.the.app.s.Podfile."></a>
<h4>1. Add the key to the app's Podfile.</h4>

<p>This is the extent of <code>cocoapods-keys</code> official <a href="https://github.com/orta/cocoapods-keys#usage">setup</a>, and after this you <strong>could</strong> set the key via <code>pod keys set &lt;NAME&gt;</code> or <code>pod install</code>... but we have more to do.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Example/Podfile#L63">/Example/Podfile</a>:</p>

<pre><code class="diff">plugin 'cocoapods-keys', {
  :target =&gt; 'Emission',
  :keys =&gt; [
    'ArtsyAPIClientSecret',
    'ArtsyAPIClientKey',
+    'StripePublishableKey',
  ]
}
</code></pre>

<hr />

<a name="L2..Configure.the.library.to.consume.our.new.key"></a>
<h4>2. Configure the library to consume our new key</h4>

<p>We'll need to update the <code>initWithUserId...</code> function — one <strong>fun</strong> part of adjusting to Objective-C is that rather than named functions, we just refer to them by their entire signatures — to expose the new key as a property and add it to <code>constantsToExport</code> (<a href="https://facebook.github.io/react-native/docs/native-modules-ios.html#exporting-constants">docs</a>).</p>

<p>Note that this is happening in our <em>Emission Pod</em>; The pod now expects that key to be available in our <em>consuming</em> Example app as defined above.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Pod/Classes/Core/AREmission.h#L17-L34">/Pod/Classes/Core/AREmission.h</a>:</p>

<pre><code class="diff">// ENV Variables
 #import &lt;React/RCTBridgeModule.h&gt;

 @interface AREmissionConfiguration : NSObject &lt;RCTBridgeModule&gt;

+ @property (nonatomic, copy, readonly, nullable) NSString *stripePublishableKey;

 - (instancetype)initWithUserID:(NSString *)userID
           authenticationToken:(NSString *)token
                     sentryDSN:(nullable NSString *)sentryDSN
+         stripePublishableKey:(NSString *)stripePublishableKey
              googleMapsAPIKey:(nullable NSString *)googleAPIKey
                    gravityURL:(NSString *)gravity
                metaphysicsURL:(NSString *)metaphysics
                     userAgent:(NSString *)userAgent;
</code></pre>

<p><code>AREmission</code>'s implementation (.m) needs to be configured to take this new key- It will be exported to our React Native components as <code>Emission</code>. We make our initializer match the signature defined in the header (.h) file, and add an instance <code>_stripePublishableKey</code> to match the <code>@property</code> declaration.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Pod/Classes/Core/AREmission.m#L24-L60">/Pod/Classes/Core/AREmission.m</a>:</p>

<pre><code class="diff"> @implementation AREmissionConfiguration
 RCT_EXPORT_MODULE(Emission);
 # ...

 - (NSDictionary *)constantsToExport
 {
   return @{
+    @"stripePublishableKey": self.stripePublishableKey ?: @"",
     # ...lots more
   };
 }

 - (instancetype)initWithUserID:(NSString *)userID
            authenticationToken:(NSString *)token
                      sentryDSN:(NSString *)sentryDSN
+          stripePublishableKey:(NSString *)stripePublishableKey
               googleMapsAPIKey:(NSString *)googleAPIKey
                     gravityURL:(NSString *)gravity
                 metaphysicsURL:(NSString *)metaphysics
                      userAgent:(nonnull NSString *)userAgent
 {
     self = [super init];
     _userID = [userID copy];
+    _stripePublishableKey = [stripePublishableKey copy];
     # ... More copies...
     return self;
 }
</code></pre>

<p><em>Why is <code>copy</code> needed at all? See <a href="https://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain/388002#388002">here</a>.</em></p>

<hr />

<a name="L3..Configure.the.example.app.to.expose.the.new.key.to.our.library"></a>
<h4>3. Configure the example app to expose the new key to our library</h4>

<p>After making sure we have imported the keys from <code>cocoapods-keys</code> we update Emission's setup to use the new initializer signature we defined above.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Example/Emission/AppDelegate.m#L109">Example/Emission/AppDelegate.m</a>:</p>

<pre><code class="diff">#import &lt;Keys/EmissionKeys.h&gt;

  - (void)setupEmissionWithUserID:(NSString *)userID accessToken:(NSString *)accessToken keychainService:(NSString *)service;
  {
    # ...
     AREmissionConfiguration *config = [[AREmissionConfiguration alloc]
      initWithUserID:userID
      authenticationToken:accessToken
      sentryDSN:nil
+     stripePublishableKey:keys.stripePublishableKey
      googleMapsAPIKey:nil
      gravityURL:setup.gravityURL
      metaphysicsURL:setup.metaphysicsURL
      userAgent:@"Emission Example"];
    # ...
</code></pre>

<hr />

<a name="L4..Use.that.configured.key.in.a.React.Native.component."></a>
<h4>4. Use that configured key in a React Native component.</h4>

<p><code>Emission</code> is now exposed along with its configured keys via React Native's <a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">NativeModules</a>.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/src/lib/components/bidding/screens/confirmfirsttimebid.tsx#l31">src/lib/Components/Bidding/Screens/ConfirmFirstTimeBid.tsx</a>:</p>

<pre><code class="js">import { NativeModules } from "react-native";
const Emission = NativeModules.Emission || {};

stripe.setOptions({
  publishableKey: Emission.stripePublishableKey
});
</code></pre>

<!--
Cᴏɴᴄʟᴜsɪᴏɴ
-->


<p>That's it! Compared to a familiar dotenv file, <strong>it</strong> certainly means a bit more ceremony here, but we are working through React Native code, its containing Pod <em>and</em> a consuming app. The process is more complicated, but it's also a nice overview of some fundamentals of Objective-C, iOS development and bridging the gap between react and mobile native code.</p>
]]></content>
  </entry>
  
</feed>
