<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-07-23T19:14:45+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Deploys: Super Weird And Totally Normal]]></title>
    <link href="http://artsy.github.io/blog/2020/03/02/ios-deploys-super-weird-totally-normal/"/>
    <updated>2020-03-02T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2020/03/02/ios-deploys-super-weird-totally-normal</id>
    <content type="html"><![CDATA[<p>Software deploys! What a concept. You have some code running somewhere, and you need to get it running somewhere
else. What could possibly go wrong? While web developers have become accustom to some <em>really slick</em> deploy
processes, iOS developers have to work within some very different constraints.</p>

<p>Today I want to explore the differences between deploying iOS software and front-end/back-end web software. Some of
these differences are inherent to how the code gets executed, and some of the differences are incidental to choices
that Apple has made. These are constraints that iOS developers need to work within. As Artsy has adopted React
Native over the past four years, we have had more and more of our web engineering colleagues contributing to our
iOS app. For these web engineers, getting familiar with the iOS deploy constraints is as important as getting to
know Xcode and CocoaPods.</p>

<!-- more -->


<a name="A.Release.Case.Study"></a>
<h2>A Release Case Study</h2>

<p>We're going to use a case study to frame today's discussion. Artsy's Mobile Experience team recently got a ticket
from our Platform team. The nature of the ticket itself doesn't matter, but it involved a change we were making to
our API. I fixed the bug and submitted a pull request, which quickly got merged. We tested the bug fix in our next
beta deploy, and everything looked fine. Great so far.</p>

<p>Artsy releases iOS software on a two-week release cadence, and this bug fix was scheduled to be released to users
the following week. But our back-end team wanted to quickly deploy that API change, which would require the app bug
fix to get released to users <em>first</em>.</p>

<p>So... what to do?</p>

<p>Do we release off-cadence? Or do we push back on our Platform team and ask them to hold off until the scheduled
release?</p>

<p>Let's actually pause for a moment and consider one of the assumptions we made above. If you're a web engineer, the
idea of releasing only every two weeks might seem pretty strange! I mean, why not release continuously? For
example, Artsy's website gets deployed to our staging environment after every merged pull request, and staging then
gets promoted to production several times a day. This process is generally referred to as "continuous delivery",
and <a href="https://www.thoughtworks.com/insights/blog/case-continuous-delivery">it has a lot of advantages</a>. That's why
it's so common among web engineering teams. So why not use continuous delivery on iOS apps?</p>

<a name="The.Executable.Problem"></a>
<h2>The Executable Problem</h2>

<p>There are two reasons we can't use continuous delivery on iOS. First, continuous delivery is only really possible
when you control where the software gets executed (or, in the case of web front-ends, where the client-side code
gets served from). Artsy controls our own servers, so we can deliver web software continuously. The next time a
user makes a web request, they'll get the updated code. However, the Artsy iOS app runs on our users' devices,
instead. We can't push out updates to users' iPhones or iPads in the same way we can push updates to our servers.</p>

<p>iOS apps are binary executables that are distributed through Apple's App Store, and updates to apps have to be
pulled down by devices. Even if <em>most</em> users have automatic updates turned on, those updates are typically
installed overnight. Consequently, there's quite a lag between when we deploy an iOS update and when users run the
code. While it only takes about a week for 80% of our users to update to the latest version, there's a very long
tail after that.</p>

<p><img src="/images/2020-03-02-ios-deploys-super-weird-totally-normal/graph.png" alt="Graph of in-use versions of Artsy's app, illustrating both the quick adoption of new updates by most users and the long tail of old versions that are never updated" /></p>

<p>iOS software is executed in an environment that we don't control, that we can't push updates to, and most
importantly, that we can't roll back deploys on. If we ship a version of our app with a bug, but then ship an
updated version with a fix right away, there is absolutely no guarantee that users will install that update.
<em>Ever</em>. That means that <em>every</em> deploy we make to our iOS software requires a lot of confidence in that code. In
contrast, rolling back a web deploy is quite painless. If we ship a bug to the web, no problem: just roll back the
deploy, fix the bug, and re-deploy with the fix.</p>

<p>(Note: some readers might be wondering why we don't take advantage of over-the-air updates to our React Native
JavaScript bundle. This is definitely possible, but our app is brownfield with some native code and some React
Native code and we haven't yet built out the infrastructure for this. As more and more code shifts to React Native,
we plan to investigate OTA updates to JavaScript bundles.)</p>

<a name="Apple.s.Platform..Apple.s.Rules"></a>
<h2>Apple's Platform, Apple's Rules</h2>

<p>The second reason to deploy iOS software on a schedule, rather than with continuous delivery, depends on the App
Store review process. This is another big difference that takes web engineers a while to get used to. Whenever we
ship a version of our iOS app, we ship it to Apple for review, and then Apple ships it to our users. I'm not going
to debate the utility of Apple as an intermediary – the fact is that they own the iOS platform and these are the
rules they have chosen. If you want to ship iOS software, then you have to abide by Apple's rules.</p>

<p>App Store review isn't exactly QA. I mean, if we were to ship an app update and it crashes upon launch, Apple isn't
likely to approve that update. But if we have a small bug buried somewhere in the app, we can't expect Apple to
find it. Apple is only testing for adherence to their
<a href="https://developer.apple.com/app-store/review/guidelines/">App Store Review Guidelines</a>. Apple is looking for
things like: is the app trying to steal user data? Is the app displaying objectionable material, given its age
rating? Is the app's description and App Store metadata correct? That kind of stuff.</p>

<p>So not only do iOS software developers need a lot of confidence in every deploy, but they also need to abide by
Apple's guidelines.</p>

<p>Alright. Let's return to the case study from earlier.</p>

<a name="Case.Study.Resolution"></a>
<h2>Case Study Resolution</h2>

<p>We had a bug fix in our app, and getting it deployed was blocking an important change to our back-end API. First,
we had to consider that some users simply wouldn't get the update. We had to ask ourselves if this would block the
back-end change entirely – through open discussions with the team, we decided to move forward. Second, we had to
consider the other work that had been merged since our last release. Were we confident in deploying that work
as-is? And what amount of QA would need to be done to ship those changes as well?</p>

<p>That last point is really interesting because there was actually another option. Rather than deploy the app based
off the current <code>master</code> branch (with the bug fix <em>and</em> other work included), we did something a bit clever.
<a href="https://fastlane.tools">fastlane</a>, the tool we use to automate our iOS deploys, will tag each commit that we
submit to the App Store. So rather than deploy the current <code>master</code> branch, which would require very rigorous QA,
we checked out the previous release tag. We then used
<a href="https://www.atlassian.com/git/tutorials/cherry-pick"><code>git cherry-pick</code></a> to apply <em>only</em> the bug fix changes, and
deployed from there.</p>

<p><img src="/images/2020-03-02-ios-deploys-super-weird-totally-normal/slack.png" alt="Screenshot from Slack where I detailed my plan to cherry-pick the commits" /></p>

<p>This isolated the changes we were making to the app and minimized the amount of QA we needed to feel confident in
our release. Even still, we ran through our usual QA script. As I hope I've demonstrated above, it's always better
to be safe than be sorry when it comes to deploying iOS software.</p>

<p>This <code>git cherry-pick</code> approach has its own trade-offs, but it is very effective in the right circumstance. It's an
approach I've only had to use a few times during my time at Artsy, but it's a good approach to be familiar with.
This situation also highlights a benefit of automating iOS deploys: we know <em>exactly</em> which commit each version of
our app is running, making it easy to <code>git cherry-pick</code> with confidence.</p>

<p>I hope I've illustrated how iOS software is a bit different from web software, both inherently and incidentally.
Many of these same quirks apply to Android deploys as well. Mobile software feels closer to software sold in
shrink-wrapped boxes than it does to Docker images shipped to Kubernetes clusters. And that's okay. Different
platforms will always have different constraints. Hopefully by understanding these constraints, mobile and web
engineers can gain a greater empathy for one another and, ideally, share ideas and solutions so we can all learn
and grown together.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[At Long Last: A Log Out Button]]></title>
    <link href="http://artsy.github.io/blog/2020/01/15/ios-logout-button-at-last/"/>
    <updated>2020-01-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2020/01/15/ios-logout-button-at-last</id>
    <content type="html"><![CDATA[<p>In 2013, Artsy shipped the first version of our iOS app. Typical for an early-day startup, the app was a "minimum
viable product" (with a big emphasis on "minimum"). One of the features that didn't make the cut was something you
expect to see in most apps: a log out button.</p>

<p>When I joined Artsy a year later, there was still no log out button. And there would be no log out button for
another six years, until today.</p>

<p>I want to talk about this quirk of our app, from both product and technical perspectives. Why wasn't this already
in our app? Why was it so difficult to build? These are interesting questions, and their answers shed light on how
products mature over time. I also want to talk about how we finally managed to prioritize this kinda weird feature
request (spoilers: it was our company-wide hackathon). Let's go!</p>

<!-- more -->


<p>When I say that our app doesn't have a log out button, that's a bit of a fib: it <em>does</em> have a log out button... in
the admin-only debug menu. The reason why this isn't a user-facing feature is that the final step of this
admin-only log out feature is a call to <code>exit(0)</code>, effectively crashing the app. That's <em>one</em> way to make sure that
user-specific state doesn't pollute your app's runtime, but of course it would be ridiculous for a user-facing log
out button to crash the app. The only other way to log out was to uninstall the app, which is <em>not</em> something we
want to encourage users to do.</p>

<p>So Artsy staff could log out of the app, but our normal users couldn't. This quirk was acceptable in the early days
of our app, but as the years wore on, it became less of a quirk and more of a product limitation. Even three months
after creating our new Mobile Experience team, we hadn't yet prioritized this feature. Let's
<a href="https://en.wikipedia.org/wiki/Five_whys">dive into this question</a> a little bit.</p>

<p>The log out button hadn't been prioritized. <strong>Why?</strong> To be honest, we had – and still have – a lot of work to do to
improve the app (<a href="http://artsy.net/jobs">we're hiring, by the way</a>). Among the high-impact work we've been
shipping, the log out button simply never made the cut. <strong>Why?</strong> It turns out be quite complicated to implement a
log out button in our app. <strong>Why?</strong> To answer that, we need to step back and think about software development and
requirements gathering, generally.</p>

<p>Experienced software developers will tell you that it's far, far easier to build a piece of software with a feature
in mind <em>from the start</em> than it is to take an existing piece of software and add something to it that it was never
intended to do. For our app, logging out was something it was never intended to do, and so adding it was
technically difficult. <strong>Why?</strong></p>

<p>Because of <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">state</a>.
When you log in to our app, the state of the app changes: we get a user ID and access token from the Artsy API and
our code assumes that these values never change. This is further complicated by the fact that our app is split into
two pieces: the native code (written in Objective-C and Swift) and the React Native code (written in TypeScript).
You can effectively think of these as <em>two</em> apps that interoperate with each other. The state now has to be managed
across <em>two</em> pieces of software, further complexifying the work to add a log out button.</p>

<p>Returning to the idea of developing features in mind from the start (versus adding them after the fact), our React
Native codebase had always assumed a logged-in user. Adding support for this later on was too difficult (indeed,
our solution was to
<a href="https://github.com/artsy/emission/pull/2027/files#diff-0cc174f9197fd0b06ecbd2eaa0247833R1020">invalidate the entire React Native runtime upon log out</a>).
This wasn't a limitation of React Native, but rather it was a limitation of how we chose to organize our code. If
we'd added a log out button earlier in the product lifetime, it wouldn't have been so difficult. The longer we
waited, the more and more code we wrote that implicitly relied upon our existing limitations.</p>

<p>In this way, the <em>absence</em> of a feature had gained its own inertia. The missing feature became a present absence,
and I think there's more to think about there – maybe for another blog post.</p>

<p>So what we had was a difficult technical problem that wasn't <em>that</em> high of priority and didn't have an obvious
solution. Our product team wasn't feeling the pain, but our colleagues who interface more directly with our users
<em>were</em> feeling it.</p>

<p>Artsy kicked off 2020 with a company-wide Hackathon. We run these events roughly once a year, and they provide a
great opportunity for engineers and non-engineers to work together to build something over a few days. Maybe it's a
brand-new piece of software to help us do our jobs better. Maybe it's a new zine to collect our favourite artworks
from the site? And maybe, just maybe, it's a long-neglected user feature that never made the cut in prioritization
meetings.</p>

<p>Among all the ideas that Artsy staff submitted for the Hackathon, the Artsy iOS Log Out button received the third
most votes.</p>

<p><img src="/images/2020-01-15-ios-logout-button-at-last/idea.png" alt="Screenshot of our Hackathon ideas board" /></p>

<p>I sat down with another Mobile Experience engineer, Brian, and the people who submitted the Hackathon idea. If we
were going to build this, it was worth doing right, so we asked questions and learned more about why users need a
log out button at all. I'll spare you the details, but it suffices to say that I learned a lot.</p>

<p>Brian and I worked on the feature, digging into the internals of our app and the interop between native and React
Native code. Our solution wasn't necessarily the "best" solution, but it worked within the assumptions that the app
has already made. Here's roughly the plan we set out with.</p>

<p>On the React Native side of the app, build a settings screen with the log out button:</p>

<ul>
<li>When the user taps the button, post a notification through <code>NSNotificationCenter</code>.</li>
<li>Also, show the user who they are logged in <em>as</em> on this screen.</li>
</ul>


<p>On the native side of the app, listen for the notification and take the following steps when it's fired:</p>

<ol>
<li>Tear down the React Native bridge (invalidate it and release it).</li>
<li>Tear down the native user interface (set singleton instance to <code>nil</code>).</li>
<li>Get a fresh unauthenticated API token.</li>
<li>Use the token to show the sign in/up flow (set the window's <code>rootViewController</code> property).</li>
</ol>


<p>Invalidating the React Native bridge is quite a dramatic action to take, but it's effective. We chose this solution
because it allows our React Native code to continue assuming that the user ID and access token never change (during
its lifetime, anyway).</p>

<p>We had a few other items to follow-up on, mostly reference cycles that were holding onto invalid singleton
instances in-memory. Here's the log out button in action:</p>

<p><img src="/images/2020-01-15-ios-logout-button-at-last/logout.png" alt="Screenshot of our new log out button!" /></p>

<p>We learned a tonne about the React Native bridge, the existing architecture of our app, and how we'd like to see
that mature going forward.</p>

<p>I said earlier that the longer we waited, the harder it was to build this log out button because more and more of
our existing code relied upon assumptions that the log out button would break. Now that we <em>do</em> have a log out
button, <em>new code we write needs to take it into account</em>. The assumptions coders can make about this codebase are
shifting over time – this is an experience that I never appreciated while working on minimum viable products. I'm
trying to lean into these shifts and use them to drive further modernizations in our codebase. For instance, I'm
already thinking ahead to how everything will work once our sign in/up flow is moved from Objective-C to React
Native (since the user ID and access token <em>will</em> need to be mutable state).</p>

<p>In case you're curious, all our iOS code is open source. The work to add a log out button is totally open source in
<a href="https://github.com/artsy/emission/pull/2027">these</a> <a href="https://github.com/artsy/eigen/pull/2977">two</a> pull requests.</p>

<p>Any organization structure will lead to features falling through cracks. It just happens, it's the nature of
structured organizations. What we've learned at Artsy is that Hackathons (and cross-team collaboration in general)
are effective "escape hatches" for important-but-not-urgent work to get prioritized. They help our colleagues in
Engineering and other teams get to know each other, get to know our business, and find out what kind of features
our users need – even less-than-glamorous features, like a log out button.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Learning Group]]></title>
    <link href="http://artsy.github.io/blog/2019/12/03/ios-learning-group/"/>
    <updated>2019-12-03T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/12/03/ios-learning-group</id>
    <content type="html"><![CDATA[<p>Regular readers of our blog might be familiar with <a href="https://www.cultureamp.com">Culture Amp</a>, a tool Artsy uses to
collect anonymous feedback and take action on cultural issues (we most recently discussed the tool
<a href="https://artsy.github.io/blog/2019/04/19/having-a-coffee-with-every-engineer/">in this blog post</a>). At a
company-wide level, Culture Amp has helped guide everything from Artsy's evolving culture, to our physical work
spaces, to our support for remote work. At an engineering-team level, we've also been using Culture Amp to guide
our choices in technology, documentation, and training.</p>

<p>In this blog post I'll be detailing a recent learning course we ran to share knowledge about how Artsy builds iOS
software for our entire engineering team.</p>

<!-- more -->


<p>Let's start at the beginning. Earlier this year, Artsy Engineering ran a survey through Culture Amp to get answers
to the following questions:</p>

<ol>
<li>What is our team's opinion on our current technology choices?</li>
<li>What is our team's familiarity with or preparedness for our current technology?</li>
<li>Where are the areas of strength and opportunities for both learning and teaching?</li>
</ol>


<p>There are a lot of things we learned from this survey, and among them was a desire for engineers to better
understand how to build iOS software at Artsy. With a nudge (and support!) from our <em>Peer Learning Working Group</em>,
I set out to create a learning plan. I wasn't starting from scratch – we already ran a few learning groups on
topics ranging from Scala fundamentals to React Hooks. We used the lessons learned from <em>those</em> experiences to
define and deliver a learning plan.</p>

<p>I started by booking five sessions, spread out by a week. I picked a time that was a good fit for as many engineers
as possible, and I scheduled them a month ahead to give people a chance to move their schedules around. Scheduling
them up front was important, to give learners a sense of what to expect; previous learning groups had suffered from
inconsistent schedules, which led to intermittent attendance. I also asked each Tech Lead to make sure at least one
engineer from their team attended.</p>

<p>Next was the actual curriculum. In the spirit of "proudly discovered elsewhere", we actually looked at using
existing learning resources that someone else had already developed. However, since
<a href="https://artsy.github.io/series/react-native-at-artsy/">our iOS stack is a bit unique</a> and I was keen to keep
honing my own skills as a technical educator, we decided to make our own. With the help of our Peer Learning
Working Group, we set learning objectives for the five sessions. Here was the original plan:</p>

<ul>
<li><strong>Week 1</strong>: This week, we will cover how iOS software is developed, QA'd, and deployed. By the end of this
session, all participants should be able to pull the latest code from <a href="https://github.com/artsy/eigen">Eigen</a>
(our native iOS repo) and <a href="https://github.com/artsy/emission">Emission</a> (our React Native repo), see their work
in an iOS simulator, and link the two projects together.</li>
<li><strong>Week 2</strong>: This week, we will cover what makes React Native distinct from React on the web, as well as how Artsy
leverages shared infrastructure (such as our design-system, <a href="https://github.com/artsy/palette">Palette</a>) to make
it easier for engineers to work in either one.</li>
<li><strong>Week 3</strong>: This week, we will cover how to create a new view controller. View controllers are the main unit of
composition for native iOS apps, and we integrate our "Scene" React components <em>as</em> view controllers. This
includes routing between view controller, from both native Objective-C and React Native code.</li>
<li><strong>Week 4</strong>: This week, we will create our own React component to fit within the new view controller from Week 3.
This will be a Relay container, fetching data from our GraphQL API,
<a href="https://github.com/artsy/metaphysics">Metaphysics</a>. We will cover how to fetch data, how to <em>re</em>-fetch data, as
well as how Eigen and Emission integrate together to provide client-side API response caches (both Relay and
others).</li>
<li><strong>Week 5</strong>: This is the final week. Participants are asked to bring an iOS bug from their product team's backlog
that they would like to fix. Pairing is encouraged.</li>
</ul>


<p>Things mostly went to plan. I made sure to provide the learning resources at least a day or two ahead of each
session; this let me respond to feedback from the previous week, and also gave learners a chance to review
materials ahead of time.</p>

<p>Every session was recorded for anyone who missed it. We had a shared Slack channel set up for questions, so
engineers could help each other. I also made sure to provide weekly office hours: this was space for people who
missed sessions to catch up, or to just dig into concepts in more detail. I'll return to the topic of office hours
later in this post.</p>

<p>Around the time of the learning group, I was reading
<em><a href="https://www.amazon.com/Make-Stick-Science-Successful-Learning/dp/0674729013/ref=sr_1_1?keywords=making+it+stick&amp;qid=1575314498&amp;sr=8-1">Make It Stick: The Science of Successful Learning</a></em>.
The book is written for people who want to improve their own learning skills, but it was <em>very</em> helpful to read as
I was developing and delivering this curriculum. Here are a few lessons that I learned from the book that were
helpful while teaching engineers at Artsy about how we build iOS software:</p>

<ul>
<li>If someone tries to do something themselves <em>before</em> being told how to do it, the attempt will strengthen their
understanding of the underlying concept. To put this into practice, I would often ask learners questions that I
didn't expect they could answer yet, and the resulting discussion was always worthwhile.</li>
<li>Interleaving different concepts together helps learners form connections between those concepts. This was
especially important, since a big motivator for using React Native at Artsy was to share skills between web and
iOS codebases. As an example of putting this into practice, I interleaved a discussion of
<a href="https://relay.dev">Relay</a> into our curriculum; I hoped to show learners both a new perspective of Relay, as well
as show them how familiar writing React Native code was to writing React web code.</li>
<li>Allowing for some forgetting to take place before reviewing concepts will
<a href="https://njcideas.wordpress.com/2017/09/22/the-cognitive-science-of-studying-massed-practice-vs-spaced-practice/">help strengthen learner's understanding</a>.
To put this into practice, I would return to topics from a few weeks ago to cement their understanding with
learners.</li>
</ul>


<p>I had to push through some discomfort as an educator, too. Each session ended with homework questions, which we
reviewed at the top of the next session. I would ask each question and then just sit there, in awkward silence,
while everyone looked around for someone to answer. Eventually, inevitably, someone would.</p>

<p>All of the learning materials
<a href="https://github.com/artsy/README/tree/master/resources/mobile/learning-group">are open source</a>. While the materials
are mostly specific to Artsy, they may be of help to others. And regardless, we want to adhere to our
<a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#open-source-by-default">Open Source by Default</a>
principle.</p>

<p>We learned quite a lot from delivering this curriculum – lessons we can apply to our next learning group:</p>

<ul>
<li>Learners appreciated the weekly schedule set upfront, affirming what we learned from previous learning groups.</li>
<li>Learners appreciated having access to the materials ahead of time.</li>
<li>Learners appreciated having the sessions recorded, to be reviewed later (or watched, in case they missed the
session).</li>
<li>Learners appreciated having office hours available; even though the office hours weren't well-attended, learners
appreciated having access to them if they needed to.</li>
<li>Learners even appreciated the awkward silences while I waited for an answer to my questions. (One survey
respondent described it as "like pulling teeth, but helpful.")</li>
<li>Learners are varied in how they want to learn. Some liked going through things together. Some thought we went too
slow. Still others thought we should expect learners to do more work ahead of class.</li>
</ul>


<p>This last point is worth expanding upon. While everyone learns differently, there is a distinction between what
<em>feels</em> effective and what <em>is</em> effective. I tried to structure the course so that it was accessible to as many
types of learners as possible: some like to review materials ahead of time, some like to have them on hand during
the session, etc. Some are in-person, others are remote, still others are reviewing the recording. I could write
another blog post about learning styles, but for now it suffices to say that I aimed for <em>inclusion</em> of as many
different learners as possible while also recognizing that I can't make everyone happy.</p>

<p>As I enter a new chapter of my own career, leading Artsy's new Mobile Experience team, it was helpful to return to
some fundamentals; to get familiar with technology choices that we made years ago
(<a href="https://ashfurrow.com/blog/swift-vs-react-native-feels/">choices which I originally resisted</a>); and to learn from
learners' perspectives as beginners. The future of iOS software at Artsy is very bright, and now every product team
is more prepared than ever to deliver user experiences that are of a quality worthy of art.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peril Architecture Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive/"/>
    <updated>2019-04-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive</id>
    <content type="html"><![CDATA[<p>For the <a href="/blog/2017/09/04/Introducing-Peril/">last two years</a>, we've used <a href="https://github.com/danger/peril">Peril</a> to automate quite a lot of process at Artsy. You can see
a full overview of what <a href="https://github.com/artsy/README/blob/master/culture/peril.md">we automate in <code>artsy/README</code></a>. As a service, Peril is a bit of an iceberg
of complexity, most tooling-y developers at Artsy have <a href="https://github.com/artsy/peril-settings/graphs/contributors">contributed</a> to our user-land Dangerfiles
but very few have touched the server itself.</p>

<p>To lower that barrier, I gave our Engineering team a run through of how the server works and how a lot of the
pieces come together. Jump <a href="https://www.youtube.com/watch?v=3HNmiNHCvdA">to YouTube</a> for the video, or click more
for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/3HNmiNHCvdA ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy, 3 years later]]></title>
    <link href="http://artsy.github.io/blog/2019/03/17/three-years-of-react-native/"/>
    <updated>2019-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/17/three-years-of-react-native</id>
    <content type="html"><![CDATA[<p>On Valentine's day in 2014, @alloy made our first commit moving the Artsy Mobile team to JavaScript, and paving the
way to the <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">shared Omakase JavaScript stack across web + iOS</a>. We've done a write-up at <a href="/blog/2016/08/15/React-Native-at-Artsy/">6 months</a>, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/">1 year</a>,
<a href="/blog/2018/03/17/two-years-of-react-native/">2 years</a> and at 2.5 years we collaborated on a React Native conference with Facebook which features a <a href="http://artsy.net/x-react-native">very long
Q&amp;A</a> session with the people who worked on, and with our React Native stack.</p>

<p>Our experience has been really positive building a single platform data-driven app. We've been able to drastically
increase the number of contributors to the codebase and with minimal guidance, web-developers are able to be
productive and ship features to our iOS apps.</p>

<p>That said, for this 3 year anniversary, I want to dive deeper into some of the less positive aspects of our
transition. We think these trade-offs are worth it, and that this may be what a successful cultural transition
eventually looks like for some companies.</p>

<!-- more -->


<a name="De-nativification"></a>
<h2>De-nativification</h2>

<p>When adopting React Native, we de-emphasized iOS as a unique platform for Artsy.</p>

<p>From an engineering team's perspective, we think of it as skill <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#de-silo-engineers">de-siloing</a>. Prior to the move, if you
were on the mobile team you only worked on the iOS apps. This meant you had a limited scope to make change at
Artsy. This comes from two factors:</p>

<ul>
<li>Skills in Obj-C and Swift are only useful in the context of Apple's platforms.</li>
<li>Internally and externally, Artsy is considered a website first.</li>
</ul>


<p>Within 2 years we had de-siloed mobile engineering completely. We started with a team of 5 experienced native iOS
developers and by the end everyone had very solid skills across the board in JavaScript, React, GraphQL and the
build tools we'd need to make it all come together. These engineers kept their native skills, but they became
frozen in time.</p>

<p>With time, we redistributed the native engineers across many teams, with the native Engineers effectively acting as
a conduit for ensuring that we keep quality high and providing guidance to the rest of that team on how to make it
feel right. A simple way to think of it, is that the native engineer's job was to make sure we still conformed to
the <a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human Interface Guidelines</a> to ensure
the user experience is consistent with the platform and the user’s expectations.</p>

<p>We're reasonably lucky here too, the mobile team at Artsy has pre-dominantly hired folks interested in improving
behind-the-scenes (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">Roads and Bridges</a> style) infrastructure. Once we had wrapped up the move, we effectively
took all of our native product developers and moved them into JavaScript platform infrastructure roles.</p>

<p>This was one of the major blocking points for AirBnB's adoption of React Native, specifically their native teams
felt uncomfortable at the introduction of JavaScript and a whole new toolchain inside their apps. There are people
who really love being a product developer in a native codebase, and React Native as a technology will de-value that
as more work would happen in JavaScript.</p>

<p>(Note: this is a gross simplification, and me reading between the lines, you should read from the horse’s mouth and
check out <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">Airbnb’s posts</a> (and <a href="https://ashfurrow.com/blog/airbnb-and-react-native-expectations/">Ash's continuation</a> on the subject ))</p>

<p>After a year of adopting React Native, the ex-mobile team used to joke that no-one enjoyed working in the native
codebase anymore. They still did. Three years down the line, with most screens now in React Native, that's not a
joke anymore.</p>

<p>This has consequences.</p>

<a name="Platform.Concerns"></a>
<h2>Platform Concerns</h2>

<p>De-siloing our mobile team obviously wasn't without its risk. In expanding the scope of our mobile engineering
team, and opening up the iOS app for contributions to the rest of the company we:</p>

<ul>
<li>Moved the engineers with a native focus to act more like platform engineers vs product engineers.</li>
<li>Had iOS native platform engineers with the skills to now also work on the web's platform.</li>
</ul>


<p>This is what started to make our third year tricky. In Artsy, web is the <a href="https://en.wikipedia.org/wiki/The_squeaky_wheel_gets_the_grease">squeaky wheel</a>.</p>

<p>After figuring out the JavaScript infrastructure for React Native on iOS, we replicated that infrastructure on the
web to consolidate tooling and ideas across all of Artsy. We call that infrastructure for both <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">the Artsy
Omakase</a>. Maintaining, and keeping the infrastructure up-to-date on the web side is a much bigger task and
requires a lot more engineering time.</p>

<p>The web-aspect of the Omakase has more client consumers (1 iOS app vs 3 large websites), and its corresponding repo
has more than double the number of commits per day on average. The web team has its own people running and
improving infrastructure, which affects the iOS side too.</p>

<p>We explicitly worked towards shared common infrastructure across all front-end at Artsy. It wasn't surprising when
the aspect with the most company focus became much larger and more complex. What creates tricky constraints are
that the few people with the interest and skills to work on our React Native infrastructure also happen to have the
skills to work on the web problems too.</p>

<p>Those web problems tend to be a lot more valuable to the business.</p>

<p>There's some work that can be done to benefit both, but in the last year it has been hard to prioritise
iOS-specific platform work. For example, it took almost a year to get around to upgrading our version of React
Native. This is a pretty risky place to be for a platform which we care about.</p>

<p>At the end of 2018, we came to the conclusion that this was something we wanted to work to improve. So, we
specifically brought back an explicit iOS-specific culture to Artsy - when we split our front-end practice into web
and <a href="https://github.com/artsy/README/commit/95c9b93ab966ed269b5ebd9f0bdec8d2434bab52#diff-342d3433f36fbedadc5a8f167985fdf3">iOS</a>.</p>

<p>Maybe this is a small admission of failure to the idea of a purely de-silo'd team, but realistically while product
work across the two front-ends teams is consistent - the platform concerns just aren't.</p>

<a name="Keeping.up.with.the.Jobs."></a>
<h2>Keeping up with the Jobs'</h2>

<p>As individual developers, it's much less important for us to keep up to date with the latest Apple developer news.
WWDCs and iOS releases just kinda happen, and we keep moving independently. We still write native code to make use
of any iOS API available when we need to, but right now we don’t go out of our way to try to make use of all the
shiny new things when they are released.</p>

<p>This is a side-effect to the openness of the JavaScript toolchain, and our ability to contribute and fix a lot of
our own problems at JavaScript level instead of needing to dive deeper into the native side to work on problems. We
still support iOS 9, and have very little incentive to bump it - new APIs from Apple just aren't that interesting
anymore.</p>

<p>Without a focused iOS team, it's not easy to pitch for iOS specific projects. This means that features like moving
to Apple's new app store review API or using iOS features which don't exist on web get spoken about in meetings,
but never started. This lack of a focused team makes it really hard to implement fixes to e.g. bad App Store
reviews.</p>

<p>That said, in the last year we did manage to ship a pretty hefty <a href="/blog/2018/03/18/ar/">ARKit feature</a> - which is a positive
example of an iOS-specific feature which is both forward-thinking tech and a super great fit for Artsy's product.
React Native basically played no part in that.</p>

<a name="Community.Disconnection"></a>
<h2>Community Disconnection</h2>

<p>There are maybe four communities at play if you're doing React Native:</p>

<ul>
<li>JavaScript (Babel/TypeScript/Storybooks/VSCode)</li>
<li>React (Relay/Styled Components)</li>
<li>React Native (Mostly people creating cross-platform tools)</li>
<li>Native (Obj-C/Swift/CocoaPods/fastlane etc)</li>
</ul>


<p>It's hard to keep on-top of any one community, and it's very hard to keep on track of four. Realistically, if you
want to be writing apps at the level of quality we want to - you need to, though.</p>

<p>Artsy's principle of <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">owning our dependencies</a> means involved in all of these communities, however it's
hard to engage in the native community with too much excitement anymore. Most of their problems aren't the same as
ours anymore, and the dependencies we want to improve live in the JavaScript realms.
4</p>

<a name="Universal.Issues."></a>
<h2>Universal Issues?</h2>

<p>Are these the kind of problems most teams would have? It depends, with React Native at Artsy our focus on:</p>

<ul>
<li>Offering a consistent way to write code across web and iOS, which doesn’t water down either platform.</li>
<li>Ensuring we are able to meaningfully own our dependencies across the stacks.</li>
</ul>


<p>Means that we took on some technical and cultural debt, specifically around the platform aspect of our native
codebase. There are a few levers we can use to fix some of these issues:</p>

<ul>
<li>Let iOS be a bit more webby, by using more JavaScript instead of enforcing stricter platform standards.</li>
<li>Use more of the React Native community’s infra-structure, we generally don't use React Native JavaScript
dependencies. These dependencies usually are cross-platform on Android and iOS which tends to mean making
compromises per-platform. Often we are forcing ourselves into extra work to ensure platform consistency.</li>
<li>Find a way to ensure clearer engineering and product ownership for iOS at Artsy.</li>
<li>Hire more iOS infrastructure engineers to allow for a better mix of native infra vs JavaScript product engineers.</li>
</ul>


<p>How and if we'll tweak these levers will make for an interesting retrospective. Till then, I'd like to finish with
a showcase of some of the React Native work we shipped over the course of the last 4 months:</p>

<p></article>
<a href='/images/react-native-3/rn_3_1.jpg' style="">
  <img src="/images/react-native-3/rn_3_1.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p></article>
<a href='/images/react-native-3/rn_3_2.jpg' style="">
  <img src="/images/react-native-3/rn_3_2.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p>We wouldn't have been able to ship this without React Native.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
</feed>
