<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: eigen | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/eigen/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-08-25T14:52:39+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On our implementation of React Native]]></title>
    <link href="http://artsy.github.io/blog/2016/08/24/On-Emission/"/>
    <updated>2016-08-24T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/24/On-Emission</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/emission/emission-logo-artsy.svg" style="height:300px;">
</center>


<p>I arrived fashionably late to the <a href="/blog/2016/08/15/React-Native-at-Artsy/">React Native party</a> in Artsy. I had been a part of our <a href="/blog/2016/08/09/the-tech-behind-live-auction-integration/">Auctions Team</a>, where we worked in Swift with <a href="https://cocoapods.org/pods/Interstellar">some light-FRP</a>. We were not affected by the 4 months of simultaneous work on moving to React Native, at all.</p>

<p>It was a quiet revolution. I did not have to install <code>npm</code>, I made zero changes to the code for auctions and the whole app's infrastructure barely changed. Yet we moved to making all new code inside our 3 year old iOS app use React Native. What gives?</p>

<p>Well, first up we weren't planning a re-write, we don't have that kind of luxury and the scope of our app is too big compared to the team working on it. Second, we reused existing dependency infrastructure to support JavaScript based apps. Read on to find out what that looks like.</p>

<!-- more -->


<h3>Why we were in a good position to do this</h3>

<p>Let's talk a little about the Artsy flagship app, <a href="https://github.com/artsy/eigen/">Eigen</a>. It's an app that aimed to comprehensively cover the art world. From <a href="https://www.artsy.net/shows">Shows</a> to <a href="https://www.artsy.net/galleries">Galleries</a>, <a href="https://www.artsy.net/art-fairs">Fairs</a> to <a href="https://www.artsy.net/auctions">Auctions</a>, <a href="https://www.artsy.net/institutions">Museums</a> to <a href="https://www.artsy.net/articles">Magazines</a>.</p>

<p>It all looks a bit like this:</p>

<p></div></div><a href='/images/emission/eigen-overview.jpg'><img src="/images/emission/eigen-overview.jpg"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Our app neatly splits into two areas of view controllers, ones that act as a browser chrome, and individual view controllers that normally map 1:1 to <a href="https://github.com/artsy/eigen/blob/master/Artsy/App/ARSwitchBoard.m#L122">routes</a> on the Artsy website.</p>

<p>For example, the route <code>artsy.net/artwork/glenn-brown-suffer-well</code> maps to the native <code>ARArtworkViewController</code>.</p>

<p></div></div><a href='/images/emission/eigen.svg'><img src="/images/emission/eigen.svg"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Just as a browser knows very little about the individual content of the pages that it's rendering, the eigen chrome exists <em>relatively</em> independent of the view controllers that are showing.</p>

<p>Each view controller also knows very little about each-other, so actions that trigger a new view controller are generally done by creating a string route and passing it through the routing system. I've wrote about this pattern in <a href="https://artsy.github.io/blog/2015/08/15/Cocoa-Architecture-Router-Pattern/">Cocoa Architecture: Router Pattern</a>.</p>

<p>Interestingly, if the router cannot route a view controller, it will pass through to a web view. This is why we consider the app a <a href="http://artsy.github.io/blog/2015/08/24/Cocoa-Architecture-Hybrid-Apps/">hybrid app</a>. This pattern means adding new view controllers is extremely easy.</p>

<h3>Introducing Emission</h3>

<p>Emission is what we use to contain all of our React Native components. Our flagship app Eigen, can depend on and use without needing to bother with the implementation details of React Native. At it's core, Emission is:</p>

<ul>
<li>A node module.</li>
<li>A CocoaPod.</li>
<li>An iOS App.</li>
</ul>


<h4>The Node Module</h4>

<p>Emission itself, is a node module. In our case, it is a JavaScript library that exposes 3 JavaScript objects.</p>

<pre><code class="javascript">/* @flow */
'use strict';

import Containers from './lib/containers';
import Components from './lib/components';
import Routes from './lib/relay/routes';

import './lib/relay/config';
import './lib/app_registry';

export default {
  Containers,
  Components,
  Routes,
};
</code></pre>

<p>Another node project can have Emission as a dependency - then can access our <code>Container</code>s, <code>Component</code>s and <code>Route</code>s. A container is a <a href="https://facebook.github.io/relay/docs/api-reference-relay-container.html">Relay container</a>, a component is a <a href="https://facebook.github.io/react/docs/component-api.html">React Component</a> and a Route is a <a href="https://facebook.github.io/relay/docs/guides-routes.html#content">Relay Route</a>.</p>

<p>The thing that's interesting from the integration side, is that each <code>Container</code> is effectively a View Controller that Emission provides to a host application. React Native ignores  the concept of view controllers from the Cocoa world, so we have an <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Pod/Classes/ViewControllers/ARComponentViewController.m">ARComponentViewController</a> which is subclassed for each exposed <code>Component</code> class.</p>

<h4>The iOS App</h4>

<p>The iOS app acts as a host target for the CocoaPod, and provides an instance of an <a href="https://github.com/artsy/emission/blob/master/Pod/Classes/Core/AREmission.m">AREmission</a> object to the view controllers using React Native. The app is nothing special, it is the default app that is created using <code>pod lib create</code>. We then <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Podfile">use CocoaPods</a> to bring in React from inside the <code>node_modules/</code> folder the Emission node module creates.</p>

<p>The <code>AREmission</code> instance is the intermediary between the host-app (<a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Emission/AppDelegate.m#L56">The Emission Example app</a>, or <a href="https://github.com/artsy/eigen/blob/41b00f6fe497de9e902315104089370dea417017/Artsy/App/ARAppDelegate%2BEmission.m">Eigen</a>.) It has an API for handling routing, and passing authentication credentials into the React Native world.</p>

<p>We use the example app to do development inside React Native. As of right now, it is simply a tableview that provides a list of view controllers <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Emission/AppDelegate.m#L159-L169">that represent an exposed Container</a>. Once you are in the right view controller, you can rely on <a href="http://facebook.github.io/react-native/releases/0.31/docs/debugging.html#automatic-reloading">Hot Reloading</a> to simplify your work.</p>

<h4>The Pod</h4>

<p>An important part of working with React Native, is that you can choose to use native code when appropriate. The <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Emission.podspec">Pod for</a> Emission, created entirely in Objective-C, provides:</p>

<ul>
<li>Communication between React Native and the host app objects via <a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">native modules</a>.</li>
<li><code>UIViewController</code> subclasses for Host apps to consume.</li>
<li>Bridges for existing native views (like our <a href="https://github.com/artsy/extraction/blob/d6a32186f7098eb2ec5d05e2fb5302a8378eff70/Extraction/Classes/ARSwitchView.m">SwitchView</a>) into React Native.</li>
</ul>


<p>The choice of Objective-C is for simplicity, and language stability. Swift is technically an option, but it's not  worth the complications for <a href="https://github.com/artsy/emission/tree/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Pod/Classes">a few simple objects</a>.</p>

<p>In order to share native views with our host app, Eigen, we created a library to just hold the shared UI components, <a href="https://github.com/artsy/extraction">Extraction</a>. These are <a href="https://github.com/artsy/extraction/tree/d6a32186f7098eb2ec5d05e2fb5302a8378eff70/Extraction/Classes">factored out of Eigen</a>, and into a pod. Emission and Eigen have this as a dependency.</p>

<h4>Pod Deployment</h4>

<p>What makes this work well, from the perspective of Eigen is that the React Native comes in atomically. The Podspec <a href="https://github.com/artsy/emission/blob/master/Emission.podspec#L17-L18">references</a> the few native classes, and a single JavaScript file.</p>

<p>This JavaScript file is the bundled version of all our React Native code. It's <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/package.json#L7">updated  by running</a> <code>npm run bundle</code>. This generates both the minified JS, and a source map so that we can transcribe the error reports into the code we write.</p>

<p>Using the CocoaPod, Emission can provide native view controllers that use React Native under the hood. The host app does not need to know the underlying details like <code>npm</code>.</p>

<h3>On Emission</h3>

<p>Whether this is a pattern other apps can follow is hard to say, we were in a great position to do this. Our app has view controllers that have very little communication with each other and the host app does not need to bridge large amounts of information.</p>

<p>As ever, our work is open source, and we ensure that anyone can download and run Emission, so if you'd like to understand more, clone <a href="https://github.com/artsy/emission#reactions--emissions">artsy/emission</a> and study the implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy]]></title>
    <link href="http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy/"/>
    <updated>2016-08-15T21:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy</id>
    <content type="html"><![CDATA[<center>
<img src="/images/react-native/artsy_react_logo.svg" style="width:300px;">
</center>


<p>As <a href="https://github.com/artsy/eigen">the Artsy iOS app</a> grew larger, we started hitting pain
points:</p>

<ul>
<li>We want to support other future platforms such as Android without creating more teams.</li>
<li>We want different business teams to work on the app without disrupting each other.</li>
<li>We want our architecture to evolve in order to increase programmer efficiency.</li>
</ul>


<p>It took us <a href="https://github.com/artsy/mobile/issues/22">about a year</a> to start resolving these issues.
Ideally, we wanted to find a solution to our architectural issues that would also improve the user
experience. Notably we wanted more efficient networking, due to mobile device constraints.</p>

<p>It would have been an easy leap to start using Swift and, as a matter of fact, we do use Swift in parts of
our flagship application and entirely in <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">2 other apps</a>.</p>

<p>However, while Swift is a great language, it’s also just that: <em>another</em> language. It does not do much in terms of new
paradigms that solved our architectural needs, it does not help in terms of cross-platform - as most of our code is
building views and thus very framework specific, and it did not really offer anything in terms of more efficient network
data fetching.</p>

<p>We've seen that the web teams integrate React in their projects with really great results. We've been
<a href="https://github.com/artsy/mobile/issues/22">paying attention</a> to React Native since it came out; the solutions provided
by the React ecosystem ticked all of our boxes.</p>

<p>Six months ago we took the plunge, and last month we formalized that this is the direction we want to go.</p>

<!-- more -->


<h1>Cons</h1>

<p>So you decided to read the full post and the first thing you got confronted with is a list of cons… <em>boo</em>. Let’s just get
these out of the way first, it will only get better afterwards.</p>

<ul>
<li><p>Dependencies, dependencies, dependencies, both in libraries and tooling. Once you open this can, you’ll have worms
<em>everywhere</em> in no time; 593 packages to be exactly, at the time of writing, for a new React Native project. Good luck
maintaining that.</p>

<p>Having created <a href="https://cocoapods.org">a dependency manager</a>, I’m not afraid of some dependencies and don’t subscribe
to NIH, but the JavaScript community has gone <em>way</em> overboard for my taste. If, like me, you subscribe to the idea
that dependencies are <em>part</em> of your application and you want to be able to know what packages are being pulled in so
you can maintain them, then you probably won’t like this aspect very much either.</p>

<p>I’m not quite sure yet how I feel about this in the long run and what we can do about it, short of trying to get the
maintainers of the packages we directly depend on to accept changes that simplify their dependency graphs.</p></li>
<li><p>As is often the case, error reporting does not always receive the attention it should get. With the amount of tools
and libs that make up the full stack you need to work with, this lack in attention to failure resolution can quickly
cascade into deep rabbit holes.</p></li>
<li><p>React Native is still very young and fast moving. If you don’t like living on the edge (i.e. lots of updating and
dealing with breaking changes) nor have an interest in shaping an unfinished framework, this currently is not for you.</p></li>
<li><p>All Facebook open-source code is made to solve the problems that Facebook has first, thus with young projects you may
well need to put in a bunch of time to make it work for your problem set. React Native provides a lot of basic view
building blocks, but you do lose a lot that you would get with UIKit for free, e.g. <code>UICollectionView</code>.</p>

<p>However, it is important to note that this is only a heads-up for those that might think they can solve any problem
out-of-the-box; in terms of open-source code I prefer code used in production over other code <em>any</em> day.</p></li>
<li><p>There are currently many more people trying to get help, with often arguably simple questions in the context of iOS
development, compared to those willing to spend time on answering questions. Most forums I’ve seen suffer from the
tragedy of the commons problem, which can be a real problem if you have incidental framework specific questions, but
jumping to React-Native probably is a complete disaster if you know very little about iOS development yet.</p>

<p>If you’re not already knowledgable about iOS development, are not motivated to put in the time to learn about the
platform specific details, and think making rich iOS applications with React Native will be a breeze, you’ll
<a href="http://www.dwotd.nl/2008/06/443-van-een-kouwe-kermis-thuiskomen.html">come home from a very cold fair</a> indeed.</p>

<p>While you can definitely make applications that way, in my experience those often end up not feeling like proper
citizens of the platform they inhibit.</p></li>
<li><p>Due to React Natives immaturity, you will not be able to find nuanced post-mortems on the subject. The project
is only at the beginning of the <a href="https://en.wikipedia.org/wiki/Hype_cycle">hype cycle</a>, meaning there is a lot
to gain in writing about how great it is, but less incentive to discuss where it doesn't work out well.</p></li>
</ul>


<h1>Pros, why we wanted to use React Native</h1>

<ul>
<li><p>From <a href="https://facebook.github.io/react/">the React website</a>:</p>

<blockquote><p>React will efficiently update and render just the right components when your data changes.
Build encapsulated components that manage their own state, then compose them to make complex UIs.</p></blockquote>

<p>The functional model that React introduces that allows you to reason about the state of your views in much simpler
ways has for us been a welcome change that should make it much easier to write decoupled code going forward.</p>

<p>I’m by no means a functional programming purist, nor do I really care for being one. I found the React/React Native
communities to be very welcome to functional enthusiasts and pragmatists alike, a healthy mix that I find leads to
more productive outcomes.</p></li>
<li><p>Relay. From <a href="https://facebook.github.io/relay/">its website</a>:</p>

<blockquote><p>Queries live next to the views that rely on them, so you can easily reason about your app.
Relay aggregates queries into efficient network requests to fetch only what you need.</p></blockquote>

<p>The clarity this brings to the view codebase - coupled with its smart caching, networking is just ground-breaking.
No more multiple levels of model code in your application that you need to trace, just a single file with
<a href="https://github.com/artsy/emission/blob/a2e4dbdb/lib/components/artist/header.js#L87">the view component</a> <em>and</em>
<a href="https://github.com/artsy/emission/blob/a2e4dbdb/lib/components/artist/header.js#L143-L144">the data it needs</a>. Neat.</p>

<p>We do still have ‘view models’, however, those now pretty much all live in
<a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">our GraphQL service</a>. The added benefit here is that we
share that model logic with Artsy’s other (web) clients.</p></li>
<li><p>“Learn once, write anywhere.” is the neo-cross-platform slogan deployed by React, which is a play on the tried
“Write once, run anywhere.” slogan of yesteryear. The difference being that you can use the same paradigms to create
products on various platforms, rather than pure code-reuse.</p>

<p>While we haven’t put this to the test yet at Artsy, we do plan to team up people across platforms to implement single
features on each respective platform, rather than having multiple people implement the same feature <em>on their own</em>.
The hope is that this will lead to better understanding of features and thus the implementations thereof, while still
taking each platform’s unique nature into account. The added benefit would be that people learn to understand and
appreciate those unique platform traits, thus making them more well-rounded engineers.</p>

<p>In the long run, we hope to extend this way of working as we start work on a React Native Android client.</p></li>
<li><p>While Auto Layout is a great step up from manual frame calculation, most of our views don’t need the granularity that
Auto Layout offers. React Native ditches Auto Layout and instead uses
<a href="https://en.wikipedia.org/wiki/CSS_Flex_Box_Layout">flexbox</a> for its layout. While my head has never been able to
fully wrap around classic CSS, I find that flexbox is an abstraction that nicely fits most of our needs.</p>

<p>I can definitely imagine situations in which more granularity would be required, however, in those cases we can always
decide to ‘drop down’ to native view code, so I don’t really worry too much about that.</p></li>
<li><p>Layout calculations are performed on a background thread, the so-called ‘shadow’ thread. This can make a big
difference when e.g. scrolling through a large complex list view.</p>

<p>Granted, you <em>can</em> do this with <code>UIView</code>, but the pattern is not as ingrained in UIKit thus usually leading to more holistic
replacements such as <a href="http://asyncdisplaykit.org">AsyncDisplayKit</a>.</p></li>
<li><p>Great separation of declarative view layout (JS, single-threaded) and technical details (native code, multi-threaded).
Because of the hard constraint of having a JS/native bridge, there really is no way to take shortcuts (e.g. spaghetti
code) that in the long run would only lead to technical debt. Constraints are great.</p></li>
<li><p>Because there’s very little code that needs to be compiled and how the isolated component nature of React makes it
it very easy to reload code in-process, development velocity lies much higher than with your typical native UIKit-based
development.</p></li>
<li><p>While, as mentioned above, there are definitely issues with the tooling and libs, on the flip-side it is all
open-source software and you <em>can</em> (officially) dive in and figure it out, unlike e.g. Xcode and UIKit. (Granted, you
still need to deal with these when using React Native, but it can be kept to a minimal surface.)</p></li>
<li><p>Because React Native is still young, fast moving, and open-source, this is a great time to help shape the framework
you’d <em>want</em> to use.</p></li>
</ul>


<h1>Things we learned</h1>

<ul>
<li><p>When we started out with React Native, I didn't want to have to re-write our application in order to take advantage of
the technology. To address this I worked within our existing application structure. We consider the App to
<a href="https://artsy.github.io/blog/2015/08/24/Cocoa-Architecture-Hybrid-Apps/">be a browser</a> of native and web view controllers. So,
we added routes <a href="http://artsy.github.io/blog/2015/08/19/Cocoa-Architecture-Switchboard-Pattern/">to our SwitchBoard</a> for
view controllers which are created in React Native. To the rest of the app, there is no difference between a Swift view controller,
or one with React Native inside.</p></li>
<li><p>All of the React Native code is kept in a completely separate repo, <a href="https://github.com/artsy/emission">Emission</a>, which
when deployed generates a minified version of the JavaScript. This means to build the Artsy iOS app you do not need to have
a JavaScript development environment.</p></li>
<li><p>We reused a lot of our existing native views, starting with loading indicators and native switch views.</p></li>
<li><p>We used new native classes to improve integration, for example the <code>&lt;OpaqueImageView&gt;</code>
<a href="https://github.com/artsy/emission/blob/master/lib/components/opaque_image_view.js">component</a> is a
<a href="https://github.com/artsy/emission/tree/master/Pod/Classes/OpaqueImageViewComponent">native</a> <code>UIImageView</code>
subclass that works with our application-wide <a href="https://cocoapods.org/pods/SDWebImage">SDWebImage</a> image cache.</p></li>
</ul>


<h1>Conclusion</h1>

<p>To really shine with React Native, you need native experience. JavaScript has not eaten everything yet. However,
you don't need a team of native experts. For example, we expect to be able to get quite far with Android support based on
our work in React Native, but to make it amazing, we will need someone with history and context in the space.</p>

<p>This frees up our engineers to widen their <a href="https://artsy.github.io/blog/2016/01/30/iOS-Junior-Interviews/">T-shaped skills</a>,
and to help remove the idea that the mobile team has to be a completely separate team with foreign tools and ideas.</p>

<p>This is only the tip of the iceberg for our writings about React Native. Follow <a href="https://twitter.com/ArtsyOpenSource">@ArtsyOpenSource</a>
to stay up to date.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Depedency Injection in Swift]]></title>
    <link href="http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/"/>
    <updated>2016-06-27T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift</id>
    <content type="html"><![CDATA[<p>Dependency Injection (DI) is a <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">$25 word for a 5¢ idea</a>, but it's an idea that has become wholly foundation to how I write software. I want to take a look at some of the ways our team have been using DI in Swift.</p>

<!-- more -->


<p>DI users in Swift (and Objective-C) are generally in one of a few camps:</p>

<ul>
<li>Use <a href="https://www.natashatherobot.com/unit-testing-swift-dependency-injection/">initializer injection</a> to provide objects with their dependencies.</li>
<li>Use property injection (<a href="https://ashfurrow.com/blog/lazy-property-setup-in-swift/">with laziness even!</a>).</li>
<li>Use <a href="https://github.com/Swinject/Swinject">frameworks like Swinject</a> to build dependency graphs at run time.</li>
</ul>


<p>If you've used storybards or nibs before, you have probably already used property injection via IBOutlets. I actually consider initializer injection and property injection to be roughly the equivalent, just with different timing.</p>

<p>If I had to pick a favourite, I like the initializer injection because it fits appropriately with the level of dynamism Swift offers. But Swift is still <em>super</em> young and there're lots of programming techniques to explore, so I've been experimenting with something new.</p>

<p>The idea is similar to initializer injection, where you provide an instance's dependencies, but instead of providing the dependencies directly, you provide closures that return a dependency. It sounds odd, and is best explained using an example that starts without any DI at all.</p>

<p>Okay, we've got a network layer that communicates with an API. We're writing the class that takes the parsed data from the <code>NetworkProvider</code> class and turns it into models consumable by the rest of the app. Right now it looks like this.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init() {
        networkProvider = NetworkProvider("https://api.wherever.com")
    }
}
</code></pre>

<p>There are some limitations to this, specifically around testing it. It would be better to have the <code>networkProvider</code> passed in as an argument to <code>init()</code>. That's initializer injection, and my opposition to it is that we've moved the responsibility for creating the <code>networkProvider</code> up the stack.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(networkProvider: NetworkProvider) {
        self.networkProvider = networkProvider
    }
}

...

let stateManager = StateManager(
    networkProvider: NetworkProvider("https://api.wherever.com")
    )
</code></pre>

<p>The thing is, now some <em>other</em> object has to know how to do create the <code>NetworkProvider</code>. Hrm. You can repeat this process of injecting dependencies from further up the stack until you have a general-purpose DI framework, and that's not my bag.</p>

<p>My approach passes a closure that <em>returns</em> a network provider instead of passing in a <code>networkProvider</code> instance directly. The parameter can be given a default implementation, too.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: () -&gt; NetworkProvider = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }

    class func defaultNetworkCreator() -&gt; (() -&gt; NetworkProvider) {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<p>There's a lot to unpack here, so let's take it slowly. The initializer has a new <code>networkProviderCreator</code>, a closure that returns a <code>NetworkProvider</code>. In the initializer, we set our property to the return value of the closure. We also have a class method that gives us a default implementation that's used in production.</p>

<p>But in tests, we can initialize the <code>StateManager</code> with a stub closure, something like:</p>

<pre><code class="swift">let fakeNetworkProvider = ...
let testSubject = StateManager({ fakeNetworkProvider })
</code></pre>

<p>Now you get the benefits of initializer injection, but the flexibility to only use DI when you need to.</p>

<p>Note: we should still test the <code>defaultNetworkCreator()</code> function to make sure it works, too. Having code behave differently specifically while being tested is not generally a good idea.</p>

<p>Applying the advice on using <code>typealias</code> from <a href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/">my last post</a>, we can tidy our code up a little bit.</p>

<pre><code class="swift">class StateManager {
    typealias NetworkCreator: () -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<h3>But wait, there's more!</h3>

<p>The other benefits of passing in a closure instead of an instance is that it lets the initializer customize the dependency based on other data. For example, let's say the state manager uses an <code>enum</code> to differentiate between staging and production API endpoints (btw, <a href="https://ashfurrow.com/blog/the-wrong-binary/">two-case enums are great at this</a>). How might our initializer change?</p>

<pre><code class="swift">enum APIEnvironment {
    case Staging, Production
}

class StateManager {
    typealias NetworkCreator: (String) -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        environment: APIEnvironment,
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        let baseURLString: String
        switch environment {
        case .Staging:
            baseURLString = "https://staging-api.wherever.com"
        case .Production:
            baseURLString = "https://api.wherever.com"
        }

        networkProvider = networkProviderCreator(baseURLString)
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return { baseURLString in
            NetworkProvider(baseURLString)
        }
    }
}
</code></pre>

<p>I really dig this. The closure to create the dependency is close to the code that uses it, but is insulated from any specific instance, so we get the benefits of using DI.</p>

<p>You could argue that picking a base URL for an API shouldn't belong here, and you could probably convince me. But my point isn't that this specific example is ideal, it's that the pattern of using closures for initializer injection is pretty neat.</p>

<p>The logic to create dependencies has to go <em>somewhere</em>. I think it makes sense to keep it close to the code that actually uses the dependency, but isolated in a <code>class</code> function so no actual instance is involved in its creation. As a result, developers get the benefits of initializer injection and none of the added cognitive overhead when writing your production code.</p>

<p>It may not be a perfect pattern (what is?) but we've been using it on <a href="https://github.com/artsy/eidolon">eidolon</a> and <a href="https://github.com/artsy/eigen">eigen</a> for nearly two years and – combined with generous use of protocols – we've been really happy with the results.</p>

<p>Now that I have more free time to explore the pattern, I want to take it a step further and see where it could be used outside of unit testing. It's possible that using this approach could make all our types less tightly coupled and provide a more modular codebase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Type Aliases: Use Early and Often]]></title>
    <link href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/"/>
    <updated>2016-06-24T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/24/typealias-for-great-good</id>
    <content type="html"><![CDATA[<p>It's been so fun to watch the Swift developer community experiment with Swift and to experiment with what idiomatic Swift will look like. No one really knows the answer yet, but we're starting to see some design patterns used more than others. We're seeing some language features used in key ways that define idiomatic Swift, and other language features that are being mostly ignored.</p>

<p>Regrettably, one of my favourite features of Swift has not enjoyed the meteoric rise in popularity I believe it deserves: <code>typealias</code>.</p>

<!-- more -->


<p>Type aliases allow developers to define synonyms for pre-existing types. It might sound dull because it <em>is</em> dull. In fact, its usefulness isn't even apparent when <em>writing</em> code, mostly when <em>maintaining</em> it.</p>

<p>But before I dig into how <code>typealias</code> is useful, let's review what it is to make sure we're all on the same page. Developers use <code>typealias</code> to create a new type identifier that's a synonym for another type. For example, we can declare <code>typealias BigNumber = Int64</code> and use "BigNumber" any place we could have used "Int64".</p>

<pre><code class="swift">func multiply(lhs: BigNumber, rhs: BigNumber) -&gt; BigNumber

...

let number: BigNumber = 5

...

let number = BigNumber(5)
</code></pre>

<p>You can use <code>typealias</code> for most any type: classes, enums, structs, tuples, closures, etc. Here are a few examples.</p>

<pre><code class="swift">typealias Name = String
typealias Employees = Array&lt;Employee&gt;
typealias GridPoint = (Int, Int)
typealias CompletionHandler = (ErrorType?) -&gt; Void
</code></pre>

<p>Now that we're familiar with <code>typealias</code>, I want to discuss four examples that show how <code>typealias</code> has helped us maintain code.</p>

<h3>Promoting Existing Types Semantics</h3>

<p>When writing web socket communication for eigen, Orta and I were using <a href="https://jwt.io">JSON Web Tokens</a> to authenticate the user. If you've never used JWTs before, don't worry, here's the tl;dr JWTs are a way to authenticate users in a way that clients can cryptographically verify. It's <em>basically</em> a base64 encoded string of JSON.</p>

<p>Clients don't need to verify the JWT in order to use them, and in fact when Orta and I began using them, we treated them only as strings retrieved from one API and sent to another (like an access token). However, instead of using the <code>String</code> type, I decided to define a <code>JWT</code> type alias.</p>

<pre><code class="swift">typealias JWT = String
</code></pre>

<p>I used the new <code>JWT</code> type throughout the code as a hint to other developers about what <em>kind</em> of string it is. This gave it some semantic meaning on top of being a string. Neat. Only later, when we needed to start decoding the JWT itself did this really come in handy.</p>

<p>After deleting the <code>typealias</code> and replacing it with a class of the same name, we didn't have to worry about changing function definitions and property types all throughout our codebase. We made the changes locally, in one file, and most all the rest of our code still compiled. Pretty cool! Here's the <a href="https://github.com/artsy/eigen/pull/1638/files/911473424849240bb71b89c412b0a1887e5c1418#diff-6d73ebd58fdd2d00c32813f60608fbd1R10">relevant portion of the pull request</a> that made that change.</p>

<h3>Consolidating Tuple Types</h3>

<p>I <a href="https://ashfurrow.com/blog/uicollectionview-unjustly-maligned/">recently wrote about UICollectionView</a> and how I used them to solve a difficult layout problem. I detailed how I created a pipeline of simple math functions that used previous results to calculate the next step of the layout. What I didn't mention was that I used tuples to help, specifically tuples with <code>typealias</code>.</p>

<p>Tuples are useful for composing several different values into a lightweight type. Think of tuples as junior structs. I was writing functions to do some calculations and return their result as a tuple. Something like this:</p>

<pre><code class="swift">func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
</code></pre>

<p>And because of how the layout pipeline worked, I then needed to use the <em>same</em> tuple as a parameter for the next function.</p>

<pre><code class="swift">func centersForPosition(position: CellPosition, metrics: (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)) -&gt; ...
</code></pre>

<p>Any time you use the same tuple type more than once, consider making a <code>typealias</code>. In this case, the code became a lot shorter and easier to skim and understand.</p>

<pre><code class="swift">typealias LayoutMetrics = (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
typealias CenterXPositions = (restingCenterX: CGFloat, targetCenterX: CGFloat)

func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; LayoutMetrics

func centersForPosition(position: CellPosition, metrics: LayoutMetrics) -&gt; CenterXPositions
</code></pre>

<p>If we need to change something about the tuple later on, we only need to change it in one place. We've also made it easier to promote this tuple to a struct or class later on, just like in the JWT example, because all the functions are already referring to it as its own type. You can check out how we used type alias'd tuples <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/Views/LiveAuctionFancyLotCollectionViewLayout.swift#L104">in the code</a>.</p>

<h3>Defining Closures Signatures</h3>

<p>Objective-C developers, burdened with <a href="http://goshdarnblocksyntax.com">arcane syntax for blocks</a>, use C's <code>typedef</code> to isolate that syntax strangeness in one place. And even though Swift's closure syntax is <em>awesome</em>, we can still benefit from Objective-C's example – we can use type aliases for closure signatures.</p>

<p><a href="https://github.com/Moya/Moya">Moya</a> uses this technique quite a bit, because it has so many closures. Let's take a look at the <code>StubClosure</code>, which <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L78-L79">defines if (and how) a network request should be stubbed</a>.</p>

<pre><code class="swift">typealias StubClosure = Target -&gt; StubBehavior
</code></pre>

<p>We use this type as an initializer parameter instead of the full closure syntax, making our code a lot shorter and more legible. Nice! Since the user usually doesn't want to customize this parameter, so we've <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L97">defined a default value</a>.</p>

<pre><code class="swift">init(...
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    ...)
</code></pre>

<p><code>MoyaProvider</code> has a class function on it called <code>NeverStub</code> <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L246-L248">whose type</a> matches our closure.</p>

<pre><code class="swift">class func NeverStub(_: Target) -&gt; Moya.StubBehavior {
    return .Never
}
</code></pre>

<p>This particular function doesn't use the <code>typealias</code>, but another one does. We have a function named <code>DelayedStub</code> that returns the <code>typealias</code> instead of the raw closure. Take a look!</p>

<pre><code class="swift">class func DelayedStub(seconds: NSTimeInterval) -&gt; Moya.StubClosure {
    return { _ in return .Delayed(seconds: seconds) }
}
</code></pre>

<p>Super cool! Closures are a powerful tool in Swift already, but by using a <code>typealias</code>, we refer to it as <code>StubClosure</code> throughout our code.</p>

<p>In isolation, this gain may not seem significant, but the dividends have accrued dramatically for the project. <code>typealias</code> has made it easy to maintain Moya as it has evolved alongside Swift. Check out more examples of type aliasing closures <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/LiveAuctionStateManager.swift#L20-L21">in this eigen class</a>, which uses them for dependency injection.</p>

<h3>Extending Typealiases</h3>

<p>The last example I want to discuss is extensions, specifically extensions to <em>your own</em> types.</p>

<p>When writing classes, especially view controllers, developers have a habit of writing long, unwieldy files that are difficult to navigate and maintain. Preventing such files is far easier than fixing them, which is why I use <code>typealias</code> early, and I use it often.</p>

<p>I recommend using a descriptive <code>typealias</code> that is private to your file, and then extending that <code>typealias</code> so you can keep things neat and tidy. It's a bit confusing, so let's take a look at an example.</p>

<pre><code class="swift">private typealias PrivateHelperFunctions = MyViewController
extension PrivateHelperFunctions {
    ...
}

private typealias TableViewMethods = MyViewController
extension TableViewMethods: UITableViewDelegate, UITableViewDataSource {
   ...
}
</code></pre>

<p>We're still extending the view controller, but specifically we're extending the <code>typealias</code> so that the extension has a helpful name. This is another way that <code>typealias</code> can help add semantic meaning to your code.</p>

<p>Beyond helping you find code quickly, having code in extensions also makes it <em>way</em> easier to move that extension to another file or create a new helper class altogether. So not only does it keep classes tidy, but it also helps you keep classes <em>small</em>.</p>

<p>This technique can also serve as a workaround for Swift's <a href="http://stackoverflow.com/questions/24017316/pragma-mark-in-swift">awful Xcode sectioning syntax</a>.</p>

<p><img src="/images/2016-06-24-typealias-for-great-good/jumpbar.png" alt="Xcode Jumpbar" /></p>

<p>You can <a href="https://github.com/artsy/eigen/search?l=swift&amp;q=private+typealias&amp;utf8=%E2%9C%93">search through eigen</a> for more examples of using a private <code>typealias</code> to divide your code into manageable pieces.</p>

<hr />

<p>Look, I'm not saying that using <code>typealias</code> more is universally a good idea. You might disagree with some of the use cases in this post, which is fine! And this isn't meant to be an exhaustive list of examples, either.</p>

<p>My point is, used in a few key ways, <code>typealias</code> has helped me maintain my code more easily. It's a good tool to be familiar with. Even if it won't revolutionize the way you write software, <code>typealias</code> can help make your job a smidgen easier, and who could argue with that?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL for iOS Developers]]></title>
    <link href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/"/>
    <updated>2016-06-19T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/19/graphql-for-mobile</id>
    <content type="html"><![CDATA[<p>GraphQL is something you may have heard in passing, usually from the web team. It's a Facebook API technology, that describes itself as a <em>A Data Query Language and Runtime</em>. GraphQL is a <a href="http://facebook.github.io/graphql/">spec</a>, and there are <a href="https://github.com/chentsulin/awesome-graphql#libraries">multiple implementation</a> of it. As mobile engineers, we can consider it an API, where the front-end team have as much control as the backend.</p>

<p>This blog post covers our usage of GraphQL, and what I've learned in the last 3 months of using it in <a href="https://github.com/artsy/eigen/">Eigen</a>.</p>

<!-- more -->


<h3>So what is GraphQL</h3>

<p>You can get the full explanation on <a href="http://graphql.org">the GraphQL website</a>. Though, I found running through <a href="https://learngraphql.com">Learn GraphQL</a> site to really hammer down how it works. Reading the <a href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html">introduction blog post</a> can be useful too.</p>

<p>GraphQL is an API middle-layer. It acts as an intermediate layer between multiple front-end clients and multiple back-end APIs. This means it can easily coalesce multiple API calls into a single request, this can be a <em>massive</em> user experience improvement when you have a screen that requires information from multiple sources before you can present anything to a user.</p>

<p><img src="/images/2016-06-19-graphql-for-iOS-devs/graphQL.svg" width=100%></p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is heirarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, sending back the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is only what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL improves the app-user experience.</p>

<p>That's the two killer features:</p>

<ol>
<li>Coalesce Multiple Network Requests. Reducing the amount of network requests that need to be made.</li>
<li>Only Send The Data You Want. Only sending the data you are interested in.</li>
</ol>


<p>With mobile apps you're working with unreliable, slow networks with high bandwidth costs. Optimising towards less networking with richer data means your app is more resiliant to things outside of your control.</p>

<p>This is in stark contrast to existing API concepts, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model as a separate request.</p>

<h3>Using GraphQL</h3>

<p>Artsy's GraphQL server is (unsurprisingly) open-source, it's at <a href="https://github.com/artsy/metaphysics">artsy/metaphysics</a>. However, it's not publicly accessible, (<a href="https://github.com/artsy/metaphysics/issues/279">yet?</a>). One of the coolest things about developing against a GraphQL server is GraphiQL - an IDE for exploring your API. I can't show you ours, but I can send you to <a href="http://clayallsopp.com">Clay Allsop's</a> <a href="https://www.graphqlhub.com">GraphQLHub</a>:</p>

<p><a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%20%20%20%20%20%20username%0A%20%20%20%20%20%20commentKarma%0A%20%20%20%20%20%20createdISO%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20username%0A%20%20%20%20%20%20%20%20%20%20%09commentKarma%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D">Here</a> ( I strongly recommend pausing to open that link in a new window. Press cmd + enter to see the results. We also have an example of refactoring that request <a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%09%09%09...userFields%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%20%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%09%09%09%20%20%20%20%20%20...userFields%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0Afragment%20userFields%20on%20RedditUser%20%7B%0A%20%20username%0A%20%20commentKarma%0A%20%20createdISO%0A%7D">here</a>. )</p>

<p>GraphQL comes with a playground for the API! It's amazing! Clay called it the <a href="https://medium.com/the-graphqlhub/graphiql-graphql-s-killer-app-9896242b2125#.6ht6374bq">"Killer App" of GraphQL</a> - I'm inclined to concur. I've never had API docs this useful. This is built on top of the schema/docs/type reflection APIs inside the GraphQL spec.</p>

<p></div></div><a href='/images/2016-06-19-graphql-for-iOS-devs/graphiql.png'><img src="/images/2016-06-19-graphql-for-iOS-devs/graphiql.png" title="Selection diagram" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<h3>How GraphQL Changed How We Write Native Code</h3>

<h4>View Models</h4>

<p>Our GraphQL server is owned by the <a href="http://artsy.github.io/blog/2016/03/28/artsy-engineering-organization-stack/">web-practice</a> and the mobile practice also help out occasionally. This ownership distinction is important, an API like this would normally be handled by our platform team.</p>

<p>Because of Metaphysics' ownership as a "front-end" product, it can contain additional information that is specific to front-end needs. For example, in our first example of a request to our GraphQL server we requested <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code> - only two of these items come from the database. Both is <code>is_price_hidden</code> and <code>is_inquireable</code> are derived from the API results on the server.</p>

<p>This is <em>awesome</em>, because before a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L310-L362">lot of this logic</a> existed in a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L108-L109">Google Doc</a> which needed to be re-implemented in 3-4 clients. On the native side we would find we were out-of-date mid-release cycle and needed to rush to catch up.</p>

<p>So, what does this mean for view models? It lessens the need for them. If you can move a lot of your derived data to the server - this handles the logic that goes in a view model for you. Now it is provided server-side, and is consistent across platforms.</p>

<p>We've not stopped writing view models, but now discussions on them includes "should this move to Metaphysics?".</p>

<h4>React Native</h4>

<p>We've already <a href="https://twitter.com/orta/status/734880605322776576">shipped one full view controller</a> in <a href="https://facebook.github.io/react-native/">React Native</a> for our flagship app, <a href="https://github.com/artsy/eigen/">Eigen</a>. The advantages that came from GraphQL were a big part of the discussion around using React Native.</p>

<p>There will be longer articles on the "why" and "how" we choose to work this way. However, the key thing that we're excited about in using React Native is Relay. Using Relay, our <a href="https://github.com/artsy/emission/tree/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist">views</a> can declare a fragment of the GraphQL query that each respective <a href="https://github.com/artsy/emission/blob/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist/biography.js#L60-L69">view needs</a>.</p>

<p>So, in our Artist View Controller, the Biography "View" (<a href="https://facebook.github.io/react-native/docs/native-components-ios.html">component</a>) declares "when I am in the view heirarchy, you need to grab a <code>bio</code>, and <code>blurb</code>"</p>

<pre><code class="js">export default Relay.createContainer(Biography, {
  fragments: {
    artist: () =&gt; Relay.QL`
      fragment on Artist {
        bio
        blurb
      }
    `,
  }
});
</code></pre>

<p>Once your views are declaring what data they need, and are acting on that data - you see less of a need to use models.</p>

<hr />

<p>GraphQL is having a massive impact in the way that we write our apps. It means we can make much faster mobile apps, as the network is our critical path. Faster apps means happier users, happier users means happier developers. I want to be happy. So I'm thankful that the <a href="https://github.com/artsy/metaphysics/graphs/contributors">Web practice</a> gave GraphQL a try, and <a href="https://github.com/artsy/metaphysics/pull/243">welcome'd</a> <a href="https://github.com/artsy/metaphysics/pull/313">us</a> <a href="https://github.com/artsy/metaphysics/pull/226">to</a> <a href="https://github.com/artsy/metaphysics/pull/302">the</a> <a href="https://github.com/artsy/metaphysics/issues/2">party</a>.</p>
]]></content>
  </entry>
  
</feed>
