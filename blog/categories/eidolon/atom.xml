<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: eidolon | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/eidolon/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-11-01T15:18:29+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Eidolon Deploy Process]]></title>
    <link href="http://artsy.github.io/blog/2016/10/08/eidolon-deploy-process/"/>
    <updated>2016-10-08T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/10/08/eidolon-deploy-process</id>
    <content type="html"><![CDATA[<p>Since we <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">originally built</a> Eidolon ‚Äì an auction bidding kiosk app ‚Äì the project has largely remained in maintenance mode. Eidolon was one of the first projects that we used automated deploys for, and the deploy process has remained largely unchanged. I believe this stability of the deploy process is a testament to how well the automated deploys have gone.</p>

<p>This post is going to detail the mechanics of automated deploys for an enterprise-distributed iOS application, discuss lessons we learned and applied to other projects' deploy processes, and describe some of the changes we'd like to make. Our project is entirely open source, so you can check out any part of the code on your own or <a href="https://github.com/artsy/eidolon/issues/new">open an issue</a> with questions.</p>

<!-- more -->


<h2>Deploying Eidolon</h2>

<p>It's one command on the terminal to deploy Eidolon:</p>

<pre><code class="sh">bundle exec fast lane deploy version:X.Y.Z
</code></pre>

<p>This command does a lot of things. It uses <a href="https://fastlane.tools">Fastlane</a>, and you can <a href="https://github.com/artsy/eidolon/blob/a0aad31bccfe2b4abf648fc64892cc165be400b4/fastlane/Fastfile#L40-L131">read the entire script here</a>. We're going to go over each part line-by-line. A few notes:</p>

<ul>
<li>We run this command locally on a development machine that has the keys installed to sign a deploy.</li>
<li>Our changelog is formatted in <a href="https://en.wikipedia.org/wiki/YAML">yaml</a>, our script uses this strategically.</li>
<li>Our deploy script modifies the project's Info.plist version and build number, as well as the changelog.</li>
</ul>


<p>Let's dive in!</p>

<h2>The Script</h2>

<p>The first thing we do is verify that the version number we've been given is in the proper <a href="http://semver.org">SemVer</a> format.</p>

<pre><code class="rb">version = options[:version]
raise "You must specify a version in A.B.X format to deploy." if version.nil? || version.scan(/\d+\.\d+\.\d+/).length == 0
</code></pre>

<p>We deploy using Hockey, so make sure that an environment variable with the Hockey API key is set.</p>

<pre><code class="rb">hockey_api_token = ENV['HOCKEY_API_TOKEN']
raise "You must specify a HOCKEY_API_TOKEN environment variable to deploy." if hockey_api_token.nil?
</code></pre>

<p>We also want to verify that we have valid API keys for analytics, the Artsy API, and a few other services the app uses. This validation only makes sure the keys have been set to non-empty values. And we don't want to accidentally deploy uncommited changes, so we check the git status first.</p>

<pre><code class="rb">verify_pod_keys
ensure_git_status_clean
</code></pre>

<p>Next we need to set the build number. These need to be unique, and we use the current date. This could be a problem if we need to deploy more than once in a day. It hasn't been a problem yet, though, since we rarely deploy.</p>

<p>We also want to set the Info.plist's version to the one specified when we run the <code>fastlane</code> command.</p>

<pre><code class="rb">build_number = Time.new.strftime("%Y.%m.%d")
increment_build_number build_number: build_number

increment_version_number version_number: version
</code></pre>

<p>Okay, now it's time to generate markdown release notes from the changelog. Our changelog is in the following format:</p>

<pre><code class="yaml">upcoming:
- Upcoming version bug fix.

releases:
- version: X.Y.Z
  date: Month Day Year
  notes:
  - Previous version bug fix.
</code></pre>

<p>We want to grab the <code>upcoming</code> notes for the changelog, and then move them to the <code>releases</code> section. Let's generate the notes first:</p>

<pre><code class="rb">changelog_filename = '../CHANGELOG.yml'
changelog_yaml = YAML.load_file(changelog_filename)
release_notes = changelog_yaml['upcoming'].map{ |note| note.prepend '- ' }.join("\n")
</code></pre>

<p>Updating the changelog is a little messy. I tried parsing the changelog as yaml, modifying it, and then writing it back as yaml, but kept running into trouble. Instead, I treat it as plain text. We open the changelog, split on <code>releases:</code>, prepend the existing releases with a the generated release notes, and write the changelog.</p>

<pre><code class="rb">changelog_contents = File.read(changelog_filename)
existing_releases = changelog_contents.split('releases:').last
this_release = changelog_yaml['upcoming'].map{ |note| note.prepend '  ' }.join("\n")
changelog_contents = &lt;&lt;-EOS
upcoming:
releases:
- version: #{version}
  date: #{Time.new.strftime("%B %d %Y")}
  notes:
#{this_release}
#{existing_releases}
EOS

File.open(changelog_filename, 'w') { |file| file.puts changelog_contents }
</code></pre>

<p>At this point, we're ready to start the actual deploy process. First we need to download the provisioning profiles, which is only one step with Fastlane:</p>

<pre><code class="rb">sigh
</code></pre>

<p>Next we build our app using <code>gym</code>. We need to use the legacy build API, I can't remember why.</p>

<pre><code class="rb">gym(
  scheme: "Kiosk",
  export_method: 'enterprise',
  use_legacy_build_api: true
)
</code></pre>

<p>With our build finished, we upload to Hockey.</p>

<pre><code class="rb">hockey(
  api_token: hockey_api_token,
  notes: release_notes
)
</code></pre>

<p>Okay, our build is deployed. Time to let the team know there's a new version available:</p>

<pre><code class="rb">slack(
  message: "There is a new version of the Kiosk app available. Download it at http://artsy.net/kioskbeta",
  success: true,        # optional, defaults to true
  payload: {            # optional, lets you specify any number of your own Slack attachments
    'Version' =&gt; version,
    'What\'s new' =&gt; release_notes,
  },
  default_payloads: [],
)
</code></pre>

<p><code>default_payloads</code> needs to be empty I think, I can't remember why. Seems like "I can't remember why" is a common theme here...</p>

<p>Before committing the changes we've made to the changelog and Info.plist files, we need to clean any build artefacts. This includes the actual binary that was compiled, unit test coverage reports, and downloaded provisioning profiles.</p>

<pre><code class="rb">clean_build_artifacts
</code></pre>

<p>Finally, we commit, tag the build, and push to GitHub. Fastlane's built-in commands to commit to git reject any changes except to Info.plist files, and we've modified the changelog, so I used <code>sh</code> and used git directly.</p>

<pre><code class="rb">sh "git add .. ; git commit -m 'Deploying version #{version}.'"
add_git_tag tag: version
push_to_git_remote
</code></pre>

<p>And that's it! With one terminal command, we've done all the following:</p>

<ul>
<li>Verified version number format.</li>
<li>Verified the local environment is set up to deploy.</li>
<li>Verified API keys used by the app aren't empty.</li>
<li>Incremented the build number and version.</li>
<li>Updated the changelog.</li>
<li>Built and signed the app.</li>
<li>Uploaded the build to Hockey.</li>
<li>Posted a notification to Slack.</li>
<li>Tagged the release and pushed to GitHub.</li>
</ul>


<h2>Lessons Learned</h2>

<p>Automating Eidolon deploys was one of the first automated deploys we built on Artsy's iOS team. Now, based on Eidolon's successful deploy process, all our iOS deploys are automated.</p>

<p>We've learned a few lessons.</p>

<p>First, running deploys locally is <em>so 2015</em>. Our more modern deploy processes run on continuous integration servers like Circle CI. This poses some problems around securing certificates necessary to deploy, maybe we'll cover that in a future blog post.</p>

<p>We deploy on CI based on pushes to a specific branch, and we run our deploy script only if the unit tests pass. This is a huge incentive to keep CI green.</p>

<p>On other iOS projects, we sometimes deploy more than once a day, so we use <code>Year.Month.Day.Hour</code> as the build number format, which is unique enough to do one deploy per hour. This is good enough for now.</p>

<p>One thing I really wish I'd done when I set up automated deploys is to document things a little better. To be honest, that's part of the motivation to write this blog post (better late than never!).</p>

<h2>Conclusion</h2>

<p>Overall, automating deploys for Eidolon has been a huge win. The other night, we had an emergency at an auction: the Eidolon app was no longer working and we needed a new deploy.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Guess who‚Äôs got two thumbs and forgot that their enterprise distribution certificates expire in September.<br><br>üëçthis guyüëç</p>&mdash; Ash vs NSThread (@ashfurrow) <a href="https://twitter.com/ashfurrow/status/784548214527627266">October 8, 2016</a></blockquote>


<p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>From the time the team let me know about the problem to the time they had a fresh deploy with a new certificate, less than twenty minutes had passed. I issued one command and watched it do all the work for me. If I had to manually follow a set of arcane steps I hadn't done in a long time, our team might not have had the new build in time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Depedency Injection in Swift]]></title>
    <link href="http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/"/>
    <updated>2016-06-27T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift</id>
    <content type="html"><![CDATA[<p>Dependency Injection (DI) is a <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">$25 word for a 5¬¢ idea</a>, but it's an idea that has become wholly foundation to how I write software. I want to take a look at some of the ways our team have been using DI in Swift.</p>

<!-- more -->


<p>DI users in Swift (and Objective-C) are generally in one of a few camps:</p>

<ul>
<li>Use <a href="https://www.natashatherobot.com/unit-testing-swift-dependency-injection/">initializer injection</a> to provide objects with their dependencies.</li>
<li>Use property injection (<a href="https://ashfurrow.com/blog/lazy-property-setup-in-swift/">with laziness even!</a>).</li>
<li>Use <a href="https://github.com/Swinject/Swinject">frameworks like Swinject</a> to build dependency graphs at run time.</li>
</ul>


<p>If you've used storybards or nibs before, you have probably already used property injection via IBOutlets. I actually consider initializer injection and property injection to be roughly the equivalent, just with different timing.</p>

<p>If I had to pick a favourite, I like the initializer injection because it fits appropriately with the level of dynamism Swift offers. But Swift is still <em>super</em> young and there're lots of programming techniques to explore, so I've been experimenting with something new.</p>

<p>The idea is similar to initializer injection, where you provide an instance's dependencies, but instead of providing the dependencies directly, you provide closures that return a dependency. It sounds odd, and is best explained using an example that starts without any DI at all.</p>

<p>Okay, we've got a network layer that communicates with an API. We're writing the class that takes the parsed data from the <code>NetworkProvider</code> class and turns it into models consumable by the rest of the app. Right now it looks like this.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init() {
        networkProvider = NetworkProvider("https://api.wherever.com")
    }
}
</code></pre>

<p>There are some limitations to this, specifically around testing it. It would be better to have the <code>networkProvider</code> passed in as an argument to <code>init()</code>. That's initializer injection, and my opposition to it is that we've moved the responsibility for creating the <code>networkProvider</code> up the stack.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(networkProvider: NetworkProvider) {
        self.networkProvider = networkProvider
    }
}

...

let stateManager = StateManager(
    networkProvider: NetworkProvider("https://api.wherever.com")
    )
</code></pre>

<p>The thing is, now some <em>other</em> object has to know how to do create the <code>NetworkProvider</code>. Hrm. You can repeat this process of injecting dependencies from further up the stack until you have a general-purpose DI framework, and that's not my bag.</p>

<p>My approach passes a closure that <em>returns</em> a network provider instead of passing in a <code>networkProvider</code> instance directly. The parameter can be given a default implementation, too.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: () -&gt; NetworkProvider = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }

    class func defaultNetworkCreator() -&gt; (() -&gt; NetworkProvider) {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<p>There's a lot to unpack here, so let's take it slowly. The initializer has a new <code>networkProviderCreator</code>, a closure that returns a <code>NetworkProvider</code>. In the initializer, we set our property to the return value of the closure. We also have a class method that gives us a default implementation that's used in production.</p>

<p>But in tests, we can initialize the <code>StateManager</code> with a stub closure, something like:</p>

<pre><code class="swift">let fakeNetworkProvider = ...
let testSubject = StateManager({ fakeNetworkProvider })
</code></pre>

<p>Now you get the benefits of initializer injection, but the flexibility to only use DI when you need to.</p>

<p>Note: we should still test the <code>defaultNetworkCreator()</code> function to make sure it works, too. Having code behave differently specifically while being tested is not generally a good idea.</p>

<p>Applying the advice on using <code>typealias</code> from <a href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/">my last post</a>, we can tidy our code up a little bit.</p>

<pre><code class="swift">class StateManager {
    typealias NetworkCreator: () -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<h3>But wait, there's more!</h3>

<p>The other benefits of passing in a closure instead of an instance is that it lets the initializer customize the dependency based on other data. For example, let's say the state manager uses an <code>enum</code> to differentiate between staging and production API endpoints (btw, <a href="https://ashfurrow.com/blog/the-wrong-binary/">two-case enums are great at this</a>). How might our initializer change?</p>

<pre><code class="swift">enum APIEnvironment {
    case Staging, Production
}

class StateManager {
    typealias NetworkCreator: (String) -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        environment: APIEnvironment,
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        let baseURLString: String
        switch environment {
        case .Staging:
            baseURLString = "https://staging-api.wherever.com"
        case .Production:
            baseURLString = "https://api.wherever.com"
        }

        networkProvider = networkProviderCreator(baseURLString)
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return { baseURLString in
            NetworkProvider(baseURLString)
        }
    }
}
</code></pre>

<p>I really dig this. The closure to create the dependency is close to the code that uses it, but is insulated from any specific instance, so we get the benefits of using DI.</p>

<p>You could argue that picking a base URL for an API shouldn't belong here, and you could probably convince me. But my point isn't that this specific example is ideal, it's that the pattern of using closures for initializer injection is pretty neat.</p>

<p>The logic to create dependencies has to go <em>somewhere</em>. I think it makes sense to keep it close to the code that actually uses the dependency, but isolated in a <code>class</code> function so no actual instance is involved in its creation. As a result, developers get the benefits of initializer injection and none of the added cognitive overhead when writing your production code.</p>

<p>It may not be a perfect pattern (what is?) but we've been using it on <a href="https://github.com/artsy/eidolon">eidolon</a> and <a href="https://github.com/artsy/eigen">eigen</a> for nearly two years and ‚Äì combined with generous use of protocols ‚Äì we've been really happy with the results.</p>

<p>Now that I have more free time to explore the pattern, I want to take it a step further and see where it could be used outside of unit testing. It's possible that using this approach could make all our types less tightly coupled and provide a more modular codebase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: ARSwitchboard]]></title>
    <link href="http://artsy.github.io/blog/2015/08/19/Cocoa-Architecture-Switchboard-Pattern/"/>
    <updated>2015-08-19T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/08/19/Cocoa-Architecture-Switchboard-Pattern</id>
    <content type="html"><![CDATA[<p>As a part of going through the design patterns we've found in the creation of the Artsy iOS apps, I'd like to introduce the Switchboard pattern. This evolved quite naturally out of <a href="/blog/2015/08/15/Cocoa-Architecture:-Router-Pattern/">ARRouter</a> when applied to generating view controllers instead of API requests.</p>

<!-- more -->


<hr />

<h1>Where we started</h1>

<p>In what must be one of my best named commits, <code>b9ff28</code> aka <em>"CREATING THE VOID"</em> introduced an <code>ARSwitchboard</code> to Eigen. Aside from this being the commit where I could finally write <code>[ARVoidViewController theVoid]</code> it added support for tapping an Artwork on the home-screen and going to another view controller.</p>

<p>We knew up-front that we needed to emulate the website's URL schemes, so we needed to come up with a way to support two ways of loading up a view controller. Here's what it looked like:</p>

<pre><code class="objc">@implementation ARSwitchBoard

+ (void)setupRouter {
    artsyHosts = [NSSet setWithObjects:@"art.sy", @"artsyapi.com", @"artsy.net", nil];

    [RCRouter map:@"/artwork/:id" to:self with:@selector(loadArtworkFromURL:)];
}

+ (void)navigateToURL:(NSURL *)url {
    if([self isInternalURL:url] &amp;&amp; [RCRouter canRespondToRoute:url.path]) {
        [RCRouter dispatch:url.path];
    } else {
//        [self openInternalBrowser:url];
    }
}

+ (BOOL)isInternalURL:(NSURL *)url {
    NSString * host = url.host;
    if(host &amp;&amp; [host hasPrefix:@"www"]) {
        host = [host substringFromIndex:3];
    }

    return (host &amp;&amp; [artsyHosts containsObject:host]);
}

#pragma mark -
#pragma mark Artworks

+ (void)loadAttachmentCollection:(AttachmentCollection *)collection {
    [[ARVoidViewController theVoid] loadArtworkViewWithAttachmentCollection:collection];
}

+ (void)loadArtwork:(Artwork *)artwork {
    AttachmentCollection * collection = [AttachmentCollection collectionWithItems:@[artwork] andIndex:0];
    [self loadAttachmentCollection:collection];
}

+ (void)loadArtworkFromURL:(NSDictionary *)options {
    [[ARVoidViewController theVoid] loadArtworkViewWithID:options[@"id"]];
}

@end
</code></pre>

<p>It shows the pattern's humble origins quite well. The <code>ARSwitchboard</code> provides an API that any object can call, and it will handle presenting the view controller. Offering an API that can either use arbitrary URLs or model objects.</p>

<h2>Where the pattern evolved</h2>

<p>I initially wrote this during my "Class methods look prettier" stage. Our <code>ARSwitchboard</code> has evolved into using instance methods, and it uses a sharedInstance. This makes writing tests for the routing extremely simple for <a href="https://github.com/artsy/energy/blob/master/ArtsyFolio%20Tests/Util/ARSwitchboardTests.m">easy use cases</a>, and possible <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy_Tests/App_Tests/ARSwitchBoardTests.m">for the complex</a>.</p>

<p>The pattern was established pretty well by the time it was integrated <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m">into Energy</a>. Some of it's highlights are:</p>

<ul>
<li><p>The sharedInstance is <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m#L20-L31">set up</a> with some of the other singletons, from that point on it only acts on properties it owns.</p></li>
<li><p>It deals with setting up entire <a href="https://github.com/artsy/energy/blob/a35969d232d8309fd2aedaae35f2dbdf6d505004/Classes/Util/App/ARSwitchBoard.m#L229-L259">view hierarchies</a>. Not just pushing another view on to a <code>UINavigationController</code>.</p></li>
</ul>


<h2>Internal Routing</h2>

<p>We try to make all view controllers that could represent a URL have two initializers; one that accepts a full model object and another that works off an ID. This means that we can provide as much context as we can initially, but can generate everything at runtime if you've come from a push notification or from another app.</p>

<p>We use an internal routing tool to do the heavy-lifting here, currently this is <a href="https://cocoapods.org/pods/JLRoutes">JLRoutes</a> which we use to map URLs to blocks and dictionaries.</p>

<h2>Difficulties</h2>

<p>With Eigen we're trying to map the whole data-set of Artsy into a single app, which likely an architecture post of it's own. However, one of the issues we're having that really strains this metaphor is ambiguity in the routing system. For us this crops up in two places:
- The URL <a href="https://github.com/artsy/eigen/pull/534">routing structure</a> you're mapping against can change.
- When one route could have <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy/App/ARSwitchBoard.m#L156">many types</a> of data.</p>

<p>Handling routes that changes is something we ended up building an <a href="https://github.com/artsy/echo/blob/master/app/api/v1/presenters/route_presenter.rb">API for</a>. It provides a JSON package of routes and names, and Eigen updates its routing internally.</p>

<p>Having one route represent multiple <em>potential</em> view controllers is tricky. We didn't want to introduce asynchronicity to the <code>ARSwitchboard</code>, so we use <a href="https://github.com/artsy/eigen/blob/2eb00a8050a69ab2e05ffeb11a2bbdcbadf9fb7e/Artsy/View_Controllers/Fair/ARProfileViewController.m#L55-L66">polymorphic view controllers</a>. This is a technique where the view controller returned then looks deeper into what it is representing and using child view controllers, embeds the true view controller inside itself.</p>

<h2>Future</h2>

<p>Like all patterns, our <code>ARSwitchboard</code> pattern is evolving. With Eigen we have  a complicated navigation stack, due to supporting app-wide tabs and hosting navigation controllers inside view controllers. This adds additional logic to pretty complicated code when we're dealing with URLs that could be root elements of a tab. So we are planning to eventually move the presentation aspect of the <code>ARSwitchboard</code> into a separate object.</p>

<h2>Alternatives</h2>

<p>We didn't need an <code>ARSwitchboard</code> in Eidolon. Which, so far always seems to be the exception in these architecture pattern posts. Instead we opted for Apple's <a href="http://www.objc.io/issues/15-testing/dependency-injection/#which-di-framework-should-i-use">Dependency Injection tool</a>, Interface Builder + Storyboards. Energy pre-dates Storyboards, and they didn't feel like a good fit for Eigen.</p>

<p>We found storyboards to be a really good replacement to this pattern when you have an established series of steps in your application with some well defined connections.</p>

<p>As an example, our on-boarding process for Eigen probably should have been storyboarded, as it's a series of view controllers pushed incrementally. However given that the rest of Eigen is essentially a web of interconnected view controllers, we'd be abusing the tool.</p>

<h2>Wrap up</h2>

<p>So the Switchboard is a way that we've managed to contain some of the complexity around having web-like abilities to jump between any two view controllers. This pattern makes it easy to stub a switchboard in tests, and to easily test the routing itself.</p>

<p>When I looked through some of the other open source iOS apps to compare the pattern, I couldn't find anything similar. So if you do have something similar, you should probably Open Source your app ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: ARRouter]]></title>
    <link href="http://artsy.github.io/blog/2015/08/15/Cocoa-Architecture-Router-Pattern/"/>
    <updated>2015-08-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/08/15/Cocoa-Architecture-Router-Pattern</id>
    <content type="html"><![CDATA[<p>I want to talk about a pattern that we've been using for the last few years on the Artsy Mobile team. This pattern pre-dates me joining Artsy by a few weeks, and was introduced into our codebase by <a href="http://90wpm.com">Ben Jackson</a>, this was the <code>ARRouter</code>'s first method:</p>

<pre><code class="objc">  + (NSURL *)newOAuthURLWithUsername:(NSString *)username password:(NSString *)password {
      NSDictionary *params = [[NSDictionary alloc] initWithObjectsAndKeys:
                              username, @"email",
                              password, @"password",
                              ARAuthClientID, @"client_id",
                              ARAuthSecret, @"client_secret",
                              @"credentials", @"grant_type",
                              nil];
      NSString *url_string = [[NSString alloc] initWithFormat:@"%@%@", AROAuthURL, [params queryString]];
      NSURL *url = [ARRouter newURLWithPath:url_string];
      [url_string release];
      [params release];
      return url;
  }
</code></pre>

<p>Yep, that's pre-ARC, pre-Dictionary Literals, memory-managed code. We took this pattern and rolled with it for the next 4 years, this article is about where we've taken it.</p>

<p>Within Eigen, <code>ARRouter</code> is one of our <a href="https://github.com/artsy/eigen/blob/904e8abfc11ce6ea4b6e81f0e02684b755a280c3/Artsy/Networking/ARRouter.m">biggest classes</a>, coming in at almost 1,000 lines of code. Whereas in Energy, it sits at a <a href="https://github.com/artsy/energy/blob/e51529250ede359c781042f222d5836eb9e8a979/Classes/Util/App/ARRouter.m">more reasonable</a> 300 lines. Eidolon does not have an ARRouter, what gives?</p>

<!-- more -->


<hr />

<h2>Pattern Evolution</h2>

<p>We started out with a Router object as being something that can take a model object, and return a <code>NSURL</code> corresponding to a server side end-point.</p>

<p>This worked pretty well, we shipped a 1.0 of Energy with this pattern. However, it become obvious that we were putting a lot of extra knowledge about the type and the parameters of request into classes whose responsibility was not generating a route. For example, user account creation, and user account deletion would use the same <code>NSURL</code> but have different HTTP methods.</p>

<p>We migrated our networking stack to using AFNetworking <code>1.0</code>, and started using CocoaPods instead of manually dragging and dropping code. With this in mind, we improved on the pattern and started returning <code>NSURLRequest</code>s which better encapsulate the server end-point request we were trying to map in the Router.</p>

<p>The pattern evolved when mixed with a <a href="http://cocoadocs.org/docsets/AFNetworking/1.3.4/Classes/AFHTTPClient.html">AFHTTPClient</a> to act as the base URL resolver, allowing us to easily switch between staging and production environments, and as a central point for hosting all HTTP headers. This meant it was trivial to generate authenticated <code>NSURLRequest</code>s.</p>

<p>As it is presently, this pattern is working. We've just wrapped up a new Pod, <a href="https://github.com/artsy/Artsy_Authentication">Artsy Authentication</a>. It's a library that has an <code>ARRouter</code> that behaves <a href="https://github.com/artsy/Artsy_Authentication/blob/master/Pod/Classes/ArtsyAuthenticationRouter.h">exactly like above</a>. We continue to build new apps with the pattern.</p>

<h2>Siblings</h2>

<p>This pattern is standing the test of time, but that doesn't mean we're not actively trying to experiment within the domain. There are three interesting offshoots from our work on <code>ARRouter</code> that are worth talking about.</p>

<h4>Got the Routes like Swagger</h4>

<p>The difference between Eigen's <code>ARRouter</code> and Energy's <code>ARRouter</code> is pretty simple. Eigen's networking scope is an order of magnitude larger. This is a reflection on the varied data that Eigen is interested in, while Energy has a tight scope on specifically Artsy Parter related data.</p>

<p>During the new year of 2015, I explored the <a href="https://github.com/orta/GotTheRoutesLikeSwagger">idea of programmatically generating</a> an <code>ARRouter</code> as a CocoaPod, and then using CocoaPods' subspecs to make it easy to define what collections of end-points you were interested in. This project is based on a standard in which an API is documented, <a href="http://swagger.io">Swagger</a>. This meant as an API consumer, I can generate the types of <code>NSURLRequest</code>s I would require from the API itself. It created files that looked like:</p>

<pre><code class="objc">// Generated by Routes Like Swagger - 31/12/14

@interface ARRouter (User)

/// Retrieve a user by id.
/// @return URLRequest for /api/v1/user/{id}.{format}

- (NSURLRequest *)getUserWithID:(NSString * )slug;

/// Update an existing user.
/// @return URLRequest for /api/v1/user/{id}.{format}

- (NSURLRequest *)updateUserWithID:(NSString * )slug;

... [snip] ...

@end
</code></pre>

<p>This was a pretty nice expansion of the pattern, but overall felt a bit over-engineered and so, it was left as just an experiment.</p>

<h4>Moya</h4>

<p>When we started an entirely fresh application, we noted down all the networking-related pain points felt from Eigen and Energy. The Router pattern was pretty good, but we were finding that we were having problems with the API consuming part of the <code>NSURLRequest</code>s. Mainly, a difficulty in testing, an inconsistency in how we would perform networking and that it didn't feel declarative.</p>

<p>Moya is our attempt at fixing this. I won't go into depth on what Moya is, we've <a href="/blog/2014/09/22/transparent-prerequisite-network-requests/">written articles</a> on this already. The part that is interesting is that it obviates an ARRouter by using a collection of Swift enums - forcing developers to include all necessary metadata an an end-point.</p>

<h4>HAL, and API v2</h4>

<p>The Router pattern relies on the idea that you know all the routes ahead of time, and add support for them as you build out each part of the app. <a href="http://stateless.co/hal_specification.html">HAL, a Hypermedia Application Layer</a> - can be approximated as being a self describing API. dB. wrote about it in <a href="/blog/2014/09/12/designing-the-public-artsy-api/">this blog post</a>.</p>

<p>This means that you ask the API how to get certain bits of data, and it will describe the ways in which you can access it.</p>

<p>Artsy's future APIs are using this, and the Router pattern is, more or less, totally deprecated in this world. This is what an artwork's JSON data looks like in v2:</p>

<pre><code class="json">{
  "id": "4d8b92bb4eb68a1b2c00044a",
  "created_at": "2010-11-15T16:32:38+00:00",
  "updated_at": "2015-08-16T09:26:26+00:00",
  "name": "Jeff Koons",
  "sortable_name": "Koons Jeff",
  "gender": "male",
  "birthday": "1955",
  "hometown": "York, Pennsylvania",
  "location": "New York, New York",
  "nationality": "American",
  "_links": {
    "curies": [
      {
        "name": "image",
        "href": "https://d32dm0rphc51dk.cloudfront.net/Uqad2mGhbNGhAUgb8bUvIA/{rel}",
        "templated": true
      }
  ],
  "thumbnail": {
    "href": "https://d32dm0rphc51dk.cloudfront.net/Uqad2mGhbNGhAUgb8bUvIA/four_thirds.jpg"
  },
  "image:self": {
    "href": "{?image_version}.jpg",
    "templated": true
  },
  "self": {
    "href": "https://api.artsy.net/api/artists/4d8b92bb4eb68a1b2c00044a"
  },
  "permalink": {
    "href": "http://www.artsy.net/artist/jeff-koons"
  },
  "artworks": {
    "href": "https://api.artsy.net/api/artworks?artist_id=4d8b92bb4eb68a1b2c00044a"
  },
  "published_artworks": {
    "href": "https://api.artsy.net/api/artworks?artist_id=4d8b92bb4eb68a1b2c00044a&amp;published=true"
  },
  "similar_artists": {
    "href": "https://api.artsy.net/api/artists?similar_to_artist_id=4d8b92bb4eb68a1b2c00044a"
  },
  "similar_contemporary_artists": {
    "href": "https://api.artsy.net/api/artists?similar_to_artist_id=4d8b92bb4eb68a1b2c00044a&amp;similarity_type=contemporary"
  },
  "genes": {
    "href": "https://api.artsy.net/api/genes?artist_id=4d8b92bb4eb68a1b2c00044a"
  }
  },
  "image_versions": [
    "four_thirds",
    "large",
    "square",
    "tall"
  ]
}
</code></pre>

<p>You can see that via the _links section, curies and self-referential urls, you can build network client which traverses the API without built-in implicit knowledge.</p>

<p>It's a really exciting pattern, and as client developers, we can work on improving standard API clients that work on all HAL APIs. Instead of something specific to Artsy's API. A lot of the most interesting work in the Cocoa space has been done by Kyle Fuller with <a href="https://cocoapods.org/pods/Hyperdrive">Hyperdrive</a>.</p>

<h3>Wrap Up</h3>

<p>Given that we're not writing applications against the v2 API, yet. The Router pattern is working fine for us at Artsy. It can be a really nice way to abstract out a responsibility that may currently be sitting inside a very large API client that might be worth extracting out.</p>

<p>Let us know what you think, send tweets to <a href="https://twitter.com/ArtsyOpenSource">@ArtsyOpenSource</a> on twitter. Ps. it's pronounced "rooter".</p>
]]></content>
  </entry>
  
</feed>
