<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mobile | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/mobile/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-05-03T16:14:55+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why does my team's Podfile.lock Podspec checksums change?]]></title>
    <link href="http://artsy.github.io/blog/2016/05/03/podspec-checksums/"/>
    <updated>2016-05-03T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/05/03/podspec-checksums</id>
    <content type="html"><![CDATA[<p>With CocoaPods, <a href="https://github.com/artsy/eigen/issues/418">we don't check in our Pods</a> directory for one of our fastest moving apps. This sometimes can cause an <a href="https://github.com/artsy/eigen/pull/1464">interesting data churn</a> inside the <code>Podfile.lock</code> when developers have different sha checksums for their Pods. This is weird, what gives?</p>

<!-- more -->


<h3>What are the Lockfiles?</h3>

<p>First off, to ensure we're talking about the same thing, this is our <a href="https://github.com/artsy/eigen/blob/master/Podfile.lock">Podfile.lock</a>. The lockfile is used on <code>pod install</code> to ensure all the members of your team have the <em>exact same</em> version of the libraries as each other. Otherwise, with a Podfile like:</p>

<pre><code class="ruby">platform :ios, '9.3'
pod 'AFNetworking/Serialization', '~&gt; 3.0'
target 'MyApp'
</code></pre>

<p>A developer running <code>pod install</code> would get the latest <code>3.x</code> version, which could be <code>3.1</code> originally, but then 6 months later they could get <code>3.4</code> - without a lockfile there is no way to keep track of the specific build. This is why it should always be in your code repo. In the case above my lockfile looks like this:</p>

<pre><code class="yaml">PODS:
  - AFNetworking/Serialization (3.1.0)

DEPENDENCIES:
  - AFNetworking/Serialization (~&gt; 3.0)

SPEC CHECKSUMS:
  AFNetworking: 5e0e199f73d8626b11e79750991f5d173d1f8b67

PODFILE CHECKSUM: 876ceaa409f4ade2b3d58d310dbe026393824bcc

COCOAPODS: 1.0.0.beta.8
</code></pre>

<h3>What do the Spec Checksums do?</h3>

<p>With the CocoaPods Master Specs repo, we do our best <a href="https://github.com/CocoaPods/Specs/pull/12199">to try</a> and ensure a write-once repository of Podspecs for the public. However, there are many times when you cannot guarantee that every you have the same version of a Podspec as everyone else in your team.</p>

<p>So, CocoaPods makes a checksum of the JSON representation of your Podspec and keeps that in the lockfile. You can easily <a href="https://github.com/CocoaPods/CocoaPods/issues/3371">replicate</a> the work to generate a checksum with:</p>

<pre><code class="sh">~/D/MyApp ⏛  pod ipc spec ~/.cocoapods/repos/master/Specs/AFNetworking/3.1.0/AFNetworking.podspec.json  | openssl sha1
5e0e199f73d8626b11e79750991f5d173d1f8b67
</code></pre>

<h3>So why am I seeing churn?</h3>

<p>A normal git development flow when working with libraries is to:</p>

<ul>
<li>Fork a library, change your Podfile to reflect that change</li>
<li>Make some changes</li>
<li>Commit them back to the main repo</li>
<li>Update the Podspec, then make changes bringing your Podfile back to a real (tagged) release</li>
</ul>


<p>CocoaPods is smart about updating your libraries behind the scenes, but it's not perfect. In order to avoid re-creating your entire Pods folder every time it will check whether your libraries are at the expected version and skip re-creating the whole process.</p>

<p>In the example above, we used the CocoaPods' Specs repo version of the Podspec. In forked repos, e,g,</p>

<pre><code class="ruby">pod 'AFNetworking/Serialization', :git =&gt; "https://github.com/orta/AFNetworking.git", :commit =&gt; "6f31b5c7bcbd59d4dac7e92e215d3c2c22f3400e"
</code></pre>

<p>The Podspec is saved into the <code>Pods</code> directory in JSON format at <code>Pods/Local\ Podspecs/AFNetworking.podspec.json</code>, this is to ensure there's always access within the CocoaPods sandbox for the Podspecs, and speed probably. This is the podspec used for generating the checksum.</p>

<p><strong>So how can this get out of sync?</strong></p>

<ul>
<li>During the development cycle, when working with a library you would have used <code>pod update [library]</code> to update just that library you were working on.  This could happen multiple times as you build your changes.</li>
<li>You continued working against your fork till it was ready for review. At this point you have a working version, you submit a PR for code review on the library.</li>
<li>There are changes that affect the podspec that come up in review, you don't do a <code>pod update [library]</code> but send the code back to review ( maybe you changed some metadata for example, which doesn't warrant another update to pass CI. )</li>
<li>Once all code is reviewed, everything is merged back into master.</li>
<li>You <code>pod install</code> - which continues to use the older version of the Podspec inside the Pods dir, e.g. <code>Pods/Local\ Podspecs/AFNetworking.podspec.json</code>.</li>
<li>You now have the older <code>AFNetworking.podspec.json</code> inside your local Pods folder, when the next person runs <code>pod install</code> with your changes merged, they get a different SHA, as they've got the version with the metadata changes.</li>
</ul>


<h3>Simple Fix</h3>

<p>The best option is to run <code>pod update [library]</code> on the computer which is causing churn, this will tell CocoaPods specifically to request a new version of the library. If that fails to give the same checksum as the rest of your team, there's the good old fasioned <code>rm -rf Pods &amp;&amp;  pod install</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Paw with Per-Developer Settings]]></title>
    <link href="http://artsy.github.io/blog/2016/04/14/net-working-with-paw/"/>
    <updated>2016-04-14T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/04/14/net-working-with-paw</id>
    <content type="html"><![CDATA[<p>I am a big fan of developer tooling, as spending time upfront on improving your process can pay a lot of dividends over time. I want to talk about one in particular: <a href="https://luckymarmot.com/paw">Paw</a>. Paw is a native HTTP client with a bunch of features. I want to cover one that means that we can now <a href="https://github.com/artsy/energy/pull/192">introduce</a> <code>[AppName].paw</code> files in our mobile projects, making it easy for us to discuss networking requests.</p>

<!-- more -->


<h3>OK, what is Paw?</h3>

<p>Paw is a tool that stores collections of API endpoints, along with all the metadata required to call them. We first started using Paw during the creation <a href="https://github.com/artsy/eidolon/blob/master/Kiosk/Stubbed%20Responses/Me.json">of Eidolon</a> as a way to keep track of the auction-related API calls we would need to stub for <a href="http://cocoapods.org/pods/moya">Moya</a>, an iOS networking library that required stubbed data. It made it easy for us to keep track of how all the different API routes work together, and to verify that we were doing things right.</p>

<p></div></div><a href='/images/2016-04-14-Paw/eidolon.png'><img src="/images/2016-04-14-Paw/eidolon.png" title="paw tokens" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>We used environment variables to keep track of things we wanted to change, but in using them this way we couldn't publicise our Paw files, the real versions contained secrets that should stay secret.</p>

<p><img src="/images/2016-04-14-Paw/eidolon-env.png" alt="Environments for Eidolon" /></p>

<p>The environment tooling made it easy to change the routes, users and settings easily, but were also the thing keeping us from being able to share the files in source. Because of this, we stopped using Paw to keep track of our routes as we had to ad-hoc share the file over chat.</p>

<h3>A Second Shot</h3>

<p>This week, roughly a year and a half later, I started work on a <a href="https://github.com/artsy/energy/pull/189">large project</a> that I knew would involve using new networking APIs. So I took the time to look for ways to interpret what I was going to be working with. After exploring some alternatives, I came back to Paw, and discovered they had a <a href="https://blog.luckymarmot.com/posts/paw-23-keep-it-secret-keep-it-safe/">new feature</a>: Keychain integration. This stopped my search.</p>

<p>In our iOS projects, as they are all open source, we use <a href="https://github.com/orta/cocoapods-keys">CocoaPods-Keys</a> to ensure that our development configuration secrets are kept safe and outside of the project's source code. It stores the per-project keys inside a developer's Keychain. This means they can be accessed from inside the iOS app, but also from the <a href="/images/2016-04-14-Paw/keychain.png">developer's computer</a> via a determinate location in the Keychain app.</p>

<pre><code>~/d/i/a/energy (master) ⏛  bundle exec pod keys
Keys for Folio
 ├  ArtsyAPIClientSecret - [***********]
 ├  ArtsyAPIClientKey - [***********]
 ├  HockeyAppBetaID - [***********]
 ├  HockeyAppLiveID - [***********]
 ├  IntercomAppID - [***********]
 ├  IntercomAPIKey - [***********]
 ├  SegmentProduction - [***********]
 ├  SegmentBeta - [***********]
 └  SegmentDev - [***********]
</code></pre>

<p>This means that we can use CocoaPods-Keys with Paw in order to use the same <code>ArtsyAPIClientSecret</code> and <code>ArtsyAPIClientKey</code> environment config variables. Great. This is almost enough to make the first API call to to get an access token.</p>

<p>I re-used this idea to allow developers to have unique username and passwords. I created two more entires in Keychain, username and <a href="/images/2016-04-14-Paw/keychain-password.png">password</a>. This is something that every developer using our Paw file has to do, otherwise Paw won't know who to log you in as.</p>

<p><img src="/images/2016-04-14-Paw/keychain-username.png" alt="Keychain Email" /></p>

<p>With these all hooked up, I could set up Paw to use all of our Keychain entities:</p>

<p><img src="/images/2016-04-14-Paw/paw-adding-keychain.png" alt="Paw Adding Keychain" />
<img src="/images/2016-04-14-Paw/paw-setting-password.png" alt="Paw Setting Password" /></p>

<p>Tada! Now I can run my route, and I've got an access token to use with our API.</p>

<h3>Route Resolving</h3>

<p>Automating the route to get an access token is the first step because Paw allows you to use the output of one route inside any new route. I'll show you, then talk it through.</p>

<p></div></div><a href='/images/2016-04-14-Paw/paw-tokens.png'><img src="/images/2016-04-14-Paw/paw-tokens.png" title="paw tokens" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>I made it so that my new request ( for the route <code>api/v1/me</code>)  passes in an header of <code>X-Access-Token</code>, with the value being the <code>access_token</code> from the route we just made called <code>Auth</code>. This means that when the token expires, it will automatically re-generate a new one and we're never storing the token explicitly inside the Paw file. Our secrets stay secret, and per-developer - I don't want to know other people's passwords.</p>

<p>Once those two routes were set up, it was a matter of looking up what routes I would need and added them to the paw file for the project. I used the group system to make it easy to show / hide sections, and experimented with using environments to differentiate between staging and production servers. Not quite figured that yet.</p>

<h3>Wrap up</h3>

<p>It's easier to talk about your API when any other developer can open this one file and shoot off requests at the same time as you. One of my favourite nice-touches is to be able to easily convert any request into a cURL command.</p>

<p>I am using this event as a reminder to myself that tools evolve, and maybe your first impression on a developer tool may require re-interpreting in light of software evolution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Xcode's Schemes to run a subset of your tests]]></title>
    <link href="http://artsy.github.io/blog/2016/04/06/Testing-Schemes/"/>
    <updated>2016-04-06T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/04/06/Testing-Schemes</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/artsy/eigen">Eigen</a> has hit the point where testing is a chore. This is a positive sign, the app has grown in terms of size, complexity, and number of developers considerably over the last 3 years. The test suite makes us feel comfortable making changes.</p>

<p>On my fastest computer, we're just under a minute - <code>Executed 1105 tests, with 1 failure (0 unexpected) in 43.221 (48.201) seconds</code>  for the whole suite. I think I could probably live with 20 seconds max. So I studied how <a href="https://www.jetbrains.com/objc/">AppCode</a> handles running tests, and this will be an illustrated guide as to how you can easily run the subset of tests in Xcode based on their techniques.</p>

<p> I <a href="https://github.com/orta/life/issues/71">have ideas</a> on how to improve time for testing in general, based on <a href="http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection/">Code Injection</a>, but they aren't fully fleshed out and I expect it to be time-intensive to pull off. Time I haven't made yet.</p>

<!-- more -->


<h3>What are Schemes?</h3>

<blockquote><p>An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute.</p>

<p>You can have as many schemes as you want, but only one can be active at a time. You can specify whether a scheme should be stored in a project—in which case it’s available in every workspace that includes that project, or in the workspace—in which case it’s available only in that workspace. When you select an active scheme, you also select a run destination (that is, the architecture of the hardware for which the products are built).</p></blockquote>

<p>To <a href="https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Schemes.html">quote Apple</a>.</p>

<h3>Hatching a Scheme</h3>

<p>The Eigen Test Suite is around 50 test classes, these look a bit like this:</p>

<p><img src="/images/2016-04-06-Testing-Schemes/tests.png" alt="Tests" /></p>

<p>Before you start, you want to be able to say, "I want to only run tests for the Fairs section of Eigen", as that is where I will be working for the next few days. To get started, I need to create a new Scheme. You will have seen the schemes before when you click on the Target side of this Targer/Sim button in the top left of Xcode.</p>

<p><img src="/images/2016-04-06-Testing-Schemes/empty_scheme.png" alt="Empty Scheme" /></p>

<p>This is what it looks like on mine, we want to create a new scheme. This brings up a modal window where you need to choose your App's target (this is so you can continue running by pressing <code>cmd + r</code>.)</p>

<p><img src="/images/2016-04-06-Testing-Schemes/new_scheme.png" alt="New Scheme" /></p>

<p>I've called mine "Artsy just for Fairs", as I'm the only person who would see it, I can name it whatever I want. Clicking "OK" selects it, and hides the modal. You now need to go back to the target selector, and go to "Edit Schemes ..." to continue though.</p>

<p><img src="/images/2016-04-06-Testing-Schemes/edit_schemes.png" alt="Edit Schemes" /></p>

<h3>Making Amends</h3>

<p>OK, click on "Test" in the sidebar, and now you're in the Schemes Test editor. This is where you do the work.</p>

<p><img src="/images/2016-04-06-Testing-Schemes/empty_edit_schemes.png" alt="Empty Edit Schemes" /></p>

<p>You need to hit the "+" in order to add your Test Target to the Scheme</p>

<p><img src="/images/2016-04-06-Testing-Schemes/test_scheme.png" alt="Test Scheme" /></p>

<p>Select and "Add" you Targets. This adds the target, you then need to click the disclosure arrow in order to show all the Test Classes.</p>

<p><em>OK, here's some magic</em>. Hold <code>alt</code> and click on the blue tickbox to the right of your test target to turn it off. Then click again, without <code>alt</code>. It should then deselect all of the classes. This is standard in all Mac apps, so go wild there.</p>

<p><img src="/images/2016-04-06-Testing-Schemes/deselect_all.png" alt="Deselect All" /></p>

<p>This means you can go find the classes you do want to run, in my case that is the Test Classes relating to Fairs.</p>

<p><img src="/images/2016-04-06-Testing-Schemes/just_the_good_tests.png" alt="Just The Good Tests" /></p>

<p>Now when I press <code>cmd + u</code> it will only run those test classes.</p>

<h3>Wrapping Up</h3>

<p>Which means I can now get back to work at a reasonable pace. <code>Executed 15 tests, with 0 failures (0 unexpected) in 0.277 (0.312) seconds</code>. I can then run the full suite whenever I go and make a cup of tea.</p>

<p><em>Note:</em> If you want to avoid using the mouse to change scheme, the <a href="/images/2016-04-06-Testing-Schemes/next_prev.png">key commands</a> to change between visible schemes is <code>cmd + ctrl + [</code> and  <code>cmd + ctrl + ]</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Injection for Xcode]]></title>
    <link href="http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection/"/>
    <updated>2016-03-05T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection</id>
    <content type="html"><![CDATA[<p>I have been writing code for roughly a decade. A large chunk of that time has been sitting waiting for my project to compile. It's a nice excuse to <a href="https://xkcd.com/303/">practice sword fighting</a> in the office, but really, deep down. It's frustrating. It's so easy to become <a href="https://xkcd.com/356/">nerd-sniped</a> when you wait for a long time.</p>

<p>As we integrate Swift into our projects, I've been seeing our compile times increase. So, I took some time to look at ways to improve this. The best option, so far, has been dynamic code injection via <a href="https://github.com/johnno1962/injectionforxcode">Injection Plugin for Xcode</a>. In a gist: This means that we don't recompile and re-launch, instead we inject new bits of code into a running application. This reduced the compile cycle on Eigen from 7 seconds to 1 second.</p>

<p>I took some time over the weekend to try and put together a video showing how I used code injection on a trivial app to create a view controller in code. It covers the technique I've <a href="https://github.com/artsy/eigen/pull/1236">started using in Eigen</a> and talks a little bit about how the pieces come together.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=uftvtmyZ8TM">to YouTube</a> for the video, or click more for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/uftvtmyZ8TM ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Review: Energy Sync]]></title>
    <link href="http://artsy.github.io/blog/2016/02/12/Code-Review-Energy-Sync/"/>
    <updated>2016-02-12T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/02/12/Code-Review-Energy-Sync</id>
    <content type="html"><![CDATA[<p>We are slowly trying to do high-level code-review views for all of our iOS apps. So far, we've covered <a href="/blog/2016/01/14/eidolon-code-review/">Eidolon</a> and <a href="/blog/2015/11/05/Emergence-Code-Review/">Emergence</a> and now <a href="/blog/2016/02/11/Code-Review-Energy/">Energy</a>. This is the second part of the Energy code review. The <a href="/blog/2016/02/11/Code-Review-Energy/">first part</a> covers the the critical codepaths that go from the App's launch to sending an email, which is the main use-case for the app. This video covers how Folio does sync between the Artsy API and the app.</p>

<p>Sync is a complex problem. This video covers our old techniques, how we changed them, the underlying abstractions we use now and how we can test each component individually. It's an hour long, and it's a little computer-sciencey. So I think people who have shipped some small apps would get a lot out of it.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=05HaKChPe_g">to YouTube</a> for the video, or click more for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/05HaKChPe_g ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
</feed>
