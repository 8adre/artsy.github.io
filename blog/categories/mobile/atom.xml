<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mobile | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/mobile/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-06-27T18:11:13+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Depedency Injection in Swift]]></title>
    <link href="http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/"/>
    <updated>2016-06-27T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift</id>
    <content type="html"><![CDATA[<p>Dependency Injection (DI) is a <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">$25 word for a 5¢ idea</a>, but it's an idea that has become wholly foundation to how I write software. I want to take a look at some of the ways our team have been using DI in Swift.</p>

<!-- more -->


<p>DI users in Swift (and Objective-C) are generally in one of a few camps:</p>

<ul>
<li>Use <a href="https://www.natashatherobot.com/unit-testing-swift-dependency-injection/">initializer injection</a> to provide objects with their dependencies.</li>
<li>Use property injection (<a href="https://ashfurrow.com/blog/lazy-property-setup-in-swift/">with laziness even!</a>).</li>
<li>Use <a href="https://github.com/Swinject/Swinject">frameworks like Swinject</a> to build dependency graphs at run time.</li>
</ul>


<p>If you've used storybards or nibs before, you have probably already used property injection via IBOutlets. I actually consider initializer injection and property injection to be roughly the equivalent, just with different timing.</p>

<p>If I had to pick a favourite, I like the initializer injection because it fits appropriately with the level of dynamism Swift offers. But Swift is still <em>super</em> young and there're lots of programming techniques to explore, so I've been experimenting with something new.</p>

<p>The idea is similar to initializer injection, where you provide an instance's dependencies, but instead of providing the dependencies directly, you provide closures that return a dependency. It sounds odd, and is best explained using an example that starts without any DI at all.</p>

<p>Okay, we've got a network layer that communicates with an API. We're writing the class that takes the parsed data from the <code>NetworkProvider</code> class and turns it into models consumable by the rest of the app. Right now it looks like this.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init() {
        networkProvider = NetworkProvider("https://api.wherever.com")
    }
}
</code></pre>

<p>There are some limitations to this, specifically around testing it. It would be better to have the <code>networkProvider</code> passed in as an argument to <code>init()</code>. That's initializer injection, and my opposition to it is that we've moved the responsibility for creating the <code>networkProvider</code> up the stack.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(networkProvider: NetworkProvider) {
        self.networkProvider = networkProvider
    }
}

...

let stateManager = StateManager(
    networkProvider: NetworkProvider("https://api.wherever.com")
    )
</code></pre>

<p>The thing is, now some <em>other</em> object has to know how to do create the <code>NetworkProvider</code>. Hrm. You can repeat this process of injecting dependencies from further up the stack until you have a general-purpose DI framework, and that's not my bag.</p>

<p>My approach passes a closure that <em>returns</em> a network provider instead of passing in a <code>networkProvider</code> instance directly. The parameter can be given a default implementation, too.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: () -&gt; NetworkProvider = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }

    class func defaultNetworkCreator() -&gt; (() -&gt; NetworkProvider) {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<p>There's a lot to unpack here, so let's take it slowly. The initializer has a new <code>networkProviderCreator</code>, a closure that returns a <code>NetworkProvider</code>. In the initializer, we set our property to the return value of the closure. We also have a class method that gives us a default implementation that's used in production.</p>

<p>But in tests, we can initialize the <code>StateManager</code> with a stub closure, something like:</p>

<pre><code class="swift">let fakeNetworkProvider = ...
let testSubject = StateManager({ fakeNetworkProvider })
</code></pre>

<p>Now you get the benefits of initializer injection, but the flexibility to only use DI when you need to.</p>

<p>Note: we should still test the <code>defaultNetworkCreator()</code> function to make sure it works, too. Having code behave differently specifically while being tested is not generally a good idea.</p>

<p>Applying the advice on using <code>typealias</code> from <a href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/">my last post</a>, we can tidy our code up a little bit.</p>

<pre><code class="swift">class StateManager {
    typealias NetworkCreator: () -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<h3>But wait, there's more!</h3>

<p>The other benefits of passing in a closure instead of an instance is that it lets the initializer customize the dependency based on other data. For example, let's say the state manager uses an <code>enum</code> to differentiate between staging and production API endpoints (btw, <a href="https://ashfurrow.com/blog/the-wrong-binary/">two-case enums are great at this</a>). How might our initializer change?</p>

<pre><code class="swift">enum APIEnvironment {
    case Staging, Production
}

class StateManager {
    typealias NetworkCreator: (String) -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        environment: APIEnvironment,
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        let baseURLString: String
        switch environment {
        case .Staging:
            baseURLString = "https://staging-api.wherever.com"
        case .Production:
            baseURLString = "https://api.wherever.com"
        }

        networkProvider = networkProviderCreator(baseURLString)
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return { baseURLString in
            NetworkProvider(baseURLString)
        }
    }
}
</code></pre>

<p>I really dig this. The closure to create the dependency is close to the code that uses it, but is insulated from any specific instance, so we get the benefits of using DI.</p>

<p>You could argue that picking a base URL for an API shouldn't belong here, and you could probably convince me. But my point isn't that this specific example is ideal, it's that the pattern of using closures for initializer injection is pretty neat.</p>

<p>The logic to create dependencies has to go <em>somewhere</em>. I think it makes sense to keep it close to the code that actually uses the dependency, but isolated in a <code>class</code> function so no actual instance is involved in its creation. As a result, developers get the benefits of initializer injection and none of the added cognitive overhead when writing your production code.</p>

<p>It may not be a perfect pattern (what is?) but we've been using it on <a href="https://github.com/artsy/eidolon">eidolon</a> and <a href="https://github.com/artsy/eigen">eigen</a> for nearly two years and – combined with generous use of protocols – we've been really happy with the results.</p>

<p>Now that I have more free time to explore the pattern, I want to take it a step further and see where it could be used outside of unit testing. It's possible that using this approach could make all our types less tightly coupled and provide a more modular codebase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Type Aliases: Use Early and Often]]></title>
    <link href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/"/>
    <updated>2016-06-24T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/24/typealias-for-great-good</id>
    <content type="html"><![CDATA[<p>It's been so fun to watch the Swift developer community experiment with Swift and to experiment with what idiomatic Swift will look like. No one really knows the answer yet, but we're starting to see some design patterns used more than others. We're seeing some language features used in key ways that define idiomatic Swift, and other language features that are being mostly ignored.</p>

<p>Regrettably, one of my favourite features of Swift has not enjoyed the meteoric rise in popularity I believe it deserves: <code>typealias</code>.</p>

<!-- more -->


<p>Type aliases allow developers to define synonyms for pre-existing types. It might sound dull because it <em>is</em> dull. In fact, its usefulness isn't even apparent when <em>writing</em> code, mostly when <em>maintaining</em> it.</p>

<p>But before I dig into how <code>typealias</code> is useful, let's review what it is to make sure we're all on the same page. Developers use <code>typealias</code> to create a new type identifier that's a synonym for another type. For example, we can declare <code>typealias BigNumber = Int64</code> and use "BigNumber" any place we could have used "Int64".</p>

<pre><code class="swift">func multiply(lhs: BigNumber, rhs: BigNumber) -&gt; BigNumber

...

let number: BigNumber = 5

...

let number = BigNumber(5)
</code></pre>

<p>You can use <code>typealias</code> for most any type: classes, enums, structs, tuples, closures, etc. Here are a few examples.</p>

<pre><code class="swift">typealias Name = String
typealias Employees = Array&lt;Employee&gt;
typealias GridPoint = (Int, Int)
typealias CompletionHandler = (ErrorType?) -&gt; Void
</code></pre>

<p>Now that we're familiar with <code>typealias</code>, I want to discuss four examples that show how <code>typealias</code> has helped us maintain code.</p>

<h3>Promoting Existing Types Semantics</h3>

<p>When writing web socket communication for eigen, Orta and I were using <a href="https://jwt.io">JSON Web Tokens</a> to authenticate the user. If you've never used JWTs before, don't worry, here's the tl;dr JWTs are a way to authenticate users in a way that clients can cryptographically verify. It's <em>basically</em> a base64 encoded string of JSON.</p>

<p>Clients don't need to verify the JWT in order to use them, and in fact when Orta and I began using them, we treated them only as strings retrieved from one API and sent to another (like an access token). However, instead of using the <code>String</code> type, I decided to define a <code>JWT</code> type alias.</p>

<pre><code class="swift">typealias JWT = String
</code></pre>

<p>I used the new <code>JWT</code> type throughout the code as a hint to other developers about what <em>kind</em> of string it is. This gave it some semantic meaning on top of being a string. Neat. Only later, when we needed to start decoding the JWT itself did this really come in handy.</p>

<p>After deleting the <code>typealias</code> and replacing it with a class of the same name, we didn't have to worry about changing function definitions and property types all throughout our codebase. We made the changes locally, in one file, and most all the rest of our code still compiled. Pretty cool! Here's the <a href="https://github.com/artsy/eigen/pull/1638/files/911473424849240bb71b89c412b0a1887e5c1418#diff-6d73ebd58fdd2d00c32813f60608fbd1R10">relevant portion of the pull request</a> that made that change.</p>

<h3>Consolidating Tuple Types</h3>

<p>I <a href="https://ashfurrow.com/blog/uicollectionview-unjustly-maligned/">recently wrote about UICollectionView</a> and how I used them to solve a difficult layout problem. I detailed how I created a pipeline of simple math functions that used previous results to calculate the next step of the layout. What I didn't mention was that I used tuples to help, specifically tuples with <code>typealias</code>.</p>

<p>Tuples are useful for composing several different values into a lightweight type. Think of tuples as junior structs. I was writing functions to do some calculations and return their result as a tuple. Something like this:</p>

<pre><code class="swift">func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
</code></pre>

<p>And because of how the layout pipeline worked, I then needed to use the <em>same</em> tuple as a parameter for the next function.</p>

<pre><code class="swift">func centersForPosition(position: CellPosition, metrics: (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)) -&gt; ...
</code></pre>

<p>Any time you use the same tuple type more than once, consider making a <code>typealias</code>. In this case, the code became a lot shorter and easier to skim and understand.</p>

<pre><code class="swift">typealias LayoutMetrics = (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
typealias CenterXPositions = (restingCenterX: CGFloat, targetCenterX: CGFloat)

func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; LayoutMetrics

func centersForPosition(position: CellPosition, metrics: LayoutMetrics) -&gt; CenterXPositions
</code></pre>

<p>If we need to change something about the tuple later on, we only need to change it in one place. We've also made it easier to promote this tuple to a struct or class later on, just like in the JWT example, because all the functions are already referring to it as its own type. You can check out how we used type alias'd tuples <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/Views/LiveAuctionFancyLotCollectionViewLayout.swift#L104">in the code</a>.</p>

<h3>Defining Closures Signatures</h3>

<p>Objective-C developers, burdened with <a href="http://goshdarnblocksyntax.com">arcane syntax for blocks</a>, use C's <code>typedef</code> to isolate that syntax strangeness in one place. And even though Swift's closure syntax is <em>awesome</em>, we can still benefit from Objective-C's example – we can use type aliases for closure signatures.</p>

<p><a href="https://github.com/Moya/Moya">Moya</a> uses this technique quite a bit, because it has so many closures. Let's take a look at the <code>StubClosure</code>, which <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L78-L79">defines if (and how) a network request should be stubbed</a>.</p>

<pre><code class="swift">typealias StubClosure = Target -&gt; StubBehavior
</code></pre>

<p>We use this type as an initializer parameter instead of the full closure syntax, making our code a lot shorter and more legible. Nice! Since the user usually doesn't want to customize this parameter, so we've <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L97">defined a default value</a>.</p>

<pre><code class="swift">init(...
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    ...)
</code></pre>

<p><code>MoyaProvider</code> has a class function on it called <code>NeverStub</code> <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L246-L248">whose type</a> matches our closure.</p>

<pre><code class="swift">class func NeverStub(_: Target) -&gt; Moya.StubBehavior {
    return .Never
}
</code></pre>

<p>This particular function doesn't use the <code>typealias</code>, but another one does. We have a function named <code>DelayedStub</code> that returns the <code>typealias</code> instead of the raw closure. Take a look!</p>

<pre><code class="swift">class func DelayedStub(seconds: NSTimeInterval) -&gt; Moya.StubClosure {
    return { _ in return .Delayed(seconds: seconds) }
}
</code></pre>

<p>Super cool! Closures are a powerful tool in Swift already, but by using a <code>typealias</code>, we refer to it as <code>StubClosure</code> throughout our code.</p>

<p>In isolation, this gain may not seem significant, but the dividends have accrued dramatically for the project. <code>typealias</code> has made it easy to maintain Moya as it has evolved alongside Swift. Check out more examples of type aliasing closures <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/LiveAuctionStateManager.swift#L20-L21">in this eigen class</a>, which uses them for dependency injection.</p>

<h3>Extending Typealiases</h3>

<p>The last example I want to discuss is extensions, specifically extensions to <em>your own</em> types.</p>

<p>When writing classes, especially view controllers, developers have a habit of writing long, unwieldy files that are difficult to navigate and maintain. Preventing such files is far easier than fixing them, which is why I use <code>typealias</code> early, and I use it often.</p>

<p>I recommend using a descriptive <code>typealias</code> that is private to your file, and then extending that <code>typealias</code> so you can keep things neat and tidy. It's a bit confusing, so let's take a look at an example.</p>

<pre><code class="swift">private typealias PrivateHelperFunctions = MyViewController
extension PrivateHelperFunctions {
    ...
}

private typealias TableViewMethods = MyViewController
extension TableViewMethods: UITableViewDelegate, UITableViewDataSource {
   ...
}
</code></pre>

<p>We're still extending the view controller, but specifically we're extending the <code>typealias</code> so that the extension has a helpful name. This is another way that <code>typealias</code> can help add semantic meaning to your code.</p>

<p>Beyond helping you find code quickly, having code in extensions also makes it <em>way</em> easier to move that extension to another file or create a new helper class altogether. So not only does it keep classes tidy, but it also helps you keep classes <em>small</em>.</p>

<p>This technique can also serve as a workaround for Swift's <a href="http://stackoverflow.com/questions/24017316/pragma-mark-in-swift">awful Xcode sectioning syntax</a>.</p>

<p><img src="/images/2016-06-24-typealias-for-great-good/jumpbar.png" alt="Xcode Jumpbar" /></p>

<p>You can <a href="https://github.com/artsy/eigen/search?l=swift&amp;q=private+typealias&amp;utf8=%E2%9C%93">search through eigen</a> for more examples of using a private <code>typealias</code> to divide your code into manageable pieces.</p>

<hr />

<p>Look, I'm not saying that using <code>typealias</code> more is universally a good idea. You might disagree with some of the use cases in this post, which is fine! And this isn't meant to be an exhaustive list of examples, either.</p>

<p>My point is, used in a few key ways, <code>typealias</code> has helped me maintain my code more easily. It's a good tool to be familiar with. Even if it won't revolutionize the way you write software, <code>typealias</code> can help make your job a smidgen easier, and who could argue with that?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL for iOS Developers]]></title>
    <link href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/"/>
    <updated>2016-06-19T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/19/graphql-for-mobile</id>
    <content type="html"><![CDATA[<p>GraphQL is something you may have heard in passing, usually from the web team. It's a Facebook API technology, that describes itself as a <em>A Data Query Language and Runtime</em>. GraphQL is a <a href="http://facebook.github.io/graphql/">spec</a>, and there are <a href="https://github.com/chentsulin/awesome-graphql#libraries">multiple implementation</a> of it. As mobile engineers, we can consider it an API, where the front-end team have as much control as the backend.</p>

<p>This blog post covers our usage of GraphQL, and what I've learned in the last 3 months of using it in <a href="https://github.com/artsy/eigen/">Eigen</a>.</p>

<!-- more -->


<h3>So what is GraphQL</h3>

<p>You can get the full explanation on <a href="http://graphql.org">the GraphQL website</a>. Though, I found running through <a href="https://learngraphql.com">Learn GraphQL</a> site to really hammer down how it works. Reading the <a href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html">introduction blog post</a> can be useful too.</p>

<p>GraphQL is an API middle-layer. It acts as an intermediate layer between multiple front-end clents and multiple back-end APIs. This means it can easily coalesce multiple API calls into a single request, this can be a <em>massive</em> user experience improvement when you have a screen that requires information from multiple sources before you can present anything to a user.</p>

<p><img src="/images/2016-06-19-graphql-for-iOS-devs/graphQL.svg" width=100%></p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is heirarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, sending back the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is only what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL improves the app-user experience.</p>

<p>That's the two killer features:</p>

<ol>
<li>Coalesce Multiple Network Requests. Reducing the amount of network requests that need to be made.</li>
<li>Only Send The Data You Want. Only sending the data you are interested in.</li>
</ol>


<p>With mobile apps you're working with unreliable, slow networks with high bandwidth costs. Optimising towards less networking with richer data means your app is more resiliant to things outside of your control.</p>

<p>This is in stark contrast to existing API concepts, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model as a separate request.</p>

<h3>Using GraphQL</h3>

<p>Artsy's GraphQL server is (unsurprisingly) open-source, it's at <a href="https://github.com/artsy/metaphysics">artsy/metaphysics</a>. However, it's not publicly accessible, (<a href="https://github.com/artsy/metaphysics/issues/279">yet?</a>). One of the coolest things about developing against a GraphQL server is GraphiQL - an IDE for exploring your API. I can't show you ours, but I can send you to <a href="http://clayallsopp.com">Clay Allsop's</a> <a href="https://www.graphqlhub.com">GraphQLHub</a>:</p>

<p><a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%20%20%20%20%20%20username%0A%20%20%20%20%20%20commentKarma%0A%20%20%20%20%20%20createdISO%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20username%0A%20%20%20%20%20%20%20%20%20%20%09commentKarma%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D">Here</a> ( I strongly recommend pausing to open that link in a new window. Press cmd + enter to see the results. We also have an example of refactoring that request <a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%09%09%09...userFields%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%20%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%09%09%09%20%20%20%20%20%20...userFields%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0Afragment%20userFields%20on%20RedditUser%20%7B%0A%20%20username%0A%20%20commentKarma%0A%20%20createdISO%0A%7D">here</a>. )</p>

<p>GraphQL comes with a playground for the API! It's amazing! Clay called it the <a href="https://medium.com/the-graphqlhub/graphiql-graphql-s-killer-app-9896242b2125#.6ht6374bq">"Killer App" of GraphQL</a> - I'm inclined to concur. I've never had API docs this useful. This is built on top of the schema/docs/type reflection APIs inside the GraphQL spec.</p>

<p></div></div><a href='/images/2016-06-19-graphql-for-iOS-devs/graphiql.png'><img src="/images/2016-06-19-graphql-for-iOS-devs/graphiql.png" title="Selection diagram" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<h3>How GraphQL Changed How We Write Native Code</h3>

<h4>View Models</h4>

<p>Our GraphQL server is owned by the <a href="http://artsy.github.io/blog/2016/03/28/artsy-engineering-organization-stack/">web-practice</a> and the mobile practice also help out occasionally. This ownership distinction is important, an API like this would normally be handled by our platform team.</p>

<p>Because of Metaphysics' ownership as a "front-end" product, it can contain additional information that is specific to front-end needs. For example, in our first example of a request to our GraphQL server we requested <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code> - only two of these items come from the database. Both is <code>is_price_hidden</code> and <code>is_inquireable</code> are derived from the API results on the server.</p>

<p>This is <em>awesome</em>, because before a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L310-L362">lot of this logic</a> existed in a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L108-L109">Google Doc</a> which needed to be re-implemented in 3-4 clients. On the native side we would find we were out-of-date mid-release cycle and needed to rush to catch up.</p>

<p>So, what does this mean for view models? It lessens the need for them. If you can move a lot of your derived data to the server - this handles the logic that goes in a view model for you. Now it is provided server-side, and is consistent across platforms.</p>

<p>We've not stopped writing view models, but now discussions on them includes "should this move to Metaphysics?".</p>

<h4>React Native</h4>

<p>We've already <a href="https://twitter.com/orta/status/734880605322776576">shipped one full view controller</a> in <a href="https://facebook.github.io/react-native/">React Native</a> for our flagship app, <a href="https://github.com/artsy/eigen/">Eigen</a>. The advantages that came from GraphQL were a big part of the discussion around using React Native.</p>

<p>There will be longer articles on the "why" and "how" we choose to work this way. However, the key thing that we're excited about in using React Native is Relay. Using Relay, our <a href="https://github.com/artsy/emission/tree/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist">views</a> can declare a fragment of the GraphQL query that each respective <a href="https://github.com/artsy/emission/blob/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist/biography.js#L60-L69">view needs</a>.</p>

<p>So, in our Artist View Controller, the Biography "View" (<a href="https://facebook.github.io/react-native/docs/native-components-ios.html">component</a>) declares "when I am in the view heirarchy, you need to grab a <code>bio</code>, and <code>blurb</code>"</p>

<pre><code class="js">export default Relay.createContainer(Biography, {
  fragments: {
    artist: () =&gt; Relay.QL`
      fragment on Artist {
        bio
        blurb
      }
    `,
  }
});
</code></pre>

<p>Once your views are declaring what data they need, and are acting on that data - you see less of a need to use models.</p>

<hr />

<p>GraphQL is having a massive impact in the way that we write our apps. It means we can make much faster mobile apps, as the network is our critical path. Faster apps means happier users, happier users means happier developers. I want to be happy. So I'm thankful that the <a href="https://github.com/artsy/metaphysics/graphs/contributors">Web practice</a> gave GraphQL a try, and <a href="https://github.com/artsy/metaphysics/pull/243">welcome'd</a> <a href="https://github.com/artsy/metaphysics/pull/313">us</a> <a href="https://github.com/artsy/metaphysics/pull/226">to</a> <a href="https://github.com/artsy/metaphysics/pull/302">the</a> <a href="https://github.com/artsy/metaphysics/issues/2">party</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why does my team's Podfile.lock Podspec checksums change?]]></title>
    <link href="http://artsy.github.io/blog/2016/05/03/podspec-checksums/"/>
    <updated>2016-05-03T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/05/03/podspec-checksums</id>
    <content type="html"><![CDATA[<p>We use CocoaPods, and <a href="https://github.com/artsy/eigen/issues/418">we don't check in our Pods</a> directory for one of our fastest moving apps, <a href="https://github.com/artsy/eigen/">Eigen</a>. This sometimes can cause an <a href="https://github.com/artsy/eigen/pull/1464">interesting data churn</a> inside the <code>Podfile.lock</code> when developers have different sha checksums for their Pods. This is weird, what gives?</p>

<!-- more -->


<h3>What are the Lockfiles?</h3>

<p>First off, to ensure we're talking about the same thing, this is our <a href="https://github.com/artsy/eigen/blob/master/Podfile.lock">Podfile.lock</a>. The lockfile is used on <code>pod install</code> to ensure all the members of your team have the <em>exact same</em> version of the libraries as each other. Otherwise, with a Podfile like:</p>

<pre><code class="ruby">platform :ios, '9.3'
pod 'AFNetworking/Serialization', '~&gt; 3.0'
target 'MyApp'
</code></pre>

<p>A developer running <code>pod install</code> would get the latest <code>3.x</code> version, which could be <code>3.1</code> originally, but then 6 months later they could get <code>3.4</code> - without a lockfile there is no way to keep track of the specific build. This is why it should always be in your code repo. In the case above my lockfile looks like this:</p>

<pre><code class="yaml">PODS:
  - AFNetworking/Serialization (3.1.0)

DEPENDENCIES:
  - AFNetworking/Serialization (~&gt; 3.0)

SPEC CHECKSUMS:
  AFNetworking: 5e0e199f73d8626b11e79750991f5d173d1f8b67

PODFILE CHECKSUM: 876ceaa409f4ade2b3d58d310dbe026393824bcc

COCOAPODS: 1.0.0.beta.8
</code></pre>

<h3>What do the Spec Checksums do?</h3>

<p>With the CocoaPods Master Specs repo, we do our best <a href="https://github.com/CocoaPods/Specs/pull/12199">to try</a> and ensure a write-once repository of Podspecs for the public. However, there are many times when you cannot guarantee that every you have the same version of a Podspec as everyone else in your team.</p>

<p>So, CocoaPods makes a checksum of the JSON representation of your Podspec and keeps that in the lockfile. You can easily <a href="https://github.com/CocoaPods/CocoaPods/issues/3371">replicate</a> the work to generate a checksum with:</p>

<pre><code class="sh">~/D/MyApp ⏛  pod ipc spec ~/.cocoapods/repos/master/Specs/AFNetworking/3.1.0/AFNetworking.podspec.json  | openssl sha1
5e0e199f73d8626b11e79750991f5d173d1f8b67
</code></pre>

<h3>So why am I seeing churn?</h3>

<p>A normal git development flow when working with libraries is to:</p>

<ul>
<li>Fork a library, change your Podfile to reflect that change</li>
<li>Make some changes</li>
<li>Commit them back to the main repo</li>
<li>Update the Podspec, then make changes bringing your Podfile back to a real (tagged) release</li>
</ul>


<p>CocoaPods is smart about updating your libraries behind the scenes, but it's not perfect. In order to avoid re-creating your entire Pods folder every time it will check whether your libraries are at the expected version and skip re-creating the whole process.</p>

<p>In the example above, we used the CocoaPods' Specs repo version of the Podspec. In forked repos, e,g,</p>

<pre><code class="ruby">pod 'AFNetworking/Serialization', :git =&gt; "https://github.com/orta/AFNetworking.git", :commit =&gt; "6f31b5c7bcbd59d4dac7e92e215d3c2c22f3400e"
</code></pre>

<p>The Podspec is saved into the <code>Pods</code> directory in JSON format at <code>Pods/Local\ Podspecs/AFNetworking.podspec.json</code>, this is to ensure there's always access within the CocoaPods sandbox for the Podspecs, and speed probably. This is the podspec used for generating the checksum.</p>

<p><strong>So how can this get out of sync?</strong></p>

<ul>
<li>During the development cycle, when working with a library you would have used <code>pod update [library]</code> to update just that library you were working on.  This could happen multiple times as you build your changes.</li>
<li>You continued working against your fork till it was ready for review. At this point you have a working version, you submit a PR for code review on the library.</li>
<li>There are changes that affect the podspec that come up in review, you don't do a <code>pod update [library]</code> but send the code back to review ( maybe you changed some metadata for example, which doesn't warrant another update to pass CI. )</li>
<li>Once all code is reviewed, everything is merged back into master.</li>
<li>You <code>pod install</code> - which continues to use the older version of the Podspec inside the Pods dir, e.g. <code>Pods/Local\ Podspecs/AFNetworking.podspec.json</code>.</li>
<li>You now have the older <code>AFNetworking.podspec.json</code> inside your local Pods folder, when the next person runs <code>pod install</code> with your changes merged, they get a different SHA, as they've got the version with the metadata changes.</li>
</ul>


<h3>Simple Fix</h3>

<p>The best option is to run <code>pod update [library]</code> on the computer which is causing churn, this will tell CocoaPods specifically to request a new version of the library. If that fails to give the same checksum as the rest of your team, there's the good old fasioned <code>rm -rf Pods &amp;&amp;  pod install</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Paw with Per-Developer Settings]]></title>
    <link href="http://artsy.github.io/blog/2016/04/14/net-working-with-paw/"/>
    <updated>2016-04-14T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/04/14/net-working-with-paw</id>
    <content type="html"><![CDATA[<p>I am a big fan of developer tooling, as spending time upfront on improving your process can pay a lot of dividends over time. I want to talk about one in particular: <a href="https://luckymarmot.com/paw">Paw</a>. Paw is a native HTTP client with a bunch of features. I want to cover one that means that we can now <a href="https://github.com/artsy/energy/pull/192">introduce</a> <code>[AppName].paw</code> files in our mobile projects, making it easy for us to discuss networking requests.</p>

<!-- more -->


<h3>OK, what is Paw?</h3>

<p>Paw is a tool that stores collections of API endpoints, along with all the metadata required to call them. We first started using Paw during the creation <a href="https://github.com/artsy/eidolon/blob/master/Kiosk/Stubbed%20Responses/Me.json">of Eidolon</a> as a way to keep track of the auction-related API calls we would need to stub for <a href="http://cocoapods.org/pods/moya">Moya</a>, an iOS networking library that required stubbed data. It made it easy for us to keep track of how all the different API routes work together, and to verify that we were doing things right.</p>

<p></div></div><a href='/images/2016-04-14-Paw/eidolon.png'><img src="/images/2016-04-14-Paw/eidolon.png" title="paw tokens" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>We used environment variables to keep track of things we wanted to change, but in using them this way we couldn't publicise our Paw files, the real versions contained secrets that should stay secret.</p>

<p><img src="/images/2016-04-14-Paw/eidolon-env.png" alt="Environments for Eidolon" /></p>

<p>The environment tooling made it easy to change the routes, users and settings easily, but were also the thing keeping us from being able to share the files in source. Because of this, we stopped using Paw to keep track of our routes as we had to ad-hoc share the file over chat.</p>

<h3>A Second Shot</h3>

<p>This week, roughly a year and a half later, I started work on a <a href="https://github.com/artsy/energy/pull/189">large project</a> that I knew would involve using new networking APIs. So I took the time to look for ways to interpret what I was going to be working with. After exploring some alternatives, I came back to Paw, and discovered they had a <a href="https://blog.luckymarmot.com/posts/paw-23-keep-it-secret-keep-it-safe/">new feature</a>: Keychain integration. This stopped my search.</p>

<p>In our iOS projects, as they are all open source, we use <a href="https://github.com/orta/cocoapods-keys">CocoaPods-Keys</a> to ensure that our development configuration secrets are kept safe and outside of the project's source code. It stores the per-project keys inside a developer's Keychain. This means they can be accessed from inside the iOS app, but also from the <a href="/images/2016-04-14-Paw/keychain.png">developer's computer</a> via a determinate location in the Keychain app.</p>

<pre><code>~/d/i/a/energy (master) ⏛  bundle exec pod keys
Keys for Folio
 ├  ArtsyAPIClientSecret - [***********]
 ├  ArtsyAPIClientKey - [***********]
 ├  HockeyAppBetaID - [***********]
 ├  HockeyAppLiveID - [***********]
 ├  IntercomAppID - [***********]
 ├  IntercomAPIKey - [***********]
 ├  SegmentProduction - [***********]
 ├  SegmentBeta - [***********]
 └  SegmentDev - [***********]
</code></pre>

<p>This means that we can use CocoaPods-Keys with Paw in order to use the same <code>ArtsyAPIClientSecret</code> and <code>ArtsyAPIClientKey</code> environment config variables. Great. This is almost enough to make the first API call to to get an access token.</p>

<p>I re-used this idea to allow developers to have unique username and passwords. I created two more entries in Keychain, username and <a href="/images/2016-04-14-Paw/keychain-password.png">password</a>. This is something that every developer using our Paw file has to do, otherwise Paw won't know who to log you in as.</p>

<p><img src="/images/2016-04-14-Paw/keychain-username.png" alt="Keychain Email" /></p>

<p>With these all hooked up, I could set up Paw to use all of our Keychain entities:</p>

<p><img src="/images/2016-04-14-Paw/paw-adding-keychain.png" alt="Paw Adding Keychain" />
<img src="/images/2016-04-14-Paw/paw-setting-password.png" alt="Paw Setting Password" /></p>

<p>Tada! Now I can run my route, and I've got an access token to use with our API.</p>

<h3>Route Resolving</h3>

<p>Automating the route to get an access token is the first step because Paw allows you to use the output of one route inside any new route. I'll show you, then talk it through.</p>

<p></div></div><a href='/images/2016-04-14-Paw/paw-tokens.png'><img src="/images/2016-04-14-Paw/paw-tokens.png" title="paw tokens" ></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>I made it so that my new request ( for the route <code>api/v1/me</code>)  passes in an header of <code>X-Access-Token</code>, with the value being the <code>access_token</code> from the route we just made called <code>Auth</code>. This means that when the token expires, it will automatically re-generate a new one and we're never storing the token explicitly inside the Paw file. Our secrets stay secret, and per-developer - I don't want to know other people's passwords.</p>

<p>Once those two routes were set up, it was a matter of looking up what routes I would need and added them to the paw file for the project. I used the group system to make it easy to show / hide sections, and experimented with using environments to differentiate between staging and production servers. Not quite figured that yet.</p>

<h3>Wrap up</h3>

<p>It's easier to talk about your API when any other developer can open this one file and shoot off requests at the same time as you. One of my favourite nice-touches is to be able to easily convert any request into a cURL command.</p>

<p>I am using this event as a reminder to myself that tools evolve, and maybe your first impression on a developer tool may require re-interpreting in light of software evolution.</p>
]]></content>
  </entry>
  
</feed>
