<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: roads and bridges | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/roads-and-bridges/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2019-03-27T22:17:37+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native, 3 years later]]></title>
    <link href="http://artsy.github.io/blog/2019/03/17/three-years-of-react-native/"/>
    <updated>2019-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/17/three-years-of-react-native</id>
    <content type="html"><![CDATA[<p>On Valentine's day in 2014, @alloy made our first commit moving the Artsy Mobile team to JavaScript, and paving the
way to the <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">shared Omakase JavaScript stack across web + iOS</a>. We've done a write-up at <a href="/blog/2016/08/15/React-Native-at-Artsy/">6 months</a>, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/">1 year</a>,
<a href="/blog/2018/03/17/two-years-of-react-native/">2 years</a> and at 2.5 years we collaborated on a React Native conference with Facebook which features a <a href="http://artsy.net/x-react-native">very long
Q&amp;A</a> session with the people who worked on, and with our React Native stack.</p>

<p>Our experience has been really positive building a single platform data-driven app. We've been able to drastically
increase the number of contributors to the codebase and with minimal guidance, web-developers are able to be
productive and ship features to our iOS apps.</p>

<p>That said, for this 3 year anniversary, I want to dive deeper into some of the less positive aspects of our
transition. We think these trade-offs are worth it, and that this may be what a successful cultural transition
eventually looks like for some companies.</p>

<!-- more -->


<a name="De-nativification"></a>
<h2>De-nativification</h2>

<p>When adopting React Native, we de-emphasized iOS as a unique platform for Artsy.</p>

<p>From an engineering team's perspective, we think of it as skill <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#de-silo-engineers">de-siloing</a>. Prior to the move, if you
were on the mobile team you only worked on the iOS apps. This meant you had a limited scope to make change at
Artsy. This comes from two factors:</p>

<ul>
<li>Skills in Obj-C and Swift are only useful in the context of Apple's platforms.</li>
<li>Internally and externally, Artsy is considered a website first.</li>
</ul>


<p>Within 2 years we had de-siloed mobile engineering completely. We started with a team of 5 experienced native iOS
developers and by the end everyone had very solid skills across the board in JavaScript, React, GraphQL and the
build tools we'd need to make it all come together. These engineers kept their native skills, but they became
frozen in time.</p>

<p>With time, we redistributed the native engineers across many teams, with the native Engineers effectively acting as
a conduit for ensuring that we keep quality high and providing guidance to the rest of that team on how to make it
feel right. A simple way to think of it, is that the native engineer's job was to make sure we still conformed to
the <a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human Interface Guidelines</a> to ensure
the user experience is consistent with the platform and the user’s expectations.</p>

<p>We're reasonably lucky here too, the mobile team at Artsy has pre-dominantly hired folks interested in improving
behind-the-scenes (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">Roads and Bridges</a> style) infrastructure. Once we had wrapped up the move, we effectively
took all of our native product developers and moved them into JavaScript platform infrastructure roles.</p>

<p>This was one of the major blocking points for AirBnB's adoption of React Native, specifically their native teams
felt uncomfortable at the introduction of JavaScript and a whole new toolchain inside their apps. There are people
who really love being a product developer in a native codebase, and React Native as a technology will de-value that
as more work would happen in JavaScript.</p>

<p>(Note: this is a gross simplification, and me reading between the lines, you should read from the horse’s mouth and
check out <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">Airbnb’s posts</a> (and <a href="https://ashfurrow.com/blog/airbnb-and-react-native-expectations/">Ash's continuation</a> on the subject ))</p>

<p>After a year of adopting React Native, the ex-mobile team used to joke that no-one enjoyed working in the native
codebase anymore. They still did. Three years down the line, with most screens now in React Native, that's not a
joke anymore.</p>

<p>This has consequences.</p>

<a name="Platform.Concerns"></a>
<h2>Platform Concerns</h2>

<p>De-siloing our mobile team obviously wasn't without its risk. In expanding the scope of our mobile engineering
team, and opening up the iOS app for contributions to the rest of the company we:</p>

<ul>
<li>Moved the engineers with a native focus to act more like platform engineers vs product engineers.</li>
<li>Had iOS native platform engineers with the skills to now also work on the web's platform.</li>
</ul>


<p>This is what started to make our third year tricky. In Artsy, web is the <a href="https://en.wikipedia.org/wiki/The_squeaky_wheel_gets_the_grease">squeaky wheel</a>.</p>

<p>After figuring out the JavaScript infrastructure for React Native on iOS, we replicated that infrastructure on the
web to consolidate tooling and ideas across all of Artsy. We call that infrastructure for both <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">the Artsy
Omakase</a>. Maintaining, and keeping the infrastructure up-to-date on the web side is a much bigger task and
requires a lot more engineering time.</p>

<p>The web-aspect of the Omakase has more client consumers (1 iOS app vs 3 large websites), and its corresponding repo
has more than double the number of commits per day on average. The web team has its own people running and
improving infrastructure, which affects the iOS side too.</p>

<p>We explicitly worked towards shared common infrastructure across all front-end at Artsy. It wasn't surprising when
the aspect with the most company focus became much larger and more complex. What creates tricky constraints are
that the few people with the interest and skills to work on our React Native infrastructure also happen to have the
skills to work on the web problems too.</p>

<p>Those web problems tend to be a lot more valuable to the business.</p>

<p>There's some work that can be done to benefit both, but in the last year it has been hard to prioritise
iOS-specific platform work. For example, it took almost a year to get around to upgrading our version of React
Native. This is a pretty risky place to be for a platform which we care about.</p>

<p>At the end of 2018, we came to the conclusion that this was something we wanted to work to improve. So, we
specifically brought back an explicit iOS-specific culture to Artsy - when we split our front-end practice into web
and <a href="https://github.com/artsy/README/commit/95c9b93ab966ed269b5ebd9f0bdec8d2434bab52#diff-342d3433f36fbedadc5a8f167985fdf3">iOS</a>.</p>

<p>Maybe this is a small admission of failure to the idea of a purely de-silo'd team, but realistically while product
work across the two front-ends teams is consistent - the platform concerns just aren't.</p>

<a name="Keeping.up.with.the.Jobs."></a>
<h2>Keeping up with the Jobs'</h2>

<p>As individual developers, it's much less important for us to keep up to date with the latest Apple developer news.
WWDCs and iOS releases just kinda happen, and we keep moving independently.</p>

<p>This is a side-effect to the openness of the JavaScript toolchain, and our ability to contribute and fix a lot of
our own problems at JavaScript level instead of needing to dive deeper into the native side to work on problems. We
still support iOS 9, and have very little incentive to bump it - new APIs from Apple just aren't that interesting
anymore.</p>

<p>Without a focused iOS team, it's not easy to pitch for iOS specific projects. This means that features like moving
to Apple's new app store review API or using iOS features which don't exist on web get spoken about in meetings,
but never started. This lack of a focused team makes it really hard to implement fixes to e.g. bad App Store
reviews.</p>

<p>That said, in the last year we did manage to ship a pretty hefty <a href="/blog/2018/03/18/ar/">ARKit feature</a> - which is a positive
example of an iOS-specific feature which is both forward-thinking tech and a super great fit for Artsy's product.
React Native basically played no part in that.</p>

<a name="Community.Disconnection"></a>
<h2>Community Disconnection</h2>

<p>There are maybe four communities at play if you're doing React Native:</p>

<ul>
<li>JavaScript (Babel/TypeScript/Storybooks/VSCode)</li>
<li>React (Relay/Styled Components)</li>
<li>React Native (Mostly people creating cross-platform tools)</li>
<li>Native (Obj-C/Swift/CocoaPods/fastlane etc)</li>
</ul>


<p>It's hard to keep on-top of any one community, and it's very hard to keep on track of four. Realistically, if you
want to be writing apps at the level of quality we want to - you need to, though.</p>

<p>Artsy's principal of <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">owning our dependencies</a> means involved in all of these communities, however it's
hard to engage in the native community with too much excitement anymore. Most of their problems aren't the same as
ours anymore, and the dependencies we want to improve live in the JavaScript realms.</p>

<a name="Universal.Issues."></a>
<h2>Universal Issues?</h2>

<p>Are these the kind of problems most teams would have? It depends, with React Native at Artsy our focus on:</p>

<ul>
<li>Offering a consistent way to write code across web and iOS, which doesn’t water down either platform.</li>
<li>Ensuring we are able to meaningfully own our dependencies across the stacks.</li>
</ul>


<p>Means that we took on some technical and cultural debt, specifically around the platform aspect of our native
codebase. There are a few levers we can use to fix some of these issues:</p>

<ul>
<li>Let iOS be a bit more webby, by using more JavaScript instead of enforcing stricter platform standards.</li>
<li>Use more of the React Native community’s infra-structure, we generally don't use React Native JavaScript
dependencies. These dependencies usually are cross-platform on Android and iOS which tends to mean making
compromises per-platform. Often we are forcing ourselves into extra work to ensure platform consistency.</li>
<li>Find a way to ensure clearer engineering and product ownership for iOS at Artsy.</li>
<li>Hire more iOS infrastructure engineers to allow for a better mix of native infra vs JavaScript product engineers.</li>
</ul>


<p>How and if we'll tweak these levers will make for an interesting retrospective. Till then, I'd like to finish with
a showcase of some of the React Native work we shipped over the course of the last 4 months:</p>

<p></article>
<a href='/images/react-native-3/rn_3_1.jpg' style="">
  <img src="/images/react-native-3/rn_3_1.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p></article>
<a href='/images/react-native-3/rn_3_2.jpg' style="">
  <img src="/images/react-native-3/rn_3_2.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p>We wouldn't have been able to ship this without React Native.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automation Encourages More Automation]]></title>
    <link href="http://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation/"/>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation</id>
    <content type="html"><![CDATA[<p>Last year, <a href="http://artsy.github.io/blog/2018/05/07/fully-automated-standups/">I wrote about the process of fully automating our weekly engineering-wide standup</a>. One of
the benefits of automating what <em>was</em> a meeting run by a single person to a meeting run by everyone is that we
removed a <a href="https://en.wikipedia.org/wiki/Single_point_of_failure">single point of failure</a>. However, I may have fibbed just slightly when I called our standups
<em>fully</em> automated.</p>

<p>This blog post is going to cover how (and more importantly, <em>why</em>) I finally automated the last 5% of our weekly
standups. Let's go!</p>

<!-- more -->


<hr />

<p>Our weekly standup process is a finely tuned machine. The meeting is run every Monday morning by a different pair
of engineers, based on our <a href="http://artsy.github.io/blog/2018/05/25/support-process/">on-call rotation</a>. The process is <a href="https://github.com/artsy/README/blob/eb2f23c835983223877a6031475153db93e98e8c/events/open-standup.md">documented</a> in the open, and we
improve it over time. I'm really proud of it! But there's just one problem... someone needs to make sure that the
people responsible for the meeting <em>know</em> about that responsibility.</p>

<p>So for the past 8 months, I've begun every week by sending Slack DMs to the responsible engineers to remind them to
run the standup, including a link to the docs. This made me a single point of failure: when I was out of the
office, I always made sure to ask someone else to remind them about the meeting. What if I had forgot? Or I was
sick that day? What would happen to our finely-tuned machine?!</p>

<p>Okay, so what would probably happen is that people would remember anyway or someone would post to Slack "hey who is
running standup today?" Automating this reminder was a pretty small priority, but it was a gap in our process, and
I wanted to patch it.</p>

<p>When I discussed all of this with my colleagues, it wasn't long before someone brought up <a href="https://xkcd.com/1319/">the xkcd comic on
automation</a>. Oh, you know the one.</p>

<p><a href="https://xkcd.com/1319/"><center><img src="https://imgs.xkcd.com/comics/automation.png" srcset="//imgs.xkcd.com/comics/automation_2x.png 2x" alt="xkcd comic about automation" title="I wonder if people would read the hover text of an xkcd comic linked to from a different site, just out of habit? I probably would." /></center></a></p>

<p>The comic observes that, often, the work necessary to automate a task often exceeds the amount of work necessary to
just do the task manually. Pretty funny! You could be forgiven for taking the logical leap to say that automating
tasks isn't worth it, generally, based on this observation. But that analysis would be incomplete because it
focuses entirely on saving <em>time</em>. In my experience, automating a task often yields far more value than it costs in
time.</p>

<p>Let's take the task of sending the on-call engineers their Monday morning standup reminder. How would we even
automate that?</p>

<p>Well, first I think about how <em>I</em> do this task. First I look at the on-call schedule, shared in Google Calendar.
Then I open a DM in Slack with the engineers. I copy the pre-composed message from my recurring OmniFocus task and
send it in the DM.</p>

<p>Okay so how would I automate that? <a href="http://artsy.github.io/blog/2017/09/04/Introducing-Peril/">Artsy uses Peril already</a> to automate reminders about open RFCs, so I
piggy-backed on that existing automation. This is key: I'm not starting from scratch, I'm building upon the
existing automation infrastructure that we've already built.</p>

<p>Next, I find out how to access the Google Calendar API using a <a href="https://cloud.google.com/iam/docs/understanding-service-accounts">Google Services Account</a>. It has an
authentication method purpose-built for server-to-server communication, which is perfect for our needs. I write
some code to pick the correct calendar events based on the current time, extract the email addresses of those
events' attendees, and handle an edge case. Then I look up the <a href="https://github.com/slackapi/node-slack-sdk#features">Slack API</a> for Peril's platform, learn how
to authenticate with it properly from a server, and lookup Slack user IDs based on those email addresses. Finally,
compose the message and use some previously written code to post it to our #dev channel.</p>

<p>Boom. <a href="https://github.com/artsy/peril-settings/pull/87">Open a PR</a>. Add some unit tests. Done.</p>

<p><img alt="screenshot of the peril task working in Slack" src="/images/2019-01-08-automation-encourages-more-automation/success.png"  /></p>

<p>I spent about four hours automating this and by my calculations, I'll recoup that time by... July 2020. But like I
said, there's more value to this than the time I saved.</p>

<p>In the process of automating this, I learned how to use <em>two</em> new APIs <em>and</em> I created infrastructure in our <a href="https://github.com/artsy/peril-settings">Peril
installation</a> to access them. Not only did I build <em>upon</em> the existing automation framework,
but I <em>contributed</em> to it so it's easier for the next person. I even <a href="https://github.com/danger/peril/pull/407">fixed a Peril bug</a> in the process.</p>

<p>Automation encourages automation. Every time you automate a task, it gets easier to automate the next one. With
sufficient infrastructure, a sort of exponential takeoff happens: all of a sudden you're not just automating
<em>existing</em> tasks, you're using that infrastructure for <em>new</em> tasks. Tasks that add value to your team, like
<a href="https://github.com/artsy/peril-settings/blob/master/org/mergeOnGreen.ts">merge-on-green</a> or <a href="https://github.com/artsy/peril-settings/blob/master/tasks/compareSchemas.ts">notifying engineers of recent API changes</a>.</p>

<p>As a consequence of the nature of engineering, we often consider ideas in only terms of constraints. We define
what's possible by what we can already accomplish. Automation is a way to hack around that habit; it encourages
engineers to think outside the box by giving us a larger box. Simple, but effective!</p>

<hr />

<p>So. Four hours of work. Was it worth it?</p>

<p>Well, let's evaluate this in terms of <em>impact</em>. Those four hours could have kept our standups running until next
July, or they could have automated that task <em>and</em> further enhanced our automation infrastructure. And, personally,
it was very satisfying.</p>

<p>I would say that's <em>definitely</em> worth it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[It's time to use Swift Package Manager]]></title>
    <link href="http://artsy.github.io/blog/2019/01/05/its-time-to-use-spm/"/>
    <updated>2019-01-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/05/its-time-to-use-spm</id>
    <content type="html"><![CDATA[<p>It's been three years, and <a href="https://swift.org/package-manager/">Swift Package Manager</a> (SPM) is at a point where it can be useful for iOS
projects. It'll take a bit of sacrifice and a little bit of community spirit to fix some holes probably but <strong>in my
opinion, it's time for teams to start adopting SPM for their 3rd party dev tools</strong>.</p>

<p><strong>TLDR:</strong> You should be using SPM for 3rd party dev tools like: <a href="https://github.com/realm/SwiftLint">SwiftLint</a>, <a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat</a>, <a href="https://danger.systems/swift/">Danger</a>,
<a href="https://github.com/krzysztofzablocki/Sourcery">Sourcery</a>, <a href="https://github.com/SwiftGen/SwiftGen/">SwiftGen</a> and <a href="https://github.com/orta/Komondor">Git Hook management</a>.</p>

<p>This post covers: What made it feasible to use SPM now? What are the downsides of the status quo? Why use SPM at
all? What are the downsides to using SPM?</p>

<!-- more -->


<a name="What.changed.to.make.SPM.usable."></a>
<h3>What changed to make SPM usable?</h3>

<p>From my perspective, David Hart's <a href="https://github.com/apple/swift-package-manager/pull/1187">addition of <code>swift run</code></a> to SPM which shipped with Swift 4.0 is what
pushed the project over the finish line to being useful for iOS developers. <code>swift run</code> is contextually the same as
<code>bundle exec</code> in that it will run a locally bundled version of your executable.</p>

<p>This means you can run <code>swift run swiftlint</code> and reliably get the same results as your CI and fellow developers.</p>

<p>Second, all of the big third party tools support SPM already. So, you probably don't need to send any upstream PRs.</p>

<a name="What.are.the.downsides.of.the.status.quo"></a>
<h3>What are the downsides of the status quo</h3>

<p><strong>Using Homebrew</strong></p>

<p>Right now, a lot of folks use <a href="https://brew.sh">homebrew</a> to manage these types of dependencies. Homebrew is useful for rarely
updated tools (like unix-y CLI apps) but it does not handle having different versions of tool available. This is a
totally reasonable call from Homebrew's perspective but it makes homebrew a bad choice for your <strong>project</strong>
dependencies - because it only installs things globally.</p>

<p>This means a developer (or your CI) would get the most recent version of that tool when they last installed the
tool. This isn't a problem for many projects (for example, check out their <a href="https://formulae.brew.sh/analytics/install/90d/">most installed</a> formulas to
see that it's lot of system libraries, languages and global tools like <code>node</code>, <code>git</code> and <code>python</code>)</p>

<p><strong>Using CocoaPods</strong></p>

<p>You can hijack CocoaPod's dependency resolver, and locking system mixed with consistent dependency paths to handle
your tools. This is better than using Homebrew, because everyone has the same version - and so you could reliably
run SwiftLint via <code>./Pods/SwiftLint/swiftlint</code>.</p>

<p>This is a great hack, and CocoaPods is smart here - because these dependencies don't ship any code for your app for
compiling it won't set up a library or framework for you. You can even use CocoaPods to set up <a href="https://guides.cocoapods.org/syntax/podfile.html#script_phase">a build
phase</a> for you too (I have feelings on this but we'll get to those later.)</p>

<p>I don't really have much of a "you shouldn't do this" for using hacking CocoaPods for your tools, outside of SPM
it's probably the right way to do it.</p>

<a name="Why.Use.SwiftPM."></a>
<h3>Why Use SwiftPM?</h3>

<ol>
<li>SPM works</li>
<li>SPM can lock your dependencies correctly. <code>:tada:</code></li>
<li>The primary tools used in our ecosystem already support it, so you don't need to do any extra work</li>
<li>Easy to cache (everything lives in <code>.build</code>) which means fast CI builds</li>
<li>You're using Swift's tools to manage tools built in Swift, promoting and encouraging the ecosystem you want to
thrive</li>
<li>Your team can get used to how SPM works now, because it should be useful for code dependencies some day</li>
<li>SPM is still in a pretty early phase for usage like this, maybe you can find features to add once you've got
started and contribute back</li>
</ol>


<a name="What.are.the.downsides."></a>
<h3>What are the downsides?</h3>

<ol>
<li><p>Running a tool will compile it the first time you use <code>swift run</code>. Running <code>swift run danger-swift</code> would first
build <code>danger-swift</code> from source and then it would run the executable.</p></li>
<li><p>SPM's dependency resolution step is very naive, and will clone all the dependencies in the tree - even if you
don't need them. So, the dependencies of your dependencies (a.k.a transitive dependencies) will have full clones
locally - e.g. the test runner for SwiftLint has to be fully cloned locally in <code>.build</code> if you use SPM for
SwiftLint. I'm hoping <a href="https://github.com/apple/swift-package-manager/pull/1918">this PR</a> and subsequent
improvements will fix this.</p></li>
<li><p>You need to reference a single Swift file in your project to make this work. SPM today does not support a
dependencies only project (it won't build), so you'll need to reference one Swift file in your codebase.</p></li>
</ol>


<p>All of these are fixable, and the first two can be worked around on CI, by caching the <code>.build</code> directory. Locally
these actions normally only happens once when you install, or update.</p>

<a name="Show.me.it.in.action"></a>
<h3>Show me it in action</h3>

<p>What would this look like for a project? IMO, for a reasonably complex Swift app, I think you should have:</p>

<ul>
<li><a href="https://github.com/realm/SwiftLint">SwiftLint</a> for catching potential code issues</li>
<li><a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat</a> so you don't argue about code style</li>
<li><a href="https://github.com/orta/Komondor">Komondor</a> to automate the above tools, so people don't have to remember to run the tools</li>
<li><a href="https://danger.systems/swift/">Danger Swift</a> to handle cultural rules for PRs like "Please add Changelogs entries"</li>
</ul>


<p>You would write a <code>Package.swift</code> file like this:</p>

<pre><code class="swift">// swift-tools-version:4.2
import PackageDescription

let package = Package(
    name: "Eigen",
    dependencies: [
      .package(url: "https://github.com/danger/swift.git", from: "1.0.0"),
      .package(url: "https://github.com/nicklockwood/SwiftFormat", from: "0.35.8"),
      .package(url: "https://github.com/Realm/SwiftLint", from: "0.28.1"),
      .package(url: "https://github.com/orta/Komondor", from: "1.0.0"),
    ],
    targets: [
        // This is just an arbitrary Swift file in the app, that has
        // no dependencies outside of Foundation, the dependencies section
        .target(name: "eigen", dependencies: ["Danger"], path: "Artsy", sources: ["Stringify.swift"]),
    ]
)

// The settings for the git hooks for our repo
#if canImport(PackageConfig)
    import PackageConfig

    let config = PackageConfig([
        "komondor": [
            // When someone has run `git commit`, first run
            // run SwiftFormat and the auto-correcter for SwiftLint
            "pre-commit": [
                "swift run swiftformat .",
                "swift run swiftlint autocorrect --path Artsy/",
                "git add .",
            ],
        ]
    ])
#endif
</code></pre>

<p>Which gives you access to the following commands:</p>

<ul>
<li><code>swift run komondor install</code> - to set up your repo's git hooks</li>
<li><code>swift run swiftformat .</code> - to run SwiftFormat over your project</li>
<li><code>swift run swiftlint --autocorrect</code> - to highlight your linter issues</li>
<li><code>swift run danger-swift ci</code> - to run Danger Swift on your CI</li>
</ul>


<p>Because you can reliably run both SwiftFormat and SwiftLint via Komondor on a git hook, you can remove build phase
steps that run these tools.</p>

<p>An iOS app's compile and run cycle already takes on the order of seconds, so you should avoid adding extra build
steps in Xcode. I realise that people are only doing this due to the (unreasonably) limited extension support in
Xcode, but the build steps are critical path code. When your build and run cycle is already on the order of many
seconds that iteration cycle has to be as tight as possible.</p>

<p>This setup gives you version-locked access to common linting/formating tools (with the ability to use komondor to
add extra checks if needed) in a self-contained <code>Package.swift</code>.</p>

<p>We've started migrating our Artsy projects to use this setup when we work on our native codebases. With our main
iOS app Eigen already using this pattern for Danger Swift, but we don't created/modify enough <code>*.swift</code> files to
warrant linters/formatters yet.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keeping Artsy's dependencies up to date]]></title>
    <link href="http://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated/"/>
    <updated>2018-11-26T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated</id>
    <content type="html"><![CDATA[<p>Hey everyone! I'm Justin, a senior engineer here at Artsy. I've been here for about 6 months and I'm a bit overdue
on my first blog post. This will be one of a series of posts I'm dubbing <em>roads and bridges</em> (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">thanks Orta</a>)
describing infrastructure and tooling work here at Artsy.</p>

<a name="Backstory"></a>
<h3>Backstory</h3>

<p>Here at Artsy we have a lot of internal dependencies. Keeping these dependencies up to date across all of our
projects can be a bit of a headache. For example, there's <a href="https://github.com/artsy/palette">Palette</a> (our <a href="https://www.uxpin.com/studio/blog/design-systems-vs-pattern-libraries-vs-style-guides-whats-difference/">design system</a>)
which is consumed by <a href="https://github.com/artsy/reaction">Reaction</a> (our react component/app library), <a href="https://github.com/artsy/emission">Emission</a> (our React Native
application), <a href="https://github.com/artsy/force">Force</a> (our main site), and <a href="https://github.com/artsy/positron">Positron</a> (our editorial creation tool). That's not
even an exhaustive list. As you can imagine, after making an update to <a href="https://github.com/artsy/palette">Palette</a> we have to make a lot of
Pull Requests to get everything synced up across our many projects. And that's just <em>one</em> dependency.</p>

<!-- more -->


<a name="Evaluating.the.problem"></a>
<h3>Evaluating the problem</h3>

<p>There are a few services out there that connect to GitHub and helps you keep your dependencies up to date. I'd
personally used <a href="https://greenkeeper.io/">Greenkeeper</a> in the past and it seemed to work fairly well for my uses. I'd also
heard about <a href="https://renovatebot.com/">Renovate</a> which is another option that actually supports more package managers than just
yarn/npm. Great! Plenty to evaluate here. Anytime I'm evaluating a new service there are a few questions I ask
myself upfront to help a good decision:</p>

<ol>
<li>What are my exact needs</li>
<li>Can this solution scale to meet future needs</li>
</ol>


<p>The first point is straight-forward, but there's a little twist. We have a <em>lot</em> of dependencies. If we got PRs for
all of them we'd be pretty much unable to do anything. In this case we wanted to specifically limit it to packages
that are published by Artsy (on the <code>@artsy</code> npm namespace).</p>

<p>The second you have to be a bit careful with. Don't try to project too far or you'll end up choosing a solution far
too complex for your current needs. In this case, I wanted something that we could selectively extend in the future
to cover other dependencies. Things like <code>react</code> and <code>react-dom</code> or <code>typescript</code>. Incremental increases without a
ton of noise.</p>

<a name="Picking.a.solution"></a>
<h3>Picking a solution</h3>

<p>First things first... we have to have a solution that can update only Artsy's dependencies. I started digging
through <a href="https://greenkeeper.io/">Greenkeeper</a>'s docs and found a reference to an <a href="https://greenkeeper.io/docs.html#ignoring-dependencies">ignore</a> option.
Essentially any package that you don't want <a href="https://greenkeeper.io/">GreenKeeper</a> to automatically update you can put in this
ignore list. That's not really doable in our usecase because we want to ignore everything but a small subset of
packages.</p>

<p>Checking out <a href="https://renovatebot.com/">Renovate</a>'s docs I found a more promising option:
<a href="https://renovatebot.com/docs/configuration-options/#excludepackagepatterns">excludePackagePatterns</a>. All I really want to do is include Artsy packages, but this sounded
like I could do the inverse by excluding all non-Artsy packages. Being as it had that option, supported more
package managers, and had a more friendly pricing scheme than <a href="https://greenkeeper.io/">Greenkeeper</a> I decided to give
<a href="https://renovatebot.com/">Renovate</a> a shot.</p>

<a name="Making.it.happen"></a>
<h3>Making it happen</h3>

<p>I began by enabling <a href="https://renovatebot.com/">Renovate</a> on <a href="https://github.com/artsy/force">Force</a>. You can see the PR <a href="https://github.com/artsy/force/pull/3086">here</a>.
<a href="https://renovatebot.com/">Renovate</a> has a <em>really</em> excellent on-boarding experience. It first creates a PR that adds its own
configuration. It shows you what packages will be updated based on that configuration. As you update the config,
Renovate will update the PR body to show you the results of your changes. This gives you the opportunity to update
the configuration before it officially activates. If you click the edited dropdown on the PR body you'll see all
the changes Renovate made to the issue while I was trying to figure out the configuration.</p>

<p><img src="/images/2018-11-26-keeping-dependencies-updated/issue-history.png" alt="GitHub PR edit history" /></p>

<p>It took me a while to figure everything out, just take a look at the <a href="https://github.com/artsy/force/pull/3086/commits">commit history</a>. I'm going to
work through the final setup just to give you an idea of our setup.</p>

<p>First, I extended <a href="https://renovatebot.com/">Renovate</a>'s base config.</p>

<pre><code>{
  "extends": [
    "config:base"
  ],
  ...
}
</code></pre>

<p>If you've worked with <a href="https://eslint.org">eslint</a>, <a href="https://babeljs.io/docs/en/options#extends">babel</a>, or other tools in the js ecosystem, you've probably
seen this type of configuration extension. It essentially allows us to use their best practices out of the box.
Check out their <a href="https://github.com/renovatebot/presets/blob/ef6a6e2e6d3e6ba25239d57d808b0e4dc64f32a3/packages/renovate-config-config/package.json#L19-L34">presets repo</a> if you want to know what it adds specifically.</p>

<p>Next, I set the <a href="https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/">assignees</a>. When <a href="https://renovatebot.com/">Renovate</a> opens a new PR, it'll assign it to these people
so that the PR doesn't get missed.</p>

<p>The actual meat of the change is the <code>packageRules</code> setup.</p>

<pre><code>{
  ...
  "packageRules": [{
    "packagePatterns": ["*"],
    "excludePackagePatterns": ["^@artsy"],
    "enabled": false
  }],
  ...
}
</code></pre>

<p><a href="https://renovatebot.com/">Renovate</a> allows you to set up multiple different <code>packageRules</code> and there's a lot of configuration for
them. I'm not going to go through more than I did, but feel free to read more in their
<a href="https://renovatebot.com/docs/configuration-options/#packagerules">docs</a>. In the <code>packageRule</code> that I setup, I specified <code>packagePatterns</code> with an
asterisk to select all dependencies. Then using <code>excludePackagePatteners</code> I excluded anything that started with
<code>@artsy</code>. Finally (and most importantly), I set <code>enabled</code> to <code>false</code> to disable the dependencies matching those
combinations of rules. That last part took me a while to figure out. When you're building package rules in
<a href="https://renovatebot.com/">Renovate</a>, think of it as building out a list of operations to perform.</p>

<p>The last few pieces of config are a little more straight-forward and you can read about those in the docs. The one
thing that I'll mention is that <a href="https://renovatebot.com/docs/configuration-options/#vulnerabilityalerts">vulnerabilityAlerts</a> <em>ignores</em> <code>packageRules</code> and
triggers update PRs for anything that's reported to have a vulnerability. You'll have to explicitly disable it if
you only want reports on certain packages. Though, having it on probably isn't a bad idea...</p>

<a name="Wrapping.up"></a>
<h3>Wrapping up</h3>

<p>So, that's how we configured <a href="https://renovatebot.com/">Renovate</a> to automatically update npm dependencies in Artsy's namespace.
It's been extremely useful already. I also went ahead and pulled our configuration out into a <a href="https://github.com/artsy/renovate-config">shared
repo</a> so that we didn't have to copy these configurations across all of our projects. That's
a blog post for another day.</p>

<p>Be well friends.</p>

<!-- prettier-ignore -->


<!-- prettier-ignore -->


<!-- prettier-ignore -->

]]></content>
  </entry>
  
</feed>
