<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-06-30T13:42:53+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Spelunking: Injection for Xcode Plugin]]></title>
    <link href="http://artsy.github.io/blog/2016/06/29/code-spelunking-injection/"/>
    <updated>2016-06-29T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/29/code-spelunking-injection</id>
    <content type="html"><![CDATA[<p>It was only three months ago that I came to the conclusion of just how much time I had wasted <a href="http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection/">on code compilation cycles</a>, once I started to play with <a href="https://github.com/johnno1962/injectionforxcode">Injection for Xcode</a>. I still feel guilt about the time I wasted. However, I'm trying to turn that into something constructive. In order to do that, I need to have a solid understanding of the fundamentals on how Injection For Xcode works.</p>

<p><a href="https://ashfurrow.com/">Ash</a> says one of the best ways to <a href="https://ashfurrow.com/blog/teaching-learning/">learn is to teach</a>. So I'm going to try take you through a guided tour of the code-base. You need some pretty reasonable Objective-C chops to get this, but anyone with an app or two under their belt should be able to <a href="https://en.wikipedia.org/wiki/Grok">grok</a> it.</p>

<!-- more -->


<p><img src="/images/2016-06-29-injection-overview/overview.png" alt="Xcode Project Overview" /></p>

<p>You might find it easier to clone the repo and have Xcode open along-side this article, to quickly do that, run these commands to put it in a temporary folder via the terminal:</p>

<pre><code class="sh">cd /tmp/
git clone https://github.com/johnno1962/injectionforxcode TempInjection
open TempInjection/InjectionPluginLite/InjectionPlugin.xcodeproj/
</code></pre>

<h2>A note on code style</h2>

<p>I am of the _why <a href="https://www.smashingmagazine.com/2010/05/why-a-tale-of-a-post-modern-genius/#dont-be-afraid-to-take-risks">camp of programming</a> - the code we are spelunking through can feel foreign to modern Objective-C, and it's not got tests. <a href="https://github.com/johnno1962/">@Johno1962</a> described it to me as being like 1997's Objective-C. The end result of all this code <em>is</em> beautiful, whether the code is - is a matter of perspective. I'm super happy it exists.</p>

<h2>Targets</h2>

<ul>
<li>InjectionPlugin - The user facing Xcode plugin</li>
<li>InjectionLoader - A Bundle used to skip patching a project for injection.</li>
<li>iOSBundleTemplate - A folder to a reference implementation of a iOS Project</li>
<li>OSXBundleTemplate - Same but for OSX Project</li>
<li>unhide - A command line tool that extracts symbols from a Swift Framework</li>
</ul>


<h2>Implementation Order</h2>

<p>I want to go through the code-base from the perspective what happens when it:</p>

<ul>
<li>Loads up inside Xcode.</li>
<li>Recieves a call to inject.</li>
</ul>


<h3>Launch</h3>

<p>All Xcode plugins have the exact same launch process, you <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Info.plist#L21-L22">define a class</a> in the info.plist, this class, <code>INPluginMenuController</code>, gets <code>+ pluginDidLoad:</code> called. This is where you <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L83-L94">set up a shared instance</a>, and can keep a reference to your bundle.</p>

<p>This triggers the interesting stuff in <code>applicationDidFinishLaunching:</code> this sets up the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L131-L137">user interface from a nib file</a>, which <a href="http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/">DIs</a> in a lot of the instance variables, and will send you to get a new version of Injection if it fails. It then sets up the menu ( note: <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L151-L154">interesting use of c-structs here</a> ) and starts a TCP server, then registers for when a <code>NSWindow</code> becomes active.</p>

<h4>Server</h4>

<p>The server is a <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L512-L535">c TCP socket</a>, prior to digging in here, I'd never needed to see one. I see a lot of references to Android injection, so I assume the low-level choice in a socket  was so the same code can do both platforms.</p>

<pre><code class="c">- (void)startServer {
    struct sockaddr_in serverAddr;

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(INJECTION_PORT);

    int optval = 1;
    if ( (serverSocket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0 )
        [self error:@"Could not open service socket: %s", strerror( errno )];
    [...] // skipping a bunch of error handling
    else if ( listen( serverSocket, 5 ) &lt; 0 )
        [self error:@"Service socket would not listen: %s", strerror( errno )];
    else
        [self performSelectorInBackground:@selector(backgroundConnectionService) withObject:nil];
}
</code></pre>

<p>Assuming everything went well, then a <a href="https://en.wikipedia.org/wiki/Bonjour_%28software%29">Bonjour</a> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L539-L542">service</a> is created advertising the socket on the network. This then moves to a background thread and starts a infinite runloop checking for new connections on the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L545-L557">socket every 0.5 seconds</a>.</p>

<p>Here is it <a href="/images/2016-06-29-injection-overview/selected_bonjour.png">running</a> in <a href="http://tildesoft.com">Bonjour Browser</a>. So, what does this server do? That's handled inside <code>INPluginClientController</code>. It uses a MAC address so that you can have multiple non-competing services running on the same network.</p>

<p>At its simplest, the server exists to send messages between running multiple applications and the injection plugin. We'll get back to what the server does later.</p>

<h4>Inside Xcode</h4>

<p>The plugin will keep track of the key editor window, <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L214-L220">this is done</a> by making sure the window's controller is of the class <code>IDEWorkspaceWindowController</code> and that it has a corresponding file.</p>

<p>That's basically everything set up for the plugin now, until a user decides to start using Injection. So we're going to move to what happens when you press <code>ctrl + =</code>.</p>

<h4>On Preparing for Injection</h4>

<p>The work starts at <code>injectSource</code> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L359">from INPluginMenuController</a>.</p>

<p>The first thing it does is grab the current file, then saves it. It then checks what type of file it is, as only <code>.m, .mm, .swift or .storyboard</code> can be injected.</p>

<p>Next, it pulls out a reference to the currently running LLDB session, the console in the bottom of Xcode. It checks if the server has any active clients.</p>

<p>OK, to understand the next bit you need to understand what <em>"unpatched injection"</em> is. In order to support code injection, your app has to have some way to communicate back to the TCP server hosted in Xcode. This can be done either by <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/documentation/patching_injection.md">including some source code</a> in your project, or by adding it in at runtime. Including the source code, is "patching" your project to allow injection. It's optional because of what comes next.</p>

<p>If there are no clients connected, then requests a pause from LLDB, allowing the plugin to send messages to the running app, it then waits a few microseconds to give the debugger chance to load. Once it's loaded <code>loadBundle:</code> is <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L404-L415">called</a>.</p>

<p>Injection then sends <code>expr -l objc++ -O -- (void)[[NSClassFromString(@"NSBundle")  bundleWithPath:@"/Users/orta/Library/Application Support/Developer/Shared/Xcode/Plug-ins/InjectionPlugin.xcplugin/Contents/Resources/InjectionLoader.bundle"] load]</code> into the debugger. Causing the same code as the patch to exist inside your app.  This code comes from the second target from the list at the top, and is hosted inside the plugin's bundle (meta...).</p>

<p>With that verified, it's ready to inject the source code.</p>

<h4>Code Injection Compilation</h4>

<p>If everything is good, and ready to go, and we've got confirmation that a client exists, Injection starts monitoring for file changes inside your Xcodeproject.</p>

<p>A lot of the code injection work is done inside perl scripts, another new language for me. OK, so, at the end of <code>injectSource</code> it runs <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl">injectSource.pl</a> with an argument of the file to inject.</p>

<p>Note, a lot of ground-work for the perl scripts is done inside <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/common.pm">common.pm</a> - which is a module the other <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L15">scripts import</a>.</p>

<p>It is the role and responsibility of this script to setup, maintain and amend an xcodeproject that compiles just the class that has changed into a new bundle. Luckily for me this is pretty well documented <code>:D</code>.</p>

<p>It starts out by copying a template xcodeproject (either <code>iOSBundleTemplate</code> or <code>OSXBundleTemplate</code>) into your current project directory. I <a href="https://github.com/artsy/eigen/pull/1236/files#diff-a084b794bc0759e7a6b77810e01874f2R46">add this</a> to the <code>.gitignore</code>.</p>

<p>Next it pulls out the build settings for all these keys <code>FRAMEWORK_SEARCH_PATHS HEADER_SEARCH_PATHS USER_HEADER_SEARCH_PATHS GCC_VERSION ARCHS VALID_ARCHS GCC_PREPROCESSOR_DEFINITIONS GCC_ENABLE_OBJC_EXCEPTIONS</code> from your project, into the sub-project.</p>

<p>Next it determines how to handle code-signing on the app, as it supports both simulator and on-device, and you need to sign to run any code on a device.</p>

<p>After that, if needs to understand how to compile an individual file, it gets a reference to the build log dirs for the <a href="/images/2016-06-29-injection-overview/build_logs.png">derived data</a> for your app. They're zipped files, so it unzips them and parses the log. Here's an example of what <a href="/images/2016-06-29-injection-overview/a_build_log.png">compiling a single class from Eigen looks like</a> (I've highlighted the useful bits). Internally, this is called the learnt db.</p>

<p>The learnt db is used to compile a class to be individually compiled into a <code>injecting_class.o</code> file, I can't quite figure out where that file comes from though.</p>

<p>To wrap up the compilation it needs to take the compiled object <code>injecting_class.o</code> and statically link it to the bundle that is generated inside the sub-project. Here is the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L331-L365">command line generation</a>, building the script is a little bit <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L376-L467">more involved</a> - but that's generally because it's trying to support a lot of user options. The main class that exists in the bundle is <code>BundleContents</code>.</p>

<p>The compiled bundle is then renamed so that you don't have name clashes, it's just incremental integers. My current sub-project I'm using for debugging looks like this:</p>

<p><img src="/images/2016-06-29-injection-overview/injection_subproject.png" alt="Injection Subproject" /></p>

<p>With the <code>Logs</code> dir being a symlink to the derived data folder.</p>

<p>With that done, it will <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L487-L503">include any nibs</a> from compiling storyboards, and <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L505-L512">code-sign the bundle</a> if it's going to a device. Finally it prints out <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L515">the new bundle path</a> in so the monitoring script can work with it.</p>

<h4>Script Monitoring</h4>

<p>The script to create the Xcode project, amend it, and compile is done as a separate process. It's <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L365">done</a> via the <a href="http://linux.die.net/man/3/popen">function</a> <code>popen</code>. This is then monitored in background, <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L382">listening for output lines</a> that begins with <code>&lt;</code>, <code>&gt;</code>, <code>!</code>, <code>%</code> and <code>?</code>. The one that we're most interested in, is the <code>!</code> operator which tells the server the filepath of the now compiled <code>InjectionBundleX.bundle</code>, in my most recent case, this looked like <code>/Users/orta/dev/ios/energy/iOSInjectionProject/build/Debug-iphonesimulator/InjectionBundle4.bundle</code>.</p>

<p>This <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L422-L423">tells the</a> server running inside Xcode that it has a file to send to the clients.</p>

<h4>How the server works</h4>

<p>Alright, back to <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m">the INPluginClientController</a>. Skipping over the option setting <code>IBAction</code>s and <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L129-L185">RTF-formatted logging</a>. We come to the initial connection responder: <code>setConnection:</code>.</p>

<p>So, this is where I ended up a bit out of my comfort zone. This isn't a blog post about sockets and c though, so I'll annotate what's going on from the high level thoughout this <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L189">connection setup function</a>.</p>

<ul>
<li>Grab some the main client file from socket, then if it's is an injection message, set the Injection console's info label to that filepath, this is the <code>BundleContents.m</code>.</li>
<li>Otherwise inject all objects from a storyboard (not too sure whats going on there TBH)</li>
<li>The server <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L216">asks the client</a> for the app's path e.g. <code>/Users/orta/Library/Developer/CoreSimulator/Devices/CDC9D8EF-AAAD-47F8-8D53-C3C69551E85A/data/Containers/Data/Application/1F636180-7113-406E-88F8-7E43EFAC13F6"</code></li>
<li>There's some more communication around the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginClientController.m#L229-L230">app's architecture</a>.</li>
<li>The app gets a <a href="/images/2016-06-29-injection-overview/badge.png">badge</a> with the client count on it, so you know it's working.</li>
<li>If checks if you want the File Watcher turned on.</li>
</ul>


<p>From that point the server's job is mainly to pass messages and files that come out of the scripts between the client and the host doing the compilation.</p>

<h4>File Watcher</h4>

<p>As an option you can set in the preferences toggles a File Watcher. I found a bunch of references to this in the code, so I wanted to at least dig into that. When you turn it on, any save will trigger an injection. This is done by looking for the folder that your <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/INPluginMenuController.m#L432-L436">project resides in</a>, then using Apple's <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/FileWatcher.m#L31">file system event stream</a> to monitor for save changes. Then when a new FS event is triggered, it re-injects that file. I bet it's turned off by default as you'll see errors when it's not compilable.</p>

<h2>Client-Side</h2>

<p>We've hand-waved though the client-side of the app during the patching stage of installation, but to understand both parts of the system we need to cover the client side in a bit more depth. There's two aspects to it, the initial bundle/patch and incremental bundles that contain the new compiled code.</p>

<h4>Client Setup</h4>

<p>To understand this, we need to grok a 1,200 LOC header file <code>:D</code>, it has a few responsibilities though. So we can try work through those, to <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h">BundleInjection.h</a>. Interesting note, when you are patching your application - you're actually making a link to a copy of this file inside your <code>/tmp/</code> dir.</p>

<pre><code class="objc">#ifdef DEBUG
static char _inMainFilePath[] = __FILE__;
static const char *_inIPAddresses[] = {"10.12.1.67", "127.0.0.1", 0};

#define INJECTION_ENABLED
#import "/tmp/injectionforxcode/BundleInjection.h"
#endif
</code></pre>

<h4>Client Socket Connection</h4>

<p>Like the server, this has two responsibilities - using Bonjour to find the server, and raw socket communication. There is nothing unique about the Bonjour mutlicast work, so I'm skipping that. Once the socket knows how to establish a connection between processes <code>+ bundleLoader</code> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L359">is called</a> on a background thread.</p>

<p>So, what does <code>bundleLoad</code> do?</p>

<ul>
<li>It checks if it's a new Injection install in the app, <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L366-L367">if so</a> it sets up <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/documentation/tunable_parameters.md">INParameters and INColors</a> for tunable parameters.</li>
<li>It then determines the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L383-L400">hardware architecture</a> for it to be sent to the server for compilation later.</li>
<li>Attempt to connect to the server, 5 times.</li>
<li>If it succeeds, <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L415">write the location</a> of the <code>BundleInjection</code> file to the server. Triggering the first of the socket work on the server.</li>
<li>Expect a response of the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L417">server's</a> version of <code>BundleInjection</code></li>
<li>If the bundle is compiling storyboards on iOS, <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L424-L429">swizzle some</a> of the UINib init functions.</li>
<li>Pass the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L443">home directory of the app</a> to the server.</li>
</ul>


<p>From there the socket goes into runloop mode on it's on thread.</p>

<h4>Client Socket Runloop</h4>

<p>As with server monitoring, the client listens for strings that begin with special prefixes:</p>

<ul>
<li><code>~</code> - Injects, then Re-creates the app degelate + view controller heirarchy.</li>
<li><code>/</code> - <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L644">Loads</a> the bundle path that was sent in.</li>
<li><code>&gt;</code> - Accepts a file or directory to <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L476">be sent through the socket</a>.</li>
<li><code>&lt;</code> - Sends a requested file or directory to <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L492">through the socket</a>.</li>
<li><code>#</code> - <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L540">Receives</a> an <code>NS/UIImage</code> via NSData for Tunable Parameters.</li>
<li><code>!</code> - Logs to console</li>
<li>Otherwise, assume it's another Tunable Parameter.</li>
</ul>


<h4>Loading the Bundle</h4>

<p>When the new bundle is loaded <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L303-L308">it triggers</a> this code:</p>

<pre><code class="objc">+ (void)load {
    Class bundleInjection = NSClassFromString(@"BundleInjection");
    [bundleInjection autoLoadedNotify:$flags hook:(void *)injectionHook];
}
</code></pre>

<p>Which does the job of letting the running app know that instances have been updated with new code. Injection does three things:</p>

<ul>
<li>A global NSNotification for .</li>
<li>Sends all instances of classes injected a message that they've been injected.</li>
<li>Sends all classes that have been injected a message they've been injected.</li>
</ul>


<p>Which is where this goes from "complex", to "I would need to study up to do this." Let's start of quoting the README that <a href="https://github.com/johnno1962/">@Johno1962</a> and I worked on for a while.</p>

<blockquote><p>It can be tough to look through all of the memory of a running application. In order to determine the classes and instances to call the injected callbacks on, Injection performs a "sweep" to find all objects in memory. Roughly, this involves looking at an object, then recursively looking through objects which it refers to. For example, the object's instance variables and properties.</p>

<p>This process is seeded using the application's delegate and all windows. Once all the in-memory reference are collected, Injection will then filter these references to ones that it has compiled and injected. Then sending them the messages referenced in the callbacks section.</p>

<p>If no references are found, Injection will look through all objects that are referred to via sharedInstance. If that fails, well, Injection couldn't find your instance. This is one way in which you may miss callbacks in your app.</p></blockquote>

<h4>Class + Method Injections</h4>

<p>So how does it pull that off? Calling <code>NSBundle</code>'s <code>- load</code> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L648">here</a>, calls the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/instm/NSBundle/load">load function to call on all classes</a> inside that new bundle. This triggers the load function from the <code>InjectionBundle</code> that is auto-generated during the Injection stage. Here's what one of mine looks like:</p>

<pre><code class="objc">@interface InjectionBundle3 : NSObject
@end
@implementation InjectionBundle3

+ (void)load {
    Class bundleInjection = NSClassFromString(@"BundleInjection");
    [bundleInjection autoLoadedNotify:0 hook:(void *)injectionHook];
}

@end
</code></pre>

<p>This is generated from the <code>injectSource.pl</code> script <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/injectSource.pl#L311-L315">here</a>] <code>[bundleInjection autoLoadedNotify:$flags hook:(void *)injectionHook];</code> . It also comes with another function,</p>

<pre><code class="c">int injectionHook() {
    NSLog( \@"injectionHook():" );
    [InjectionBundle3 load];
    return YES;
}
</code></pre>

<p>What we care about is <code>&amp;injectionHook</code> which gets passed to <code>autoLoadedNotify</code> as a pointer to a function. Oddly enough, I'm a tad confused about the fact that the injection hook contains a reference to the function that calls it, but lets roll with it for now. Perhaps it's never actually called, <em>I asked</em> -it's for Android support, and isn't used.</p>

<p>So, we've had a fairly typical <code>NSBundle</code> <code>- load</code> load our classes into the runtime. This triggered the <code>InjectionBundle.bundle</code> to have it's classes created, and the first thing it does is pass a reference back to the <code>BundleInjection</code> class instance for the <code>injectionHook</code> function that calls the <code>load</code> on the new classes.</p>

<p><em>Note:</em> terminology changes here, I've talked about a bundle, but now that the code is in the runtime, we start talking about it as a dynamic library. These bundles contain 2 files <code>Info.plist</code>, <code>InjectionBundleX</code> - so when I say dynamic library, I'm referring to the code that is inside the bundle that is linked ar runtime (and thus dynamically linked in.)</p>

<p>Next, Injection creates a <a href="https://github.com/davetroy/astmanproxy/blob/f4b952a717b7e982b585bf0daa86398add394a88/src/include/dlfcn-compat.h#L44-L54">dynamic library info</a> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L944-L946">struct</a> and uses <a href="http://linux.die.net/man/3/dladdr">dladdr</a> to fill the struct, based on the function pointer. This lets Injection know where in memory the library exists. It's now safe in the knowledge that the code has been injected into the runtime. Injection will re-create the app structure, if requested - like when it receives a socket event of <code>~</code>.</p>

<p>We're getting into Mach-O binary APIs, so put on your crash helmets. Injection is going to use the dynamic library info, and <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L959-L981">ask for the Objective-C</a> <code>__classlist</code> via <a href="http://www.manpagez.com/man/3/getsectdatafromheader/">getsectdatafromheader</a> for the new dynamic library. This works fine for Swift too, it <em>mostly</em> has to be exposed to the Objective-C runtime. If you want to understand more about what this looks like, read <a href="https://blog.zynamics.com/2010/07/02/objective-c-reversing-ii/">this blog post</a> from <a href="https://zynamics.com">Zynamics</a>. Injection then loops through the classes inside the library, via the most <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L988">intensely casted</a> line in of code in here: <code>Class *classReferences = (Class *)(void *)((char *)info.dli_fbase+(uint64_t)referencesSection);</code>.</p>

<p>These classes are then iterated though, and <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L836-L845">new implementations of functions are swizzled</a> to reference the new implementations. With Swift you have no guarantee that the methods are <code>dynamic</code> so all their <code>vtable</code> <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L847-L855">data is switched</a>. If you don't know what a vtable is check this <a href="https://en.wikipedia.org/wiki/Virtual_method_table">page on Wikipedia</a>.</p>

<p>Once all of the classes have had their methods switched, the <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L911-L937">class table is updated</a> to ensure that functions that rely on the class table ( e.g. <code>NSClassFromSelector</code> ) return the new values.</p>

<p>With valid class tables, and the newly injected functions added. Injection starts the memory sweep to send updated notifications.</p>

<h4>Class + Instance Notifications</h4>

<p>At <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L1028">this point</a> Injected does a run through the new class list again, if that class responds to the selector <code>+ injected</code> it runs it. It then does a check to see if the class's instances reponds to <code>- injected</code> if it does, it looks to see if it has any instances of the objects in it's liveObjects array. If the array hasn't been set up, then it needs to do a full memory sweep.</p>

<p>Injection has an <a href="https://github.com/johnno1962/Xprobe">Xprobe</a>-lite included inside it. This lives in <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h">BundleSweeper.h</a>. The quote opening this notification section above gave the start away, BundleSweeper <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L47">looks at the app delegate</a> ( or a <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L55">Cocos2D director object</a>) and then starts to recursively look at every object that it's related to. This is done by adding a <code>bwseep</code> function to <code>NSObject</code> then individually customizing it for known container classes, and "reference" classes e.g <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L228">NSBlock</a>, <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L221">NSData</a>, NSString, NSValue etc. The <code>bsweep</code> function adds itself to the <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L113-L117">shared list</a> of "objects seen", checks for an it being a <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L119-L124">private class or a transition</a>, if it's not then it loops through the <a href="http://stackoverflow.com/questions/16304483/debug-obtain-a-list-of-all-instance-variables-of-an-object-unknown-type">IvarList</a> and runs <code>bsweep</code> on all of those. With that done, it casually tests to see if there are any weakly held objects that <a href="https://github.com/johnno1962/injectionforxcode/blob/16a9b8e93b458b1c5916e95df06fe8c74cb56862/InjectionPluginLite/Classes/BundleSweeper.h#L148-L160">tend to use common selectors</a>.</p>

<p>Let that simmer for a bit ( I jest, it's super fast. ) and then you have <em>almost</em> every object in your object graph being told that they've been updated. I say almost because of the above caveat. Can't find all objects this way. Singletons that never are referenced strongly from another object inside the findable graph wouldn't get a notification this way for example.</p>

<p>With all the fancy class an instance nofications sorted, there is a good old reliable <code>NSNotification</code> - <a href="https://github.com/johnno1962/injectionforxcode/blob/master/InjectionPluginLite/Classes/BundleInjection.h#L1065">here</a>. Which is what I based my <a href="https://github.com/artsy/eigen/pull/1236">work on for Eigen</a>, super simple, extremely reliable and great for re-use.</p>

<p><img src="https://cloud.githubusercontent.com/assets/49038/13548868/131cbb1e-e2c8-11e5-9f61-4acdfd10b6aa.gif" alt="https://cloud.githubusercontent.com/assets/49038/13548868/131cbb1e-e2c8-11e5-9f61-4acdfd10b6aa.gif" />.</p>

<hr />

<p><strong>Phew!</strong></p>

<p>So, this covered the majority of how Injection for Xcode works. It's a <em>really</em> powerful tool, that can vastly improve your day-to-day programming. When I showed a draft of this post to <a href="https://github.com/johnno1962/">@Johno1962</a> he reminded me that <a href="https://github.com/johnno1962/Diamond">Diamond</a> - his Swift scripting improvement tool, had it's own version of Injector inside that, that is much <a href="https://github.com/johnno1962/Diamond/blob/master/Reloader/Reloader.m">simpler and a easier read</a> at 120 LOC. However, can't understand the future without understanding the past.</p>

<p>A lot of the most complicated code is around:</p>

<ul>
<li>The client-server architecture, and about passing files/folders between the running application and the Xcode plugin.</li>
<li>The recursive memory sweeping required to get a notification that it's done.</li>
</ul>


<p>The actual work involved in <a href="https://github.com/johnno1962/injectionforxcode/blob/2c1696e7301fdcf1d99a8a75be501df7c25d93e8/InjectionPluginLite/Classes/BundleInjection.h#L807-L938">doing the injection, and replacing the classes</a> isn't particularly complicated, and is easy to understand without c/Mach-o domain knowledge. It's making sure the environment is set up and supporting useful features like Storyboards, Android via Apportable, ARC and no-ARC, 32bit vs 64bit and iOS vs Mac where things start to become more complex.</p>

<p>As of Xcode 8, Xcode Plugins are on the way out, though there are hacks to work around the system to install them, doing so might not be the smartest of moves yet. It's hard to see where the future lies here. However,</p>

<p><img src="http://media2.giphy.com/media/VHW0X0GEQQjiU/giphy.gif" alt="Giphy" /></p>

<p>So we'll see in a few months.</p>

<p>If you're interested in this kind of stuff, follow <a href="https://github.com/johnno1962/">@Johno1962</a> on Twitter, he's <a href="https://twitter.com/Injection4Xcode">@Injection4Xcode</a> - Chris Lattner follows him, so you know it's good stuff. He's always got some project that is pushing a boundry or two.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Depedency Injection in Swift]]></title>
    <link href="http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/"/>
    <updated>2016-06-27T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift</id>
    <content type="html"><![CDATA[<p>Dependency Injection (DI) is a <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">$25 word for a 5¢ idea</a>, but it's an idea that has become wholly foundation to how I write software. I want to take a look at some of the ways our team have been using DI in Swift.</p>

<!-- more -->


<p>DI users in Swift (and Objective-C) are generally in one of a few camps:</p>

<ul>
<li>Use <a href="https://www.natashatherobot.com/unit-testing-swift-dependency-injection/">initializer injection</a> to provide objects with their dependencies.</li>
<li>Use property injection (<a href="https://ashfurrow.com/blog/lazy-property-setup-in-swift/">with laziness even!</a>).</li>
<li>Use <a href="https://github.com/Swinject/Swinject">frameworks like Swinject</a> to build dependency graphs at run time.</li>
</ul>


<p>If you've used storybards or nibs before, you have probably already used property injection via IBOutlets. I actually consider initializer injection and property injection to be roughly the equivalent, just with different timing.</p>

<p>If I had to pick a favourite, I like the initializer injection because it fits appropriately with the level of dynamism Swift offers. But Swift is still <em>super</em> young and there're lots of programming techniques to explore, so I've been experimenting with something new.</p>

<p>The idea is similar to initializer injection, where you provide an instance's dependencies, but instead of providing the dependencies directly, you provide closures that return a dependency. It sounds odd, and is best explained using an example that starts without any DI at all.</p>

<p>Okay, we've got a network layer that communicates with an API. We're writing the class that takes the parsed data from the <code>NetworkProvider</code> class and turns it into models consumable by the rest of the app. Right now it looks like this.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init() {
        networkProvider = NetworkProvider("https://api.wherever.com")
    }
}
</code></pre>

<p>There are some limitations to this, specifically around testing it. It would be better to have the <code>networkProvider</code> passed in as an argument to <code>init()</code>. That's initializer injection, and my opposition to it is that we've moved the responsibility for creating the <code>networkProvider</code> up the stack.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(networkProvider: NetworkProvider) {
        self.networkProvider = networkProvider
    }
}

...

let stateManager = StateManager(
    networkProvider: NetworkProvider("https://api.wherever.com")
    )
</code></pre>

<p>The thing is, now some <em>other</em> object has to know how to do create the <code>NetworkProvider</code>. Hrm. You can repeat this process of injecting dependencies from further up the stack until you have a general-purpose DI framework, and that's not my bag.</p>

<p>My approach passes a closure that <em>returns</em> a network provider instead of passing in a <code>networkProvider</code> instance directly. The parameter can be given a default implementation, too.</p>

<pre><code class="swift">class StateManager {
    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: () -&gt; NetworkProvider = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }

    class func defaultNetworkCreator() -&gt; (() -&gt; NetworkProvider) {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<p>There's a lot to unpack here, so let's take it slowly. The initializer has a new <code>networkProviderCreator</code>, a closure that returns a <code>NetworkProvider</code>. In the initializer, we set our property to the return value of the closure. We also have a class method that gives us a default implementation that's used in production.</p>

<p>But in tests, we can initialize the <code>StateManager</code> with a stub closure, something like:</p>

<pre><code class="swift">let fakeNetworkProvider = ...
let testSubject = StateManager({ fakeNetworkProvider })
</code></pre>

<p>Now you get the benefits of initializer injection, but the flexibility to only use DI when you need to.</p>

<p>Note: we should still test the <code>defaultNetworkCreator()</code> function to make sure it works, too. Having code behave differently specifically while being tested is not generally a good idea.</p>

<p>Applying the advice on using <code>typealias</code> from <a href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/">my last post</a>, we can tidy our code up a little bit.</p>

<pre><code class="swift">class StateManager {
    typealias NetworkCreator: () -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        networkProvider = networkProviderCreator()
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return {
            NetworkProvider("https://api.wherever.com")
        }
    }
}
</code></pre>

<h3>But wait, there's more!</h3>

<p>The other benefits of passing in a closure instead of an instance is that it lets the initializer customize the dependency based on other data. For example, let's say the state manager uses an <code>enum</code> to differentiate between staging and production API endpoints (btw, <a href="https://ashfurrow.com/blog/the-wrong-binary/">two-case enums are great at this</a>). How might our initializer change?</p>

<pre><code class="swift">enum APIEnvironment {
    case Staging, Production
}

class StateManager {
    typealias NetworkCreator: (String) -&gt; NetworkProvider

    let networkProvider: NetworkProvider

    init(
        environment: APIEnvironment,
        networkProviderCreator: NetworkCreator = StateManager.defaultNetworkCreator()
        ) {
        let baseURLString: String
        switch environment {
        case .Staging:
            baseURLString = "https://staging-api.wherever.com"
        case .Production:
            baseURLString = "https://api.wherever.com"
        }

        networkProvider = networkProviderCreator(baseURLString)
    }
}

private typealias ClassFunctions = StateManager
extension ClassFunctions {
    class func defaultNetworkCreator() -&gt; NetworkCreator {
        return { baseURLString in
            NetworkProvider(baseURLString)
        }
    }
}
</code></pre>

<p>I really dig this. The closure to create the dependency is close to the code that uses it, but is insulated from any specific instance, so we get the benefits of using DI.</p>

<p>You could argue that picking a base URL for an API shouldn't belong here, and you could probably convince me. But my point isn't that this specific example is ideal, it's that the pattern of using closures for initializer injection is pretty neat.</p>

<p>The logic to create dependencies has to go <em>somewhere</em>. I think it makes sense to keep it close to the code that actually uses the dependency, but isolated in a <code>class</code> function so no actual instance is involved in its creation. As a result, developers get the benefits of initializer injection and none of the added cognitive overhead when writing your production code.</p>

<p>It may not be a perfect pattern (what is?) but we've been using it on <a href="https://github.com/artsy/eidolon">eidolon</a> and <a href="https://github.com/artsy/eigen">eigen</a> for nearly two years and – combined with generous use of protocols – we've been really happy with the results.</p>

<p>Now that I have more free time to explore the pattern, I want to take it a step further and see where it could be used outside of unit testing. It's possible that using this approach could make all our types less tightly coupled and provide a more modular codebase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Type Aliases: Use Early and Often]]></title>
    <link href="http://artsy.github.io/blog/2016/06/24/typealias-for-great-good/"/>
    <updated>2016-06-24T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/24/typealias-for-great-good</id>
    <content type="html"><![CDATA[<p>It's been so fun to watch the Swift developer community experiment with Swift and to experiment with what idiomatic Swift will look like. No one really knows the answer yet, but we're starting to see some design patterns used more than others. We're seeing some language features used in key ways that define idiomatic Swift, and other language features that are being mostly ignored.</p>

<p>Regrettably, one of my favourite features of Swift has not enjoyed the meteoric rise in popularity I believe it deserves: <code>typealias</code>.</p>

<!-- more -->


<p>Type aliases allow developers to define synonyms for pre-existing types. It might sound dull because it <em>is</em> dull. In fact, its usefulness isn't even apparent when <em>writing</em> code, mostly when <em>maintaining</em> it.</p>

<p>But before I dig into how <code>typealias</code> is useful, let's review what it is to make sure we're all on the same page. Developers use <code>typealias</code> to create a new type identifier that's a synonym for another type. For example, we can declare <code>typealias BigNumber = Int64</code> and use "BigNumber" any place we could have used "Int64".</p>

<pre><code class="swift">func multiply(lhs: BigNumber, rhs: BigNumber) -&gt; BigNumber

...

let number: BigNumber = 5

...

let number = BigNumber(5)
</code></pre>

<p>You can use <code>typealias</code> for most any type: classes, enums, structs, tuples, closures, etc. Here are a few examples.</p>

<pre><code class="swift">typealias Name = String
typealias Employees = Array&lt;Employee&gt;
typealias GridPoint = (Int, Int)
typealias CompletionHandler = (ErrorType?) -&gt; Void
</code></pre>

<p>Now that we're familiar with <code>typealias</code>, I want to discuss four examples that show how <code>typealias</code> has helped us maintain code.</p>

<h3>Promoting Existing Types Semantics</h3>

<p>When writing web socket communication for eigen, Orta and I were using <a href="https://jwt.io">JSON Web Tokens</a> to authenticate the user. If you've never used JWTs before, don't worry, here's the tl;dr JWTs are a way to authenticate users in a way that clients can cryptographically verify. It's <em>basically</em> a base64 encoded string of JSON.</p>

<p>Clients don't need to verify the JWT in order to use them, and in fact when Orta and I began using them, we treated them only as strings retrieved from one API and sent to another (like an access token). However, instead of using the <code>String</code> type, I decided to define a <code>JWT</code> type alias.</p>

<pre><code class="swift">typealias JWT = String
</code></pre>

<p>I used the new <code>JWT</code> type throughout the code as a hint to other developers about what <em>kind</em> of string it is. This gave it some semantic meaning on top of being a string. Neat. Only later, when we needed to start decoding the JWT itself did this really come in handy.</p>

<p>After deleting the <code>typealias</code> and replacing it with a class of the same name, we didn't have to worry about changing function definitions and property types all throughout our codebase. We made the changes locally, in one file, and most all the rest of our code still compiled. Pretty cool! Here's the <a href="https://github.com/artsy/eigen/pull/1638/files/911473424849240bb71b89c412b0a1887e5c1418#diff-6d73ebd58fdd2d00c32813f60608fbd1R10">relevant portion of the pull request</a> that made that change.</p>

<h3>Consolidating Tuple Types</h3>

<p>I <a href="https://ashfurrow.com/blog/uicollectionview-unjustly-maligned/">recently wrote about UICollectionView</a> and how I used them to solve a difficult layout problem. I detailed how I created a pipeline of simple math functions that used previous results to calculate the next step of the layout. What I didn't mention was that I used tuples to help, specifically tuples with <code>typealias</code>.</p>

<p>Tuples are useful for composing several different values into a lightweight type. Think of tuples as junior structs. I was writing functions to do some calculations and return their result as a tuple. Something like this:</p>

<pre><code class="swift">func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
</code></pre>

<p>And because of how the layout pipeline worked, I then needed to use the <em>same</em> tuple as a parameter for the next function.</p>

<pre><code class="swift">func centersForPosition(position: CellPosition, metrics: (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)) -&gt; ...
</code></pre>

<p>Any time you use the same tuple type more than once, consider making a <code>typealias</code>. In this case, the code became a lot shorter and easier to skim and understand.</p>

<pre><code class="swift">typealias LayoutMetrics = (restingWidth: CGFloat, restingHeight: CGFloat, targetWidth: CGFloat, targetHeight: CGFloat)
typealias CenterXPositions = (restingCenterX: CGFloat, targetCenterX: CGFloat)

func layoutMetricsForPosition(position: CellPosition, aspectRatio: CGFloat) -&gt; LayoutMetrics

func centersForPosition(position: CellPosition, metrics: LayoutMetrics) -&gt; CenterXPositions
</code></pre>

<p>If we need to change something about the tuple later on, we only need to change it in one place. We've also made it easier to promote this tuple to a struct or class later on, just like in the JWT example, because all the functions are already referring to it as its own type. You can check out how we used type alias'd tuples <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/Views/LiveAuctionFancyLotCollectionViewLayout.swift#L104">in the code</a>.</p>

<h3>Defining Closures Signatures</h3>

<p>Objective-C developers, burdened with <a href="http://goshdarnblocksyntax.com">arcane syntax for blocks</a>, use C's <code>typedef</code> to isolate that syntax strangeness in one place. And even though Swift's closure syntax is <em>awesome</em>, we can still benefit from Objective-C's example – we can use type aliases for closure signatures.</p>

<p><a href="https://github.com/Moya/Moya">Moya</a> uses this technique quite a bit, because it has so many closures. Let's take a look at the <code>StubClosure</code>, which <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L78-L79">defines if (and how) a network request should be stubbed</a>.</p>

<pre><code class="swift">typealias StubClosure = Target -&gt; StubBehavior
</code></pre>

<p>We use this type as an initializer parameter instead of the full closure syntax, making our code a lot shorter and more legible. Nice! Since the user usually doesn't want to customize this parameter, so we've <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L97">defined a default value</a>.</p>

<pre><code class="swift">init(...
    stubClosure: StubClosure = MoyaProvider.NeverStub,
    ...)
</code></pre>

<p><code>MoyaProvider</code> has a class function on it called <code>NeverStub</code> <a href="https://github.com/Moya/Moya/blob/6666947219f231091d5c3e0b9d5f63ac4091718d/Source/Moya.swift#L246-L248">whose type</a> matches our closure.</p>

<pre><code class="swift">class func NeverStub(_: Target) -&gt; Moya.StubBehavior {
    return .Never
}
</code></pre>

<p>This particular function doesn't use the <code>typealias</code>, but another one does. We have a function named <code>DelayedStub</code> that returns the <code>typealias</code> instead of the raw closure. Take a look!</p>

<pre><code class="swift">class func DelayedStub(seconds: NSTimeInterval) -&gt; Moya.StubClosure {
    return { _ in return .Delayed(seconds: seconds) }
}
</code></pre>

<p>Super cool! Closures are a powerful tool in Swift already, but by using a <code>typealias</code>, we refer to it as <code>StubClosure</code> throughout our code.</p>

<p>In isolation, this gain may not seem significant, but the dividends have accrued dramatically for the project. <code>typealias</code> has made it easy to maintain Moya as it has evolved alongside Swift. Check out more examples of type aliasing closures <a href="https://github.com/artsy/eigen/blob/12eac80948bcfd1e5c6fc2aa85b22ccb2a4421dd/Artsy/View_Controllers/Live_Auctions/LiveAuctionStateManager.swift#L20-L21">in this eigen class</a>, which uses them for dependency injection.</p>

<h3>Extending Typealiases</h3>

<p>The last example I want to discuss is extensions, specifically extensions to <em>your own</em> types.</p>

<p>When writing classes, especially view controllers, developers have a habit of writing long, unwieldy files that are difficult to navigate and maintain. Preventing such files is far easier than fixing them, which is why I use <code>typealias</code> early, and I use it often.</p>

<p>I recommend using a descriptive <code>typealias</code> that is private to your file, and then extending that <code>typealias</code> so you can keep things neat and tidy. It's a bit confusing, so let's take a look at an example.</p>

<pre><code class="swift">private typealias PrivateHelperFunctions = MyViewController
extension PrivateHelperFunctions {
    ...
}

private typealias TableViewMethods = MyViewController
extension TableViewMethods: UITableViewDelegate, UITableViewDataSource {
   ...
}
</code></pre>

<p>We're still extending the view controller, but specifically we're extending the <code>typealias</code> so that the extension has a helpful name. This is another way that <code>typealias</code> can help add semantic meaning to your code.</p>

<p>Beyond helping you find code quickly, having code in extensions also makes it <em>way</em> easier to move that extension to another file or create a new helper class altogether. So not only does it keep classes tidy, but it also helps you keep classes <em>small</em>.</p>

<p>This technique can also serve as a workaround for Swift's <a href="http://stackoverflow.com/questions/24017316/pragma-mark-in-swift">awful Xcode sectioning syntax</a>.</p>

<p><img src="/images/2016-06-24-typealias-for-great-good/jumpbar.png" alt="Xcode Jumpbar" /></p>

<p>You can <a href="https://github.com/artsy/eigen/search?l=swift&amp;q=private+typealias&amp;utf8=%E2%9C%93">search through eigen</a> for more examples of using a private <code>typealias</code> to divide your code into manageable pieces.</p>

<hr />

<p>Look, I'm not saying that using <code>typealias</code> more is universally a good idea. You might disagree with some of the use cases in this post, which is fine! And this isn't meant to be an exhaustive list of examples, either.</p>

<p>My point is, used in a few key ways, <code>typealias</code> has helped me maintain my code more easily. It's a good tool to be familiar with. Even if it won't revolutionize the way you write software, <code>typealias</code> can help make your job a smidgen easier, and who could argue with that?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Injection for Xcode]]></title>
    <link href="http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection/"/>
    <updated>2016-03-05T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/03/05/iOS-Code-Injection</id>
    <content type="html"><![CDATA[<p>I have been writing code for roughly a decade. A large chunk of that time has been sitting waiting for my project to compile. It's a nice excuse to <a href="https://xkcd.com/303/">practice sword fighting</a> in the office, but really, deep down. It's frustrating. It's so easy to become <a href="https://xkcd.com/356/">nerd-sniped</a> when you wait for a long time.</p>

<p>As we integrate Swift into our projects, I've been seeing our compile times increase. So, I took some time to look at ways to improve this. The best option, so far, has been dynamic code injection via <a href="https://github.com/johnno1962/injectionforxcode">Injection Plugin for Xcode</a>. In a gist: This means that we don't recompile and re-launch, instead we inject new bits of code into a running application. This reduced the compile cycle on Eigen from 7 seconds to 1 second.</p>

<p>I took some time over the weekend to try and put together a video showing how I used code injection on a trivial app to create a view controller in code. It covers the technique I've <a href="https://github.com/artsy/eigen/pull/1236">started using in Eigen</a> and talks a little bit about how the pieces come together.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=uftvtmyZ8TM">to YouTube</a> for the video, or click more for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/uftvtmyZ8TM ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Being a Good OSS Citizen]]></title>
    <link href="http://artsy.github.io/blog/2016/01/28/being-a-good-open-source-citizen/"/>
    <updated>2016-01-28T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/01/28/being-a-good-open-source-citizen</id>
    <content type="html"><![CDATA[<p>Let's take a look at the day in the life of an open source citizen: me. On our app, I was given <a href="https://github.com/artsy/eigen/issues/971">an issue</a> that would allow users to refine what kinds of sale artworks they were looking at, and it included this <em>awesome</em> slider control so they could set min/max price ranges.</p>

<!-- more -->


<p></div></div><a href='/images/2016-01-28-being-a-good-open-source-citizen/design.png'><img src="/images/2016-01-28-being-a-good-open-source-citizen/design.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Nice.</p>

<p>But iOS doesn't have a slider like that built into UIKit, so I headed to <a href="https://cocoapods.org">CocoaPods.org</a> to find something that would work for me. Searching for "range slider" yielded a bunch of results, and I looked through three or four of them.</p>

<p>I picked <a href="https://cocoapods.org/pods/MARKRangeSlider">this one</a> because it did <em>almost exactly</em> what I needed, provided a reasonable level of customization, and had a history of development leading up to a recent v1.0.</p>

<p>But I said it did "almost exactly" what I needed, which meant I'd have to modify it. At this point, many developers either look for a different library or abandon the idea of using an existing library altogether and invent one themselves. That's a shame, because it's almost always faster and easier to improve an existing library than it is to build your own.</p>

<p>So let's step through what I did to modify this library for my needs. First, I checked to see if there was an issue for my feature already opened on the repository; maybe someone else had tried this, and I could benefit from their experience! That wasn't the case, so I forked the library to my personal account and cloned my fork locally. Now I can modify the library's code and commit it to my fork.</p>

<p>Next I add the library to my <code>Podfile</code>, but I'm clever about it.</p>

<pre><code class="rb">pod 'MARKRangeSlider', :path =&gt; '../MARKRangeSlider'
</code></pre>

<p>This tells CocoaPods that I'm <em>working</em> on the pod, and, it is stored in a local directory (the one where I cloned my fork). This makes it a "development pod", so that the files in Xcode are actually the ones I've cloned locally.</p>

<p>This is a really important, but subtle point. Normally, CocoaPods downloads copies of the files and stores those copies, but in this case, it refers to the existing files. It doesn't copy them at all: any changes I make to the library while working on my app are to the files I cloned. That means they can be easily committed and pushed up to my fork.</p>

<p>That's exactly what I did. I made my changes from within the app until I was satisfied, and <a href="https://github.com/ashfurrow/MARKRangeSlider/commit/aefbeb181b62c8c257a7d0ada1e75834489b1909">pushed them to my fork</a>, then pointed the <code>Podfile</code> to my fork of the pod.</p>

<pre><code class="rb">pod 'MARKRangeSlider', :git =&gt; 'https://github.com/ashfurrow/MARKRangeSlider.git'
</code></pre>

<p>Nice. At this point, I continued on as a developer, running a <code>pod install</code> to download the forked library with my commits as usual. I finished building the feature and <a href="https://github.com/artsy/eigen/pull/1075">PR'd it using my fork</a>.</p>

<p><img src="/images/2016-01-28-being-a-good-open-source-citizen/done.gif" alt="" /></p>

<p>I could've stopped here, but that'd be a shame. Someone else might want the same changes I made, and I should submit them back. I <a href="https://github.com/vadymmarkov/MARKRangeSlider/pull/22">opened a PR</a> on the library to contribute my changes back, and I made sure to explain <em>why</em> my changes were necessary. Because our app is open source, I was even able to link to <em>our</em> PR to show the library author how their work was being used.</p>

<p>The next morning, I woke up to find my PR had been merged, and after the author pushed an updated version of the library (including my changes), I updated our app's <code>Podfile</code> once more.</p>

<pre><code class="rb">pod 'MARKRangeSlider'
</code></pre>

<p>Then ran <code>pod update MARKRangeSlider</code> so it would update <em>just</em> that pod, and point it to the new release. I re-ran the unit tests to make sure I hadn't broken anything, and <a href="https://github.com/artsy/eigen/pull/1077">PR'd the change</a>.</p>

<p>This sounds like a lot, and having written it all out, I guess it is. But it's a series of small steps, not big ones, and I've worked like this long enough that it's second-nature to me now.</p>

<hr />

<p>I believe that using existing open source libraries is almost always better than writing your own, and I believe that improvements made to open source ought to be shared. Those beliefs shape my behaviour as a developer, and as a person.</p>

<p>Making your first contribution to a project may seem scary, but we all <a href="https://github.com/B-Sides/ELCSlider/pull/1">start somewhere</a>. It gets easier, and in time, you will become a paragon of open source citizenry.</p>
]]></content>
  </entry>
  
</feed>
