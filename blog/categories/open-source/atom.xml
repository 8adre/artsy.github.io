<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Open-Source | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/open-source/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2015-01-22T18:14:45-05:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[Artsy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Developing a Bidding Kiosk for iOS in Swift]]></title>
    <link href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/"/>
    <updated>2014-11-13T10:00:00-05:00</updated>
    <id>http://artsy.github.io/blog/2014/11/13/eidolon-retrospective</id>
    <content type="html"><![CDATA[<p>In the Summer of 2014, we began developing a bidding kiosk for the Artsy auctions platform (code-named <a href="https://github.com/artsy/eidolon">Eidolon</a>). Typically, the iOS team here at Artsy worked on two main apps: a <a href="http://iphone.artsy.net">consumer-facing iPhone app</a> and an iPad app used by art galleries. For Eidolon, we followed <a href="https://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/">Artsy’s standard practices</a> for building our software and use GitHub issues as our canonical source for bug reports and feature requests. Many of the components used in our apps are <a href="https://github.com/artsy">open source</a>, but the codebases themselves remain in private repositories.</p>

<p>Initial planning for Eidolon began over the Summer. Our designer <a href="http://twitter.com/katarinabatina">Katarina</a> had the main features sketched out. I was scheduled to work on it at first, with <a href="http://twitter.com/orta">Orta</a> and <a href="http://twitter.com/1aurabrown">Laura</a> joining me near the end of the project. We had a rough scope: the app would be able to list artworks at an auction and allow prospective bidders to learn more about these artworks. The user would be able to register to bid and place bids using the Kiosk, including credit card processing for identity-checking.</p>

<!-- more -->


<p><img src="/images/2014-11-12-eidolon-retrospective/listings.png" alt="Finished Eidolon App" /></p>

<h2>An Idea</h2>

<p>Orta and I met some friends over a weekend in Austria and, during our drive across the country, discussed the possibility of developing this new iOS app as a completely open source project. We were both excited about the prospect and had the support from <a href="http://twitter.com/dblockdotorg">dB</a> to make it open. There were just some technical issues that would have to be addressed to make the Kiosk app an open source reality. For example, how would we restrict access to the app’s API keys? Developing Eidolon in the open would let us share what we've learned, a value at Artsy, and also allow us to easily ask for help from the community.</p>

<p>We were also together in San Francisco for Apple’s announcement of Swift. Following the announcement, there were lots of small pieces of source code published on the Internet that demonstrated some of Swift’s new features, but a large project didn't really exist to show how iOS apps written in Swift don’t have to be moulded by outdated Objective-C traditions.</p>

<p>I wanted to write this app in Swift. After speaking with Orta, he said that as long as we could meet the deadlines, that would be okay. (Since this app uses enterprise distribution instead of the App Store, using beta versions of Xcode wouldn’t be a problem.)</p>

<p>More than just an app written in Swift, I wanted to build this app with functional reactive programming principles in mind. We would be using ReactiveCocoa any place that it made sense. While I had begun using it in our consumer iPhone app, it was mostly replacements of KVO code. This would be a fully “functionally reactive” app, a first for Orta and Laura.</p>

<p>So to summarize: our team embarked on a brand new project, developed in the open, using a new and incomplete language, built using a non-standard approach to functional programming, and using beta versions of Xcode. It was ambitious, but we were excited by the prospect of learning new things. I believed then, and do now, that Swift is the future of iOS development, and we love to be on the cutting edge (Artsy’s iOS apps are often testbeds for new CocoaPods features). There’s also an incredible demand for sample code written in Swift, so having a complete codebase written in Swift early in the language’s lifetime would be a significant contribution to the open source community.</p>

<h2>Getting Started</h2>

<p>The first steps were trivial. We examined our existing approach to iOS development and decided what techniques would be appropriate to use on this new project. Then, we identified tools that we needed to use those techniques. In some cases, existing tools needed to be modified to suit our needs. In other cases, the tools didn’t exist at all and we had to invent them.</p>

<p>Shortly after Swift’s announcement, <a href="http://twitter.com/modocache">Brian Gesiak</a> began work on <a href="https://github.com/Quick/Quick">Quick</a> and <a href="https://github.com/Quick/Nimble">Nimble</a>, a Swift-based testing framework and matchers framework, respectively. We would be able to continue using rspec-like syntax for our unit tests – awesome.</p>

<p>We use continuous integration on our other iOS projects and wanted to do the same for Eidolon. However, our usual CI provider, <a href="https://travis-ci.org">Travis</a>, has historically not supported beta versions of Xcode – our only choice for CI would be Jenkins. With a basic Swift Xcode project in hand, Orta set up Jenkins on a Mac Mini in the Artsy office. This didn’t meet our needs for a few reasons. Primarily, getting the build to work from a command line was difficult with Swift and Xcode 6 – Orta spent quite some time getting it configured. However, we all sorely missed some of the great integrations that Travis provides, particularly with GitHub. During development, we technically did have continuous integration, but it wasn’t leveraged to nearly the degree that it could or should have been.</p>

<p>A large portion of our tests on our other iOS apps rely on <a href="https://github.com/facebook/ios-snapshot-test-case">snapshot tests</a> and we use a <a href="https://github.com/dblock/ios-snapshot-test-case-expecta">set of Expecta matchers for Specta</a> that DB wrote. However, we weren’t using Specta for Eidolon and the matchers we were using wouldn’t work, so I <a href="https://github.com/AshFurrow/Nimble-Snapshots">wrote some new ones</a>. This was great from my perspective, since I didn’t really understand how the under-the-hood of a unit testing framework worked until I wrote the new matchers. It’s been fun and educational to see Quick and Nimble grow as projects. As an early adopter, the Artsy iOS team has been able to provide feedback on its development. This has hopefully helped Quick and Nimble grow in ways that benefitted from real-world use, but by contributing to the project, it also helped us get features we needed faster (you can insert either a “quick” or “swift” pun here as you wish).</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/polaroid.gif" alt="*click*" /></p>

<p>As I neared the beginning of development work on Eidolon, Orta and I discussed how we would want our networking layer to operate. One our our <a href="https://github.com/artsy/eidolon/issues/9">first GitHub issues</a> enumerated the desired features of our new network layer. In summary:</p>

<ul>
<li>Make it easy to run the app offline</li>
<li>Treat stubs as a first class citizens</li>
<li>Allow tests to state that only networking request X is allowed during this test run</li>
<li>Keep track of current requests and don't support dupes</li>
</ul>


<p>These features grew mainly out of frustrations with our ad hoc approach to network testing on our other projects: some tests would rely on stubbed models with populated data while other tests would rely on <a href="https://github.com/AliSoftware/OHHTTPStubs">stubbed network responses</a>.</p>

<p>The result of these conversations was <a href="https://github.com/AshFurrow/Moya">Moya</a>, a networking library that takes advantage of some really cool features in Swift. With some <a href="http://chris.eidhof.nl/posts/typesafe-url-routes-in-swift.html">help from Chris Eidhof</a>, we were able to write a functional-esque network abstraction library on top of <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> that provided compile-time checking for API endpoints. I even wrote an optional ReactiveCocoa-based interface for Moya. This interface does not accept callback closures; instead, it returns a <em>signal</em> that represents the network request. Following <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/4403d84348b30f5ffa05dfcd6317b14e0efecc62/Documentation/FrameworkOverview.md#connections">ReactiveCocoa best-practices</a>, this signal is <em>cold</em>, meaning that until someone subscribes to it (that is, registers their interest in the network request), the request is not fetched. We were even able to write a check for duplicate, in-flight requests and return existing signals.</p>

<p>Combined with the optional ReactiveCocoa extensions, Moya succeeded in addressing all of our needs for Eidolon’s network layer. Additionally, as each project matured, the needs of a full app informed the design and development of Moya.</p>

<p>One final component that had to be addressed before main development could get underway was the issue of API keys. We wanted to have our app accessible to anyone who was interested in it, but limit access to our API keys. Keeping keys secure when they are stored near source code is closely related to the problem of keeping keys secure once an app is compiled. To <a href="http://www.quora.com/How-were-the-Twitter-iPhone-and-Android-OAuth-keys-leaked">quote John Adams</a>, a member of the Twitter Security Team:</p>

<blockquote><p>Putting this in the context of, "should you be storing keys in software", is more appropriate. Many companies do this. It's never a good idea.</p></blockquote>

<p>Over the course of a few weeks, Orta solicited some help from CocoaPods contributor <a href="http://twitter.com/segiddins">Samuel Giddins</a> to create <a href="https://github.com/orta/cocoapods-keys">cocoapods-keys</a>. This project is a <a href="http://cocoapods.org">CocoaPods</a> plugin that stores the <em>names</em> of the keys you want to use in a plaintext file in your <code>~/.cocoapods</code> directory. The <em>values</em> of the keys with matching names are stored securely in your OS X keychain. Whenever you run <code>pod install</code>, this plugin generates an obfuscated <code>char</code> array with all of your applications keys mixed up with some other random data. The keys are only un-scrambled at runtime, and the file is ignored by git. Every developer on our team has their own API keys that are stored in their OS X keychains, far away from any git repository. While using this technique by no means guarantees the security of your API keys (a dedicated hacker with a debugger attached to your running app would still be able to retrieve your keys), it’s better than nothing.</p>

<p>We began main work on the project. Orta and I divided the app into two pieces: auction listings and bid fulfillment. We created two separate storyboards that would each encapsulate one of these app components. Orta took fulfillment and I took listings – over the course of Eidolon’s development, we had very few merge conflicts.</p>

<p>We used <a href="https://github.com/paulsamuels/SBConstants">SBConstants</a> to have compile-time safety when referring to storyboard identifiers and we used Swift’s operator overloading to make using these constants <a href="https://github.com/artsy/eidolon/blob/a96763b7ccee9cd35c30079ff4044779d30e999a/Kiosk/App/UIStoryboardSegueExtensions.swift">really easy</a>. For example:</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
    if segue == .LoadAdminWebViewController {
        // code goes here
    }
}
</code></pre>

<p>A component that I had not developed before was an admin panel that Orta made. This panel is accessible via a hard-to-accidentally-invoke gesture within the app and is protected by a password to prevent users from accidentally accessing it. The admin panel lets you change core behaviours of the app without recompiling it. For example, the panel is used to change between production and staging.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/admin.png" alt="Admin Panel" /></p>

<p>Speaking of production and staging, to prevent developers from accidentally placing bids on production and to prevent live users from inadvertently using the staging servers, Orta made a simple badge that would let you know if you were on staging. If you were running in the simulator, it would also alert you if you were running on production. This was great, but wouldn’t prevent someone from accidentally placing bids on the production server while testing on a device. <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L157-L169">Our solution</a> was to check your current wifi network name. If it looks like you’re at the Artsy offices, then the production flag is shown, even on a device.</p>

<p>So we’ve got the scaffolding for a great app and it was time to really begin development. Using ReactiveCocoa, we were able to make our <a href="http://artsy.github.io/blog/2014/09/22/transparent-prerequisite-network-requests/">XApp authentication transparent</a>. Functional reactive programming had other great benefits, like <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L87-L137">scheduling automated refreshes</a> of auction listings. We may have <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L48-L68">gone overboard</a> in one instance (cleaning that up is on my todo list), but ReactiveCocoa has made modelling complex behaviour of Eidolon relatively easy.</p>

<p>Of course, learning how to ReactiveCocoa is no easy feat. At this point, Orta and Laura were both working on Eidolon. There were many conversations in our Slack chatroom about how to approach problem-solving the ReactiveCocoa way and, with some time, they both became proficient at creating and manipulating signals. Sweet.</p>

<p>I’ve often been asked by people who want to use ReactiveCocoa about how to get their team up to speed; until recently, I didn’t have an answer. Now that I’ve done it, I can say that the most important thing is that you realize that you’re going to be responsible for this decision. If another developer needs help using ReactiveCocoa, you’ll be the one that helps them, so take that into consideration when scheduling your work. There were also several occasions where I didn’t know the answers to the questions Orta and Laura had, but the ReactiveCocoa community was there to support us.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/clap.gif" alt="Finished Eidolon App" /></p>

<p>So what about Swift? I mean, there are other apps out there for iOS 8 and other apps that use ReactiveCocoa – how did we find Swift?</p>

<p>Well, at first it was great. We took our own approach to it, trying out new language features that were unavailable to us in Objective-C. We even did away with the usual comment header that Xcode includes in newly created files – what is that even for?</p>

<p>Progress was slow at first, but Orta and I (Laura was not yet on the project) assumed that was due to our unfamiliarity with the language. Eventually, we became relatively proficient, but our progress was still really slow. Why?</p>

<p>However ready you think the Swift language is (and however much you believe <a href="http://www.apple.com/swift/">Apple’s PR</a> about the language), the reality is that the tools necessary to use Swift are far from ready. During the Xcode 6 betas, we stayed up-to-date in the hopes that newer versions of Xcode would fix our problems. However, after the GMs were released, it became apparent that these problems would just be a reality of working in Swift.</p>

<p>What kind of problems? Certainly there were Xcode crashes, but those were mostly fixed by beta 5. Building the app with enterprise distribution certificates cost us a few days of headaches, sure. And we still can’t compile the app with compiler optimizations without causing a segfault. But what really became the bane of our existence were SourceKit crashes.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/crash.gif" alt="SourceKit Crash" /></p>

<p>When SourceKit crashes, you temporarily lose autocomplete, syntax highlighting, and the behaviour of the text editor’s shortcut keys changes dramatically. The larger your project, the more often SourceKit crashes. These crashes can last anywhere from a split second to ten seconds or more and can be alleviated using an array of cargo-cult techniques such as:</p>

<ul>
<li>deleting your derived data folder</li>
<li>restarting Xcode</li>
<li>restarting your computer</li>
<li>restarting the project from scratch using Objective-C</li>
</ul>


<p>It’s really too bad. I’ve been asking for a <a href="http://ashfurrow.com/blog/we-need-to-replace-objective-c/">replacement to Objective-C</a> for a while and, when Swift was announced, I was ecstatic. However, based on our experience using Swift in a full production app, it is our conclusion that Swift is not yet ready for use in production apps unless you are willing to take on unknown risks and delays. As much as I <em>want</em> to like Swift, I can’t make the recommendation that you should use it, even if that’s what I’d like to say. I think that Steve Streza put it best:</p>

<blockquote class="twitter-tweet" lang="en"><p>Objective-C in the streets, Swift in the sheets.</p>&mdash; Steve Streza (@SteveStreza) <a href="https://twitter.com/SteveStreza/status/474069822808915968">June 4, 2014</a></blockquote>


<p> <script async src="http://artsy.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>As we neared our deadline, we realized that we probably weren’t going to make it. This was despite Katarina dropping some features from the “must-have” list. Orta sent out an email to the auctions team letting them know the bad news and we looked at alternatives; none of them suited us. Through some late nights and weekends, and a lot of coffee and tea, the three of us were able to complete the project with only a few hours to spare. It was a herculean effort and I’m incredibly proud to have worked with Orta and Laura to make it a success.</p>

<p>The launch went fairly smoothly, with Orta on-site to assist if necessary. The auction attendees found the software easy to use – one even said that the app made bidding “too easy”, which we are incredibly proud of.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/launch.jpg" alt="Finished Eidolon App" /></p>

<p>However, this successful launch came at a cost. It was only through some very long hours and a disregard for code longevity that we were able to complete the project on time. Ignoring unit tests was fine at the time, but we now have significant technical debt that we’ll be spending the next few weeks repaying.</p>

<h2>Lessons Learned</h2>

<p>It is completely possible to write an open source iOS application, though we did have to create some tools to help us along the way. These tools are now available for everyone to use, so you should consider opening your next project from the start. We’ve adopted an “open by default” approach where we only keep things closed when we have to, like with our fonts which have restrictive licenses. If your next app isn’t a core part of what makes you you, consider having a conversation about the pros and cons of making it open source.</p>

<p>ReactiveCocoa is <em>really</em> great at networking. It forced us to use some good abstractions that we might have otherwise cut corners on. Orta describes complex signal mapping to be “too magic.” For example, you can probably figure out what the following line of code does:</p>

<pre><code>RAC(self, "artworks") &lt;~ XAppRequest(.Artworks(auctionID)).filterSuccessfulStatusCodes().mapJSON().catch { (error) -&gt; RACSignal! in
    println("Error: \(error)")
    return RACSignal.empty()
}
</code></pre>

<p>Grab some artworks with the auction ID, filter out non-successful status codes, turn the data into JSON, and if anything goes wrong with any of that, log the error and ignore the results. Then bind the result of that operation to the <code>artworks</code> property of <code>self</code>. Nice and easy.</p>

<p>We discovered, as I mentioned earlier, that Swift just isn’t ready for primetime yet. I want it to be, but it was probably a mistake to write the app in Swift. By our projections, it took us about four times longer than we had anticipated to complete the project (in terms of person-hours worked). A lot of that is admittedly due to our own faulty estimates, but a lot more of it is attributable to Swift’s immaturity. In future projects, we’re going to be more mindful about estimation.</p>

<h2>So What Now?</h2>

<p>Swift isn’t ready yet, but we already have an app written in Swift, so what do we do? We could rewrite the whole app in Objective-C, but that would represent a substantial effort with very little reward, considering that the tools surrounding Swift are expected to improve over the coming months and years. We could shift away from Swift, writing all new code in Objective-C, but a lot of the app relies on existing Swift idioms, like Moya’s compile-time safety of API endpoint checking.</p>

<p>So we’re pretty much stuck with Swift, as much as you can be “stuck” with a totally <em>awesome</em> language that just needs some more time to have a mature ecosystem of tools. Swift does, after all, address most of my concerns with Objective-C. It has a lot of features that made developing Eidolon a joy. I’m impressed with what Apple’s made so far, but I’m eagerly waiting for Xcode 6.2 and beyond.</p>

<p>On our other iOS projects, we’ll stick with Objective-C for now, but we’re starting to have conversations around what would be necessary to move to developing those in the open, too. In that respect, Eidolon has been an unqualified success.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/success.jpg" alt="Success" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Transparent Prerequisite Network Requests with Swift and ReactiveCocoa]]></title>
    <link href="http://artsy.github.io/blog/2014/09/22/transparent-prerequisite-network-requests/"/>
    <updated>2014-09-22T11:26:00-04:00</updated>
    <id>http://artsy.github.io/blog/2014/09/22/transparent-prerequisite-network-requests</id>
    <content type="html"><![CDATA[<p>Artsy's <a href="http://developers.artsy.net">API</a> requires something called an <a href="https://developers.artsy.net/docs/authentication">XApp
token</a> in order to perform
requests. The token comes back with an expiry date, after which the token will
no longer work. A new token will have to be fetched.</p>

<p><code>json
{
    "xapp_token": "SOME_TOKEN",
    "expires_in":"2014-09-19T12:22:21.570Z"
}
</code></p>

<p>In our previous iOS apps, tragically written in Objective-C, we have a lot of
code that looks like the following. <code>getXappTokenWithCompletion:</code> checks to
make sure that there is a valid token. If there is, it invokes the completion
block immediately. Otherwise, it fetches a token, sets it in a static variable,
and then invokes the completion block.</p>

<p><code>objc
[ArtsyAPI getXappTokenWithCompletion:^(NSString *xappToken, NSDate *expirationDate) {
    [ArtsyAPI getSomething:^(NSDictionary *results) {
       // do something
    } failure:^(NSError *error) {
        // handle herror
    }];
}];
</code></p>

<p>That's kind of ugly. A better approach might be to embed the token-requesting
logic within the <code>getSomething:</code> method. But that kind of sucks, since we'd have
to reproduce that logic for <em>every</em> network-accessing method. If we have ten
methods, that's ten times we need to duplicate that logic.</p>

<p>With our <a href="https://github.com/artsy/eidolon">new app</a> (written in Swift), we're
using a network abstraction layer we've created called <a href="https://github.com/AshFurrow/Moya">Moya</a>.
Moya sits on top of <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> and
provides an abstraction for API endpoints. Instead of having ten different
network-accessing methods, there is only <em>one</em> method to which you pass one of
the ten different possible <code>enum</code> values. This means you have compile-time
safety in your networking code, but that's not really what we're here to talk
about.</p>

<!-- more -->


<p>Moya has this cool last-minute closure that it invokes to sign requests, so we
can sign these requests like this.</p>

<pre><code>var endpointsClosure = { (target: ArtsyAPI, method: Moya.Method, parameters: [String: AnyObject]) -&gt; Endpoint&lt;ArtsyAPI&gt; in
        let endpoint: Endpoint&lt;ArtsyAPI&gt; = Endpoint&lt;ArtsyAPI&gt;(URL: url(target), sampleResponse: .Success(200, target.sampleData), method: method, parameters: parameters)

        // Sign all non-XApp token requests
        switch target {
        case .XApp:
            return endpoint
        default:
            return endpoint.endpointByAddingHTTPHeaderFields(["X-Xapp-Token": /* global XApp token */])
        }
    }
</code></pre>

<p>So that's kind of cool.</p>

<p>Since there is only <em>one</em> method for accessing the API, we can easily inject
the token-checking method there. Something like</p>

<pre><code>public func XAppRequest(token: ArtsyAPI, completion: MoyaCompletion) {
    if /* token is valid */ {
        moyaProvider.sharedProvider.request(token, completion: completion)
    } else {
        moyaProvider.request(ArtsyAPI.XApp, completion: { (data, statusCode, error) -&gt; () in
            /* store token somewhere */
            moyaProvider.sharedProvider.request(token, completion: completion)
        })
    }
}
</code></pre>

<p>That's <em>better</em>, but it's still kind of ugly. We've got duplicated code in
there, and we're just kind of abstracting away the callback mess; it still
exists, we just don't see if as often.</p>

<p>OK, so what alternative is there? Well, Moya supports a <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>
extension that uses <em>signals</em> instead of callback closures. Super-cool. So we
can rewrite our <code>XAppRequest</code> function to be the following.</p>

<pre><code>private func XAppTokenRequest() -&gt; RACSignal {
    let newTokenSignal = moyaProvider.request(ArtsyAPI.XApp).filterSuccessfulStatusCodes().mapJSON().doNext({ (response) -&gt; Void in
        /* store new token globally */
    }).logError().ignoreValues()

    let validTokenSignal = RACSignal.`return`(/* does the token exist and is valid? */)
    return RACSignal.`if`(validTokenSignal, then: RACSignal.empty(), `else`: newTokenSignal)
}

public func XAppRequest(token: ArtsyAPI) -&gt; RACSignal {
    return XAppTokenRequest().then({ () -&gt; RACSignal! in
        return moyaProvider.request(token, method: method, parameters: parameters)
    })
}
</code></pre>

<p>Neato. So we have abstracted the "check if there is a valid token and get one if
there isn't" into its own private method called <code>XAppTokenRequest</code>. If the token
exists and is valid, then the function returns <code>RACSignal.empty()</code>, a signal
which completes immediately. Otherwise, we perform a fetch, which completes
when the XApp token request is finished.</p>

<p>Then we just need to use <code>then</code> on <code>RACSignal</code> to create a new signal that is
generated once the <code>XAppTokenRequest</code> signal completes. Since the <code>then</code> closure
is only invoked once the <code>XAppTokenRequest</code> signal completes, the newly created
request signal will be generated after the token is set, which is ideal.</p>

<p>All the code above is kind of simplified. That's OK, since it's just a proof of
concept. If you want the full code, it's all available <a href="https://github.com/artsy/eidolon/blob/1804044dfa8b22d9f765a621a5dbde357440146c/Kiosk/App/ArtsyAPI.swift#L87-L112">on GitHub</a>
and the conversation surrounding this change is in a <a href="https://github.com/artsy/eidolon/pull/29">merged pull request</a>.</p>

<p>If you have run into this problem and have a different solution, we'd love to
hear from you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing the Public Artsy API]]></title>
    <link href="http://artsy.github.io/blog/2014/09/12/designing-the-public-artsy-api/"/>
    <updated>2014-09-12T12:21:00-04:00</updated>
    <id>http://artsy.github.io/blog/2014/09/12/designing-the-public-artsy-api</id>
    <content type="html"><![CDATA[<p>Today we are happy to announce that we're making a new public API generally available, along with over 26,000 artworks from many of our institutional partners.</p>

<p>The Artsy API currently provides access to images of historic artwork and related information on <a href="https://artsy.net">artsy.net</a> for educational and other non-commercial purposes. You can try it for playing, testing, and learning, but not yet for production. The scope of the API will expand in the future as it gains some traction.</p>

<p><a href="https://developers.artsy.net"><img src="http://artsy.github.io/images/2014-09-12-designing-the-public-artsy-api/the-art-world-in-your-app.png" border="0"></a></p>

<p>If you just want to use the API, you can stop reading here and head to the <a href="https://developers.artsy.net/">developers.artsy.net</a> website. (The developers website itself is a classic Rails + Boootstrap example and is also <a href="https://github.com/artsy/doppler">open-source</a>.)</p>

<p>In this post we will step back and describe some of the technical decisions made during the development of the new API.</p>

<!-- more -->


<h2>First, Make All The Mistakes</h2>

<p>Artsy has been developing a homegrown API over the last four years, consisting of almost 400 endpoints and exposing over 100 domain models. It's probably one of the largest <a href="https://github.com/intridea/grape">Ruby Grape</a> implementations and it has been battlefield-tested by the dozens of services that we have built around it, starting with our <a href="https://github.com/artsy/force-public">recently open-sourced artsy.net website</a>. The core API project itself is unfortunately not public.</p>

<p>As with all legacy code with many client dependencies, our API has accumulated a staggering number of architectural faults, which have become impossible to work ourselves out of without a major rewrite. When thinking about a public API we went back to the drawing board with a more pragmatic approach.</p>

<h2>Use Hypermedia</h2>

<p>One of the common problems of being an API client is figuring out which routes an API provides or what data is available. For example, what can I do with this specific artwork? Documentation helps, but it often lacks such context. Furthermore, URLs are long and cumbersome to reference, parse and use. How can we make the API more developer-friendly and discoverable? Our answer was to settle on a well-known Hypermedia format. We chose <a href="http://stateless.co/hal_specification.html">HAL+JSON</a> because it is disciplined and very complete. Let me illustrate by example.</p>

<p>The <a href="https://api.artsy.net/api">API root</a> lists all the API routes within "_links", such as "artists".</p>

<p><code>json
{
  _links: {
    artists: {
      href: "https://api.artsy.net/api/artists"
    },
    ...
  }
}
</code></p>

<p>If you fetch artists from the above URL, they will be returned in the same JSON+HAL format. Each artist will include a number of links, notably to the artist's artworks. This is a perfect example of "context".</p>

<p><code>json
{
  _embedded: {
    artists: [
      {
        id: 123,
        _links: {
          artworks: {
            href: "https://api.artsy.net/api/artworks?artist_id=123"
          }
        }
      }
    ]
  }
}
</code></p>

<p>This is very powerful and makes it possible to write a generic API client that consumes any HAL+JSON API with just a bit of meta-programming. For Ruby, we provide examples using <a href="https://github.com/codegram/hyperclient">hyperclient</a>. Here's a more complete example that retrieves a well-known artist, <a href="https://artsy.net/artist/gustav-klimt">Gustav Klimt</a>, and a few of his works.</p>

<p>``` ruby
require 'hyperclient'</p>

<p>api = Hyperclient.new('https://api.artsy.net/api').tap do |api|
  api.headers.update('Accept' => 'application/vnd.artsy-v2+json')
  api.headers.update('X-Xapp-Token' => ...)
end</p>

<p>artist = api.links.artist.expand(id: '4d8b92b64eb68a1b2c000414') # Gustav Klimt
puts "#{artist.attributes.name} was born in #{artist.attributes.birthday} in #{artist.attributes.hometown}"</p>

<p>artist.links.artworks.embedded.artworks.each do |artwork|
  puts artwork.attributes.title
end
```</p>

<h2>Provide Canonical URLs for Resources</h2>

<p>In the past we returned different JSON payloads for a resource when it appeared within a collection vs. when it was retrieved individually. We have also developed solutions such as <a href="https://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> to deal with this in a declarative way. However, clients were burdened to merge data. For example, our iOS application had to deal with the fact that different data existed in the local store for the same artwork depending on how a user navigated to it in the app.</p>

<p>With the new API each resource has a canonical, uniquely identifying, "self" link which is used to reference it from other resources. When a client encounters such a link and has already downloaded the resource, it can just swap the data without making an HTTP request. This is only possible because every single URL maps 1:1 with a specific JSON response - there're no two data responses possible for the same URL. The retrieval of such data can be solved by a generic crawler - get a resource, fetch dependent resource links, iterate until you run out of links. Storage is even simpler and doesn't have to know anything about our domain model since it just maps URLs to JSON bodies.</p>

<h2>Partition Data and Perform Access Controls at API Level</h2>

<p>Because we decided not to return two different types of responses for a given model, we needed to partition data at the model level. For example, we introduced publicly available <a href="https://developers.artsy.net/docs/users">Users</a> and private <a href="https://developers.artsy.net/docs/user_details">User Details</a>. Access controls are now done exclusively at the API level.</p>

<p>The API developer must simply answer the question of whether a client is authorized to retrieve a resource or not. The API will return a 403 or 404 otherwise and it's not necessary to customize the response for different types of access.</p>

<h2>Be Disciplined About Data Access and NxM Queries</h2>

<p>The performance of APIs that return collections of objects has been a constant struggle. The initial API design attempted to help clients make the least amount of HTTP requests possible, often requiring many NxM server-side queries. This actually had a profoundly negative impact on overall performance and user experience than we have ever anticipated. Servers had to allocate a lot more memory to parse, render and cache very large JSON payloads, also causing larger garbage collection cycles. Web applications seemed slower because a lot of data had to be retrieved to render anything on initial page load. Mobile clients spend a lot more time parsing huge JSON payloads, requiring a lot of CPU and yielding rarely. This created a very sluggish user experience and much longer delays waiting for background processing to finish. To mitigate this and keep our API response times low on the server we had to leverage complicated caching schemes with <a href="https://github.com/artsy/garner">garner</a> and had to fine-tune Mongoid's eager-loading endpoint by endpoint.</p>

<p>For the new API we decided to never return relational data for a given model and refactor relations at the API model level when necessary. For example, we do not return artist information with a given artwork, but we do return a collection of artist links (an artwork can be created by a group of artists).</p>

<p><code>json
_embedded: {
    artist_links: [
      {
        id: "4fe8862daa12fb00010017b9",
        _links: {
          artist: {
            href: "https://api.artsy.net/api/artists/4fe8862daa12fb00010017b9"
          }
        }
      }
    ],
  }
}
</code></p>

<p>We can still leverage the fact that we do have embedded objects in MongoDB and the fact that HAL supports embedded data. For example, we always return editions embedded within an artwork. Being disciplined about this allows the server to make one database query for one API request.</p>

<p>Furthermore, creating such rigid rules forces us to never optimize for a specific client's scenario. That said, we still want to make life easy for developers that need bulk loading of various resources. We plan to implement a <a href="http://techblog.netflix.com/2012/07/embracing-differences-inside-netflix.html">Netflix API</a>-style middleware, where you can supply a set of URLs and get back a single, full JSON response with many different embedded resources. HAL+JSON's disciplined structure makes mixing data very easy.</p>

<h2>Use Media Types and Accept Headers for Versioning</h2>

<p>Our initial API lives under a versioned URL which includes "v1". For the new API we decided to adopt a different model and use an "Accept" header which currently takes an optional "application/vnd.artsy-v2+json" media type.</p>

<pre><code>$ curl 'http://api.artsy.net/api' -H 'Accept:application/vnd.artsy-v2+json'
</code></pre>

<p>Accept headers in the API context can be used to indicate that the request is specifically limited to an API version. Our API will serve a backward compatible format by default. However, when we decide change the format of a resource we will increment the API version and require a newer value in the header to retrieve it. The new version can become the default only after the old version has been fully deprecated.</p>

<h2>Create a Flat API Structure and Leverage 302 Redirects</h2>

<p>Our old API served all artworks from "/artworks" and artworks belonging to a partner from "/partner/:id/artworks". This was convenient, but made obsolete by a Hypermedia API. API URL structure no longer matters, because you no longer have to build URLs yourself, but follow links instead.</p>

<p>We decided to expose all models at the root and to use query string parameters for filtering. The API uses a plural for all routes, so you can query both "/artworks" and "/artworks/:artwork_id". At the Hypermedia API root level those differences are expressed in a declarative way in the shape of link templates with a singular (an artwork) or a plural (artworks) key, and all possible parameters.</p>

<p><code>json
{
  _links: {
    artworks: {
      href: "https://api.artsy.net/api/artworks{?public,artist_id}",
      templated: true
    },
    artwork: {
      href: "https://api.artsy.net/api/artworks/{id}",
      templated: true
    }
  }
}
</code></p>

<p>We leverage 302 redirects extensively. For example, querying "/current_user" redirects to "/users/:user_id" with a 302 status code (we cannot serve different content per user at the root of the API, as explained in a section above). Another good example is that the current API only provides access to public domain artworks, so if you navigate to "/artworks", you will currently be redirected to "/artworks?public=true", making this scheme future-proof.</p>

<h2>Do Not Paginate with Pages and Offsets</h2>

<p>Our original API accepted "page" or "offset" parameters. This was rather problematic for changing collections. Consider what happens when you are on page 5 and an item is inserted on page 4. Your next set of results for page 6 will include a duplicate that has just moved from page 5 onto page 6. Similarly, if an item was removed from page 4, a request to page 6 will skip an item that now appears on page 5.</p>

<p>Our new API returns subsets of collections with "next" links and optional counts. To fetch a subsequent page, follow the "next" link, which accepts an opaque "cursor" (internally we use the <a href="https://github.com/dblock/mongoid-scroll">mongoid-scroll</a> Ruby gem). The cursor retains position in a collection, including when an item has been deleted.</p>

<p><code>json
{
  total_count: 26074,
  _links: {
    self: {
      href: "https://api.artsy.net/api/artworks?public=true"
    },
    next: {
      href: "https://api.artsy.net/api/artworks?cursor=...&amp;public=true"
    }
  }
}
</code></p>

<p>We also wanted to solve the problem of querying different page sizes as we often wanted to retrieve just a couple of items quickly on an initial page load, then make larger requests for subsequent pages as the user scrolled, or vice-versa. You can now supply "size" to all collection APIs and a cursored approach makes it possible to vary the number on every request.</p>

<p>To get the "total_count", we decided to require clients to append "?total_count=true" to the query string. It's not necessary to do all that counting work on the server side if you're not going to use the data.</p>

<h2>Standardize Error Format</h2>

<p>We use HTTP error codes, however we also use JSON data that comes with those errors for additional, often humanly readable descriptions. We settled on a standard error format that includes a "type" and a "message". For example, a 401 Unauthorized response will also carry the following payload.</p>

<p><code>json
{
  type: "auth_error",
  message: "The access token is invalid or has expired."
}
</code></p>

<h2>Conclusion</h2>

<p>We tried to stay pragmatic with our approach and still have time and room for improvements. We would love to hear from you on our <a href="http://groups.google.com/group/artsy-api-developers/subscribe">API developers mailing list</a> and hope you'll give our new API a try at <a href="https://developers.artsy.net/">developers.artsy.net</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress and Jekyll]]></title>
    <link href="http://artsy.github.io/blog/2012/01/18/octopress-and-jekyll/"/>
    <updated>2012-01-18T23:03:00-05:00</updated>
    <id>http://artsy.github.io/blog/2012/01/18/octopress-and-jekyll</id>
    <content type="html"><![CDATA[<p>This blog is powered by static pages.</p>

<p>I think it's quite ironic that, while we spend a lot of time building complex large scale dynamic websites, our new favorite publishing platform is a system that compiles static content. But, in many ways, <a href="http://octopress.org/">Octopress</a> and <a href="https://github.com/mojombo/jekyll">Jekyll</a> fit our philosophy and developer workflow perfectly. Writing an article for this blog means using the same tools and processes as contributing to a project on Github. And everyone is welcome to browse and learn from <a href="https://github.com/artsy/artsy.github.com/tree/source">the source</a> of this blog, and even fork it and contribute fixes to the layout or even blog features.</p>

<p>Here's what Artsy engineers do to get setup (once) and publish a new post.</p>

<p>``` bash
    $ git clone git@github.com:artsy/artsy.github.com.git
     Cloning into artsy.github.com...</p>

<pre><code>$ cd artsy.github.com

artsy.github.com$ git checkout source
 Branch source set up to track remote branch source from origin.
 Switched to a new branch 'source'

artsy.github.com$ mkdir _deploy

artsy.github.com$ cd _deploy

artsy.github.com/_deploy$ git init
 Initialized empty Git repository in artsy.github.com/_deploy/.git/

artsy.github.com/_deploy$ git remote add origin git@github.com:artsy/artsy.github.com.git

artsy.github.com/_deploy$ git pull origin master
 From github.com:artsy/artsy.github.com
  * branch            master     -&gt; FETCH_HEAD

artsy.github.com/_deploy$ cd ..

artsy.github.com$ rake create_post["Octopress and Jekyll"]
 Creating new post: source/_posts/2012-01-18-octopress-and-jekyll.md

artsy.github.com$ git commit -am "Octopress and Jekyll"
 1 files changed, 52 insertions(+), 0 deletions(-)
 create mode 100644 source/_posts/2012-01-18-octopress-and-jekyll.md

artsy.github.com$ rake deploy
</code></pre>

<p>```</p>

<p>(If you're confused by the setup, check out <a href="http://code.dblock.org/octopress-setting-up-a-blog-and-contributing-to-an-existing-one">this post</a>).</p>

<p>We believe in simple systems and love the opportunity to understand technology in-depth. Everything you see, short of the blog content and styles, is written in Ruby by very smart people. The source is open and free, which helps us learn and make progress, together.</p>
]]></content>
  </entry>
  
</feed>
