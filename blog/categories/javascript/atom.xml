<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-04-12T14:43:36+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Making a React Native Components Pod]]></title>
    <link href="http://artsy.github.io/blog/2018/03/19/making-a-components-pod/"/>
    <updated>2018-03-19T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/03/19/making-a-components-pod</id>
    <content type="html"><![CDATA[<p>When we talk about our React Native setup in abstract, there are two kinds of "<a href="http://2.bp.blogspot.com/_PekcT72-PGE/SK3PTKwW_eI/AAAAAAAAAGY/ALg_ApHyzR8/s1600-h/1219140692800.jpg">now draw The Tick</a>" for
iOS developers:</p>

<ul>
<li>How do I build this React Native as a CocoaPods setup?</li>
<li>How do I get all the JavaScript tooling setup up?</li>
</ul>


<p>We're going to address the first part in this post. By the end of this post we're going to get an <a href="/blog/2016/08/24/On-Emission/">Emission-like
repo</a> set up for an existing OSS Swift iOS app called <a href="https://github.com/GitHawkApp/GitHawk/">GitHawk</a>. The aim being to introduce no
JavaScript tooling into GitHawk itself, and to only expose iOS-native <code>UIViewControllers</code> via a CocoaPod which is
consumed by GitHawk.</p>

<p>To do this we're going to use the CocoaPods' <code>pod lib create</code> template, and React Native's <code>react-native init</code> to
make a self-contained React Native repo. It will export a JS file, and some native code which Podspec will
reference. Read on to start digging in.</p>

<!-- more -->


<p>[show existing links]</p>

<p>So, I'm <strong>choosing</strong> to be annoying here. I will intentionally be adding <code>$</code>s before all of the commands, this is
specifically to slow you down and make you think about each command.</p>

<div class="mobile-only">
<p>
  <strong>Also, before you get started</strong>, it looks like you're using a really small screen, this post expects you would have a terminal around with useful tools for getting stuff done. I'm afraid without that, you're not going to get much out of it. I'd recommend switching to a computer.
</p>
</div>


<a name="What.Are.We.Going.To.Do."></a>
<h2>What Are We Going To Do?</h2>

<ol>
<li><p>We will use <code>pod lib create</code> to make a library repo</p></li>
<li><p>We will use <code>react-native init</code> to make a React Native environment</p></li>
<li><p>We will bundle the React Native code into our Pod's asset folder</p></li>
<li><p>We will edit the Podspec for GitDawg, and then the Podfile for the example project to consume it</p></li>
<li><p>We will use <a href="https://github.com/orta/cocoapods-fix-react-native#readme">cocoapods-fix-react-native</a> to hotfix the React Native files</p></li>
<li><p>We will expose a UIViewController which corresponds to the default screen from <code>react-native init</code> in our Pod</p></li>
<li><p>We will change the storyboard reference to point to the UIViewController from our Pod, and run the simulator to
see our welcome screen.</p></li>
<li><p>We will set up GitHawk to consume our new Pod</p></li>
<li><p>We will change GitHawk to show our new UIViewController instead of the bookmarks screen</p></li>
<li><p>We will edit GitDawg to act more like a development environment</p></li>
</ol>


<a name="GitHawk"></a>
<h2>GitHawk</h2>

<p>Let's get started by having a working <a href="https://github.com/GitHawkApp/GitHawk/">copy of GitHawk</a>. I'll leave the README for GitHawk to do that, but
if you want to be certain you're on the same version as me - I'm working from this commit
<code>6dc2988d23d70eb0862d11f4a365bf47a87848c6</code>.</p>

<p>Clone a copy of GitHawk, and get it running in your Simulator, should take about 5 minutes Then we can move on to
starting our repo.</p>

<a name="GitDawg.JS"></a>
<h2>GitDawg JS</h2>

<a name="Pre-requisites"></a>
<h3>Pre-requisites</h3>

<p>We need CocoaPods: <code>$ gem install cocoapods</code>.</p>

<p>We're going to need node, and a dependency manager. If you run <code>$ brew install yarn</code> you will get both.</p>

<p>I'm running on node <code>8.9.x</code> and yarn <code>1.5.x</code>. Honestly, it shouldn't matter if you're on node 8, or 9. Yarn is
basically CocoaPods for node projects. If you're wondering what the differences are between <a href="https://github.com/yarnpkg/yarn/">yarn</a> and <a href="https://www.npmjs.com/">NPM</a>,
then TLDR: there used to be some, but now there's few. I stick with yarn because I prefer how the CLI works, and I
can easily read the lockfile it generates.</p>

<p>We need the React Native CLI, so let's install it globally: <code>$ yarn global add react-native-cli</code>.</p>

<a name="Starting.with.the.Pod"></a>
<h3>Starting with the Pod</h3>

<p>We're going to let CocoaPods create the initial folder for our project. Let's set up your Pod:</p>

<pre><code class="sh">$ pod lib create GitDawg

Cloning `https://github.com/CocoaPods/pod-template.git` into `GitDawg`.
Configuring GitDawg template.

------------------------------

To get you started we need to ask a few questions, this should only take a minute.

If this is your first time we recommend running through with the guide:
 - http://guides.cocoapods.org/making/using-pod-lib-create.html
 ( hold cmd and click links to open in a browser. )


What platform do you want to use?? [ iOS / macOS ]
 &gt; iOS

What language do you want to use?? [ Swift / ObjC ]
 &gt; ObjC

Would you like to include a demo application with your library? [ Yes / No ]
 &gt; Yes

Which testing frameworks will you use? [ Specta / Kiwi / None ]
 &gt; None

Would you like to do view based testing? [ Yes / No ]
 &gt; No

What is your class prefix?
 &gt; GD
</code></pre>

<p>I'd recommend using Objective-C at this point, for simplicities sake. Swift is a great language and all, but I'm
after tooling simplicity. We're not going to write enough native code to warrent the setup for testing. Plus, if we
skip native testing then we can run CI on linux - which is basically instant in comparison.</p>

<p>This has made a new library. Let's go into our project's root with <code>$ cd GitDawg</code>. There shouldn't be too much in
here:</p>

<pre><code class="sh">$ ls
Example         GitDawg         GitDawg.podspec LICENSE         README.md         _Pods.xcodeproj
</code></pre>

<p>Because the core competency of the repo is the JavaScript, we're going to rename the "GitDawg" folder in the root to
be about the CocoaPod instead of owning the name of the project. Run <code>$ mv GitDawg Pod</code> to do that.</p>

<p>We want to create our React Native project. I'm hard-coding my versions in these commands to try ensure this post
lasts some time, but you never know what amazing changes the future brings. If things are broken, leave a comment at
the bottom of this post.</p>

<p>Let’s create a GitDawg React Native project, and then rename the folder to src:</p>

<pre><code class="sh"># Use the RN CLI to create a new RN app in the folder GitDawg
$ react-native init GitDawg --version react-native@0.54.4

# Rename the folder to src
$ mv GitDawg src

# Remove _Pods.xcodeproj as it's relevant for our pod
$ rm _Pods.xcodeproj
</code></pre>

<p>We don't want all our project files living in a sub-folder though, so let's move a few of them back to the repo's
root, then remove some unused files.</p>

<pre><code class="sh"># Copy the package metadata, deps, lockfile and dotfiles to root
$ mv src/package.json src/node_modules src/yarn.lock src/.* .

# Remove the ios and android scaffolds as we have the CP one
$ rm -rf src/ios src/android
</code></pre>

<p>Which should make your app's folder look something like this:</p>

<pre><code class="sh">$ ls
Example         GitDawg.podspec LICENSE         README.md       Pods        node_modules    package.json    src             yarn.lock

$ ls src/
App.js    __tests__ app.json  index.js
</code></pre>

<p>To ensure everything is still hooked up, let's make sure that all of your tests are working in the new repo.</p>

<pre><code class="sh">$ yarn test

yarn run v1.5.1
 PASS  src/__tests__/App.js
  ✓ renders correctly (176ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.392s
Ran all test suites.
✨  Done in 2.32s.
</code></pre>

<p>We're now going to be done with our JavaScript side, basically is our React Native "hello world". It's a React
Native project that exposes a single component which says <code>"Welcome to React Native!"</code>.</p>

<p>It looks like this:</p>

<center><img src="/images/making_cp_pod/success.png" width="50%" /></center>


<p>However, it's going to take a bit of work before we can see it in action.</p>

<a name="Deployment"></a>
<h3>Deployment</h3>

<p>We're going to want to have this exposed to our native libraries, so we're going to ship the bundled JavaScript as
our library's source code. We do this via the React Native CLI, and it's going to place the file inside our Pod
folder from earlier.</p>

<pre><code class="sh">$ react-native bundle --entry-file src/index.js --bundle-output Pod/Assets/GitDawg.js --assets-dest Pod/Assets
</code></pre>

<a name="GitDawg.Pod"></a>
<h2>GitDawg Pod</h2>

<p>With that done, we can start looking at the native side of our codebase. We let <code>pod lib create</code> set up an Example
app for us to work with in the repo, which consumes a Podspec in the root. So we're going to take a look at the
Podspec, and update it.</p>

<p>Our goal with the Example app is to set up an app exclusively for developing components in. In Artsy's case, this
app handles auth and has a series of jump-off points for developing a component (either through Storybooks or
directly using the Pods' <code>UIViewController</code>s.)</p>

<p>To get started we need to modify the CocoaPod this repo represents:</p>

<ul>
<li>Update our Podspec to handle React Native as a dependency, and our assets</li>
<li>Add support for native compilation via CocoaPods with <a href="https://github.com/orta/cocoapods-fix-react-native#readme">cocoapods-fix-react-native</a></li>
<li>Create a single <code>UIViewController</code> subclass for the Welcome Screen using the bundled React Native JS</li>
</ul>


<p>We want to have our Podspec re-use the metadata from React Native to set up GitDawg's dependencies. So replace
<code>GitDawg.podspec</code> with this:</p>

<pre><code class="ruby">require 'json'

# Returns the version number for a package.json file
pkg_version = lambda do |dir_from_root = '', version = 'version'|
  path = File.join(__dir__, dir_from_root, 'package.json')
  JSON.parse(File.read(path))[version]
end

# Let the main package.json decide the version number for the pod
gitdawg_version = pkg_version.call
# Use the same RN version that the JS tools use
react_native_version = pkg_version.call('node_modules/react-native')

Pod::Spec.new do |s|
  s.name             = 'GitDawg'
  s.version          = gitdawg_version
  s.description      = 'Components for GitHawk.'
  s.summary          = 'Components for GitHawk.'
  s.homepage         = 'https://github.com/orta/GitDawg'
  s.license          = { type: 'MIT', file: 'LICENSE' }
  s.author           = { 'orta' =&gt; 'orta.therox@gmail.com' }
  s.source           = { git: 'https://github.com/orta/GitDawg.git', tag: s.version.to_s }

  s.source_files   = 'Pod/Classes/**/*.{h,m}'
  s.resources      = 'Pod/Assets/{GitDawg.js,assets}'
  s.platform       = :ios, '8.0'

  # React is split into a set of subspecs, these are the essentials
  s.dependency 'React/Core', react_native_version
  s.dependency 'React/CxxBridge', react_native_version
  s.dependency 'React/RCTAnimation', react_native_version
  s.dependency 'React/RCTImage', react_native_version
  s.dependency 'React/RCTLinkingIOS', react_native_version
  s.dependency 'React/RCTNetwork', react_native_version
  s.dependency 'React/RCTText', react_native_version

  # React's dependencies
  s.dependency 'yoga', "#{react_native_version}.React"
  podspecs = [
    'node_modules/react-native/third-party-podspecs/DoubleConversion.podspec',
    'node_modules/react-native/third-party-podspecs/Folly.podspec',
    'node_modules/react-native/third-party-podspecs/glog.podspec'
  ]
  podspecs.each do |podspec_path|
    spec = Pod::Specification.from_file podspec_path
    s.dependency spec.name, "#{spec.version}"
  end
end
</code></pre>

<p>This Podspec is probably more complex then you're used to, but it means less config. To validate the Podspec, use
<code>$ pod ipc spec GitDawg.podspec</code> and read the JSON it outputs. With the Podspec set up, it's time to set up the
example project's <code>Podfile</code> and <code>Podfile</code>.</p>

<p>We'll start with applying the <a href="https://github.com/orta/cocoapods-fix-react-native#readme">React Native hot-fix plugin</a>, sometimes a version of React Native is released
that doesn't support Swift frameworks (as Facebook don't use Swift) and so you have to apply some patches to the
code. I made a CocoaPods Plugin that handles the hot-fixes for you.</p>

<p>Start by making a <code>Podfile</code> in the <code>Example</code> folder: <code>touch Example/Gemfile</code></p>

<pre><code class="ruby">source 'https://rubygems.org'

gem 'cocoapods'
gem 'cocoapods-fix-react-native'
</code></pre>

<p>Then run <code>$ bundle install</code> in the <code>Example</code> folder, which will set up <code>cocoapods</code> and <code>cocoapods-fix-react-native</code>
for your app. Making it possible to reference <code>"cocoapods-fix-react-native"</code> in your <code>Podfile</code>.</p>

<pre><code class="sh">$ cd Example
$ bundle install
</code></pre>

<p>We want to take the current Podfile and make sure that every React Native dependency comes from the folder in
<code>node_modules</code>. We can do this using the <code>:path</code> operator to redeclare where you can find each Pod.</p>

<p>Note: we also <em>extend</em> the amount of subspecs for <code>'React'</code> in this Podfile via <code>subspecs: ['DevSupport']</code> - this is
what provide the hot code reloading and other developer tools. You'll want this, it will mean that the example app
can be used as a dev environment, and your main app will only get a production environment.</p>

<p>So edit <code>Example/Podfile</code> to look like this:</p>

<pre><code class="ruby">platform :ios, '9.0'

node_modules_path = '../node_modules'
react_path = File.join(node_modules_path, 'react-native')
yoga_path = File.join(react_path, 'ReactCommon/yoga')
folly_spec_path = File.join(react_path, 'third-party-podspecs/Folly.podspec')
glog_spec_path = File.join(react_path, 'third-party-podspecs/glog.podspec')
double_conversion_spec_path = File.join(react_path, 'third-party-podspecs/DoubleConversion.podspec')

plugin 'cocoapods-fix-react-native'

target 'GitDawg_Example' do
  pod 'GitDawg', path: '../'

  # We want extra developer support in React inside this app
  pod 'React', path: react_path, subspecs: ['DevSupport']

  # We're letting CP know where it can find these Podspecs
  pod 'yoga', path: yoga_path
  pod 'Folly', podspec: folly_spec_path
  pod 'DoubleConversion', podspec: double_conversion_spec_path
  pod 'glog', podspec: glog_spec_path
end
</code></pre>

<p>Run the following to set up the React Native dependencies for your project.</p>

<pre><code>$ bundle exec pod install
</code></pre>

<p>We need some native code to represent our Welcome component from the React Native template. So create two new files
in <code>Pod/Classes</code>:</p>

<pre><code class="sh">$ touch ../Pod/Classes/GDWelcomeViewController.h ../Pod/Classes/GDWelcomeViewController.m
$ bundle exec pod install
$ open GitDawg.xcworkspace
</code></pre>

<p>It is a pretty vanilla <code>UIViewController</code>, so declare it exists in the interface and then use an <code>RCTRootView</code> as
it's <code>self.view</code>.</p>

<pre><code class="objc">#import &lt;UIKit/UIKit.h&gt;

@interface GDWelcomeViewController : UIViewController
@end
</code></pre>

<p>We're going to handle the React bridging in this <code>UIViewController</code>, because that is the simplest option for our
Hello World app. We'll be going back to this later.</p>

<pre><code class="objc">#import "GDWelcomeViewController.h"
#import &lt;React/RCTRootView.h&gt;
#import &lt;React/RCTBridgeDelegate.h&gt;
#import &lt;React/RCTBridge.h&gt;

// Let this View Controller handle getting the URL for the JS
@interface GDWelcomeViewController () &lt;RCTBridgeDelegate&gt;
@end

@implementation GDWelcomeViewController

// Set self.view on the VC to be an RCTRootView
- (void)loadView
{
    RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:@{}];
    self.view = [[RCTRootView alloc] initWithBridge:bridge
                                         moduleName:@"GitDawg"
                                  initialProperties:@{}];
}

// Use our bundled JS for now
- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
    NSBundle *gitdawgBundle = [NSBundle bundleForClass:GDWelcomeViewController.class];
    return [gitdawgBundle URLForResource:@"GitDawg" withExtension:@"js"];
}

@end
</code></pre>

<p>As the <code>pod lib create</code> template uses storyboards, you will need to open up the example app's storyboard and <a href="/images/making_cp_pod/settings_welcome.png">change
the initial view controller</a> to be a <code>GDWelcomeViewController</code>. If you see a <a href="/images/making_cp_pod/not_working.png">white screen</a> on the app launches then
this hasn't been done. Run the app in the simulator, and you should get this screen:</p>

<center><img src="/images/making_cp_pod/success.png" width="50%" /></center>


<p>This is the default screen from the React Native template, and it's proof that everything has worked for our dev app.</p>

<p>Let's take a second to re-cover what has happened to get to this point.</p>

<ol>
<li><p>We used the <code>pod lib create</code> template to make a library repo</p></li>
<li><p>We used <code>react-native init</code> to make a React Native environment, which has the settings in the root and the
source code inside <code>src</code></p></li>
<li><p>We've bundled the React Native code into our CocoaPod's asset folder</p></li>
<li><p>We set up the Podspec for GitDawg, and then the Podfile for the example project to consume it</p></li>
<li><p>We added <a href="https://github.com/orta/cocoapods-fix-react-native#readme">cocoapods-fix-react-native</a> to hot-fix the native files</p></li>
<li><p>We added a UIViewController for the default screen from <code>react-native init</code> to our CocoaPod, and ran
<code>bundle exec pod install</code> to update the example project</p></li>
<li><p>We changed the storyboard reference to point to the UIViewController from our Pod, and ran the simulator to see
our welcome screen</p></li>
</ol>


<p>This is a full run-through of how your Pod would look when integrated into your main app's codebase. At this point
you have a unique, isolated app which is going to be your development environment. In our case this app is a menu of
different root screens and admin flags.</p>

<p>—</p>

<p>OK, let’s go take this and migrate it into GitHawk. This is our end-goal:</p>

<center><img src="/images/making_cp_pod/githawk.gif" width="75%" /></center>


<p>Our setup is going to be different here because we can't rely on React Native coming from the file-system, as we
want to make sure our app has no hint of JS tooling. So we will use CocoaPods to handle downloading and setting up
our versions of the React Native libraries. As of 0.54.x, that is React and Yoga.</p>

<p>We want to have a local copy of the JSON version of Podspecs for each of these. They can be generated from the
Podspecs using <code>bundle exec pod ipc spec [file.podspec]</code>. Let's generate one for React:</p>

<pre><code class="sh">$ cd GitDawg/node_modules/react-native/; pod ipc spec React.podspec
</code></pre>

<p>It will output a bunch of JSON to your terminal. This is perfect. Let's move that text to a file on your desktop.</p>

<pre><code class="sh">$ pod ipc spec node_modules/react-native/React.podspec &gt; ~/Desktop/React.podspec.json
</code></pre>

<p>You'll see no output if everything went fine. Before you grab that podspec, let's get the one for yoga too.</p>

<pre><code class="sh">$ cd ReactCommon/yoga/; pod ipc spec yoga.podspec &gt; ~/Desktop/yoga.podspec.json
</code></pre>

<p>Again, no output means everything is perfect. You should now have two JSON files in your Desktop. Grab them, move
them into the <code>Local Pods</code> folder inside GitHawk. It should already have a few Podspecs.</p>

<pre><code class="sh">$ cd ../../../ # Or however it takes to get back to the project root

# Move any podspec.json into the Local Pods folder
$ mv ~/Desktop/*.podspec.json "Local Pods"
</code></pre>

<p>Modify their <code>Gemfile</code> to include <a href="https://github.com/orta/cocoapods-fix-react-native#readme">cocoapods-fix-react-native</a>:</p>

<pre><code class="diff">source 'https://rubygems.org'

gem 'cocoapods', '~&gt; 1.4.0'
+ gem 'cocoapods-fix-react-native'
</code></pre>

<p>Then run <code>bundle install</code>. Next we need to add GitDawg, and our custom Podspecs to the Podfile:</p>

<pre><code class="diff">source 'https://github.com/CocoaPods/Specs.git'

[...]

+ pod 'GitDawg', :path =&gt; '../GitDawg'
+ pod 'React', :podspec =&gt; 'Local Pods/React.podspec.json'
+ pod 'yoga',  :podspec =&gt; 'Local Pods/yoga.podspec.json'
</code></pre>

<p>Then run <code>$ bundle exec pod install</code>. That should grab React Native for you. Unlike inside GitDawg, CocoaPods will
download the source code from the internet. <code>:podspec</code> only tells CocoaPods where to find the Podspec, but it will
still download code externally.</p>

<p>Open up the Xcode Workspace - <code>open Freetime.xcworkspace</code>, and we're gonna make the code changes - it's all in one
file. Open the file <code>RootNavigationController.swift</code> and add a new <code>import</code> at the top for <code>GitDawg</code>:</p>

<pre><code class="diff">import UIKit
import GitHubAPI
import GitHubSession
+ import GitDawg
</code></pre>

<p>Then add our new view controller by replacing the bookmarks view controller</p>

<pre><code class="diff">        tabBarController?.viewControllers = [
            newNotificationsRootViewController(client: client),
            newSearchRootViewController(client: client),
+            GDWelcomeViewController(),
-            newBookmarksRootViewController(client: client),
            settingsRootViewController ?? UIViewController() // simply satisfying compiler
        ]
</code></pre>

<p>That should get you to the same point as we were in the dev app. Now when you run the app, log in and hit the place
where the bookmarks icon used to live. Tada.</p>

<p>[summary of native changes]</p>

<a name="What.now."></a>
<h2>What now?</h2>

<p>We've now got a successful deploy of our React Native Pod into an external app. However, we need to make some
changes in GitDawg now to start making it possible to develop efficiently.</p>

<p>We will need to:</p>

<ol>
<li><p>Make a singleton to handle setting up React Native between all potential UIViewControllers</p></li>
<li><p>Use the React Native Packager to get runtime editing support</p></li>
</ol>


<p>Move your terminal back to the GitDawg folder. We're going to make a class that represents our library, GitDawg</p>

<pre><code class="sh">$ touch Pod/Classes/GitDawg.h Pod/Classes/GitDawg.m
</code></pre>

<p>Then we need to re-run <code>$ bundle exec pod install</code> in the <code>Example</code> folder to get it in Xcode.
Open up the Xcode workspace for GitDawg and let's fill in these files. These files are based on <a href="https://github.com/artsy/emission/blob/master/Pod/Classes/Core/AREmission.h">AREmission.h</a> and <a href="https://github.com/artsy/emission/blob/master/Pod/Classes/Core/AREmission.m">AREmission.m</a>. For us, in a
production app, <code>AREmission</code> has a few key responsibilities:</p>

<ol>
<li><p>Pass through the non-optional environment variables to expose in JS</p></li>
<li><p>Create and retain the React Native bridge</p></li>
<li><p>Set up the native modules so that we React Native can communicate with the host app</p></li>
</ol>


<p>For this tutorial we don't need all of these responsibilities, but we will handle the second one.</p>

<p>For the header file, <code>GitDawg.h</code>:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;
#import &lt;React/RCTBridge.h&gt;

NS_ASSUME_NONNULL_BEGIN

/// The RN library API
@interface GitDawg : NSObject

/// The way in which we communicate with React Native
@property (nonatomic, strong, readonly) RCTBridge *bridge;

/// The single instance of a GitDawg
+ (instancetype)sharedInstance;
+ (void)setSharedInstance:(GitDawg *)instance;

/// Pass in nil for a packagerURL to indicate this is in release mode
- (instancetype)initWithPackagerURL:(nullable NSURL *)packagerURL NS_DESIGNATED_INITIALIZER;
- (instancetype)init NS_UNAVAILABLE;

@end

NS_ASSUME_NONNULL_END
</code></pre>

<p>And for the implementation file <code>GitDawg.m</code>:</p>

<pre><code class="objc">#import "GitDawg.h"

@interface GitDawg() &lt;RCTBridgeDelegate&gt;
@property (nonatomic, copy) NSURL *packagerURL;
@end

@implementation GitDawg

static GitDawg *_sharedInstance = nil;

+ (void)setSharedInstance:(GitDawg *)instance;
{
    _sharedInstance = instance;
}

+ (instancetype)sharedInstance;
{
    NSParameterAssert(_sharedInstance);
    return _sharedInstance;
}

- (instancetype)initWithPackagerURL:(NSURL *)packagerURL
{
    self = [super init];

    _packagerURL = packagerURL;
    _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:@{}];

    return self;
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
    return self.packagerURL ?: self.releaseBundleURL;
}

- (NSURL *)releaseBundleURL;
{
    return [[NSBundle bundleForClass:self.class] URLForResource:@"GitDawg" withExtension:@"js"];
}

@end
</code></pre>

<p>Then change your <code>GDWelcomeViewController.m</code> to use the shared <code>GitDawg</code>.</p>

<pre><code class="diff"> #import "GDWelcomeViewController.h"
+#import "GitDawg.h"
 #import &lt;React/RCTRootView.h&gt;
-#import &lt;React/RCTBridgeDelegate.h&gt;
-#import &lt;React/RCTBridge.h&gt;

 - (void)loadView
 {
-    RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:@{}];
+    RCTBridge *bridge = [GitDawg sharedInstance].bridge;
     self.view = [[RCTRootView alloc] initWithBridge:bridge
                                              moduleName:@"GitDawg"
                                     initialProperties:@{}];
 }

-// Just use our packaged JS for now
-- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
-{
-    NSBundle *emissionBundle = [NSBundle bundleForClass:GDWelcomeViewController.class];
-    return [emissionBundle URLForResource:@"GitDawg" withExtension:@"js"];
-}
-
 @end
</code></pre>

<p>We use the UIAppDelegate callback to set up our React Native bridge (you want this ready as fast as possible
normally) so edit <code>Example/GitDawg/GDAppDelegate.m</code></p>

<pre><code class="diff"> #import "GDAppDelegate.h"
+#import &lt;GitDawg/GitDawg.h&gt;

 @implementation GDAppDelegate

 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
 {
-    // Override point for customization after application launch.
+    NSURL *packagerURL = [NSURL URLWithString:@"http://localhost:8081/src/index.bundle?platform=ios"];
+    GitDawg *dawg = [[GitDawg alloc] initWithPackagerURL:packagerURL];
+    [GitDawg setSharedInstance:dawg];
+
     return YES;
 }
</code></pre>

<p>These changes give you the ability to switch between a dev mode and a release mode. Consider that React Native
just runs your JavaScript, the source of that could be anything, including from a local dev server. Well, almost.</p>

<p>Because of Apple's HTTP security, you cannot connect to localhost in an app by default. To fix this, open up <code>GitDawg-info.plist</code> and right-click to add a new row. Paste in <code>NSAppTransportSecurity</code> as the name, and Xcode will switch it to "App Transport Security Settings". Hit the <code>+</code> and add "Allow arbitrary loads" then set it to true.</p>

<p>From here: run the GitDawg app and you should see a red screen. This will be telling you to start the React Native Packager. Let's do that. From the root of the GitDwag repo run <code>$ yarn start</code>. This will start up a server. Once it says "Metro Bundler Ready." you can go back into your simulator for GitDawg and hit the reload button at the bottom.</p>

<p>That's it.</p>

<p>We're done.</p>

<p>So, there's obviously a lot more to learn here. You've successfully set up a Pod that you can deploy to an app. To make a real version you'd need to do a bit more process like creating a repo, and making tags.</p>

<p>We use our root view controller in Emission to trigger loading any of our view controllers, in different states. We also mix that with some admin options, the ability to run someone's PRs and <a href="https://storybook.js.org">storybooks</a>.</p>

<center><img src="/images/making_cp_pod/emission.png" width="100%" /></center>


<p>So good luck! Something like this probably easily scripted, but there's a lot of value in understanding how every piece comes together. So let me know if you make something cool - we've been using this structure for 2 years now and I think it's the right way to integrate React Native into an existing complex app. It keeps your JS tooling in a completely different repo from your iOS tooling.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native, 2 years later]]></title>
    <link href="http://artsy.github.io/blog/2018/03/17/two-years-of-react-native/"/>
    <updated>2018-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/03/17/two-years-of-react-native</id>
    <content type="html"><![CDATA[<p><a href="https://twitter.com/alloy/">@alloy</a> first mentioned React Native as an option for Artsy back <a href="https://github.com/artsy/mobile/issues/22">in March 2015</a>, and in February 2016 he
made <a href="https://github.com/artsy/emission/commit/b9154d4145feb49b38e713ee84594de04ea377e3#diff-9879d6db96fd29134fc802214163b95a">our first commit</a> to get the ball rolling. Since then, we've grown a new codebase, <a href="https://github.com/artsy/emission/">Emission</a>,
which has slowly taken over the responsibility for creating the UIViewControllers presented inside our iOS app.</p>

<p>We've come quite far from where we started, and I was asked if I could give a talk to summerize what we've learned in
the last 2 years as a set of native developers using React Native.</p>

<p>The <a href="https://speakerdeck.com/orta/react-native-2-years-later">slides are on speakerdeck</a>, and I've <a href="https://github.com/artsy/artsy.github.io/issues/420">opened comments</a> for this post if people have questions. Jump
through to get to the video or watch it <a href="https://www.prolificinteractive.com/iosoho/">on Prolific's site</a> for <a href="https://www.meetup.com/iOSoho/">iOSoho</a>.</p>

<!-- more -->


<p>Table of Contents for the Video:</p>

<ul id="timers">
  <li><a href="#video" data-time="330">Why move? 5:30</a></li>
  <li><a href="#video" data-time="520">Why not Swift? 8:40</a></li>
  <li><a href="#video" data-time="590">What we expected vs what we have: 9:50</a></li>
  <li><a href="#video" data-time="960">Downsides: 16:00</a></li>
  <li><a href="#video" data-time="1235">Artsy Omakase: 20:35</a></li>
  <li><a href="#video" data-time="1420">Upsides: 23:40</a></li>
  <li><a href="#video" data-time="1645">In-App demo of Emission: 27:25</a></li>
  <li><a href="#video" data-time="2195">RN Brownfield Apps: 36:35</a></li>
  <li><a href="#video" data-time="2379">Our Deployment: 39:30</a></li>
</ul>




<center id="video">
  <iframe src="https://player.vimeo.com/video/260417482" width="100%" height="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</center>




<script src="https://player.vimeo.com/api/player.js"></script>


<script>
  $(() => {
    $('#timers a').click( function(e) {
      var time = $(this).attr("data-time");
      var iframe = document.querySelector('iframe');
      var player = new Vimeo.Player(iframe);
      player.setCurrentTime(time)
      e.stopPropagation()
    });
  })
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integrating Redux and Socket.io]]></title>
    <link href="http://artsy.github.io/blog/2018/03/15/integrating-redux-and-socketio/"/>
    <updated>2018-03-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/03/15/integrating-redux-and-socketio</id>
    <content type="html"><![CDATA[<p>On the engineering team at Artsy, we've built a CMS for both internal and external editors to write and publish <a href="https://www.artsy.net/article/artsy-editorial-brooklyn-born-sisters-diego-rivera-dubbed-the-greatest-living-women-mural-painters">articles</a>. We have a team of a dozen in-house editors creating new content on a daily basis. As many people starting using the app simultaneously, something became apparent. Editors would unintentionally go and override each other’s work because there was no way to tell if someone else was currently editing an article. As a workaround, team members would be forced to edit drafts in another editor such as google docs and copy their work over once ready. This made for a lackluster collaborative experience.</p>

<p>So we decided to implement a system that would make our editors more confident in our CMS by ensuring only one editor could go in and edit an article at any given time. I was tasked with coming up with an elegant technical solution for this feature. Here's the approach I took....</p>

<!-- more -->


<p>We decided to resolve this issue building an article locking mechanism. When an editor would start editing an article, all other users in sessions would be notified. One of the requirements for this new feature was for things needed to update without refreshing the page. In order to fulfill this, we needed to implement a system to push events from the server to clients.</p>

<p>Based on the requirements presented, I looked at potential solutions for this. Right away, the HTML5 WebSocket API seemed like the perfect solution to keep all clients synced in realtime, however a few issues arose. For one, many proxies and firewalls block WebSocket connections, so it's not always an available option for clients. I needed to find another option to mitigate that problem. That's where <a href="https://socket.io">socket.io</a> comes in.</p>

<p>Socket.io, a battle tested library for creating real-time bidirectional communication channels, helps mitigate those problems. In a gist socket.io initially establishes a long-polling HTTP connection, and in parallel tries to upgrade it to WebSocket.</p>

<p>By the time this project was proposed, we had already started the process of converting the app from using Coffeescript, Backbone + Jade to a modern javascript stack based on ES6, React for UI components and Redux for managing app state. Naturally, one of the goals was to leverage Redux to manage state for this feature. You've probably at least heard of Redux as it has emerged as the industry standard way of implementing one-way data flows in apps. If you're not familiar with Redux and its architecture, here's an excellent <a href="https://www.smashingmagazine.com/2016/06/an-introduction-to-redux/">intro to redux</a> article to familiarize yourself.</p>

<p> So how do we go about integrating socket.io in the Redux-based state architecture we just designed. I thought the best would be to change as little as possible to the code structures developers familiar with Redux are already used to. Namely, use standard Redux actions creators and simply use a decorator to enhance them.</p>

<p><img src="/images/2018-03-15-integrating-redux-and-socketio/example.gif" alt="/images/2018-03-15-integrating-redux-and-socketio/example.gif" /></p>

<p>Here's a simplified version of the <a href="https://leanpub.com/javascriptallongesix/read#decorators">function decorator</a> which broadcasts redux actions via a socket connection to other connected clients.</p>

<pre><code class="javascript">// From client
import io from 'socket.io-client'
import { messageTypes } from './messageTypes'

let socket = io(rootURL)

// Helper to emit a redux action to our websocket server
const emitAction = (actionCreator) =&gt; {
  return (...args) =&gt; {
    // This return the action object which gets sent to our backend
    // server via the socket connection
    const result = actionCreator.apply(this, args)
    socket.emit(result.key, {
      ...result.payload,
      type: result.type
    })
    return result
  }
}
</code></pre>

<p>To recap the code above, <code>emitAction</code> is a <a href="https://leanpub.com/javascriptallongesix/read#decorators">function decorator</a> that enhances action creators to dispatch actions via the local store and also broadcast that same action to other connected clients. The following code snippet shows how it's being used to wrap a typical redux action creator.</p>

<pre><code class="javascript">// actions.js
import keyMirror from 'client/lib/keyMirror'
import { emitAction } from 'client/apps/websocket/client'
import { messageTypes } from 'client/apps/websocket/messageTypes'

export const actions = keyMirror(
  ...
  'START_EDITING_ARTICLE',
  'STOP_EDITING_ARTICLE',
  ...
)

export const startEditingArticle = emitAction((data) =&gt; {
  return {
    type: actions.START_EDITING_ARTICLE,
    key: messageTypes.userStartedEditing,
    payload: {
      timestamp: new Date().toISOString(),
      ...data
    }
  }
})

...
</code></pre>

<p>On the receiving end, we simply add a reducer to process the event from the action payload which we can then return a new state from.</p>

<pre><code class="javascript">//reducers.js
import { data as sd } from 'sharify'
import { actions } from 'client/actions/editActions'
import u from 'updeep'

export const initialState = {
  articles: sd.ARTICLES,
  articlesInSession: sd.ARTICLES_IN_SESSION || {}
}

export function articlesReducer (state = initialState, action) {
  switch (action.type) {
    ...
    case actions.START_EDITING_ARTICLE: {
      const session = action.payload

      return u({
        articlesInSession: {
          [session.article]: session
        }
      }, state)
    }
    ...
  }
}
</code></pre>

<p>We can now use our <code>emitAction</code> decorator function to enhance any number of action creators. All that's needed is to add a <code>key</code> property to the action object. We can then decide to either process actions
 on a backend service or proxy them directly to other clients. You can find the remainder of the server implementation and our <a href="https://github.com/artsy/positron/blob/master/src/client/apps/websocket/index.js">event handlers</a> in our <a href="https://github.com/artsy/positron">github repo</a> along with instructions on how to run the code.</p>

<a name="Future.improvements"></a>
<h2>Future improvements</h2>

<p>There's an opportunity to extract this module for reuse in other projects and apps. Another logical improvement to this project would be to implement collaborative editing using this architecture. It would also be nice to include helpers for handling events on backend servers.</p>

<a name="Useful.links"></a>
<h2>Useful links</h2>

<ul>
<li><a href="https://redux.js.org/">Redux</a></li>
<li><a href="https://socket.io/docs/">Socket.io</a></li>
<li><a href="https://github.com/substantial/updeep">Updeep</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Babel 7 + TypeScript]]></title>
    <link href="http://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript/"/>
    <updated>2017-11-27T14:18:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript</id>
    <content type="html"><![CDATA[<p>At Artsy we &lt;3 <a href="https://www.typescriptlang.org/">TypeScript</a>. We use it with React Native via <a href="https://github.com/artsy/emission">Emission</a> and on the web via <a href="https://github.com/artsy/reaction">Reaction</a>. Until recently, however, projects that required the use of Babel had to implement convoluted tooling pipelines in order to work with the TypeScript compiler, increasing friction in an already complex landscape. (An example of this is Emission's use of Relay, which requires <a href="https://facebook.github.io/relay/docs/babel-plugin-relay.html#setting-up-babel-plugin-relay">babel-plugin-relay</a> to convert <code>graphql</code> literals into require calls.) Thankfully, those days <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-typescript">are over</a>. Read on for an example project, as well as some advice on how to avoid common pitfalls when working with the new beta version of Babel 7.</p>

<!-- more -->


<p>Babel configurations can be complicated. They take time to set up and maintain and can often contain some pretty <a href="https://github.com/kentcdodds/babel-macros">far-out features</a> that make interop with other environments difficult. That's why we were elated when <a href="https://github.com/babel/babylon/pull/523">this PR</a> appeared in the wild from <a href="https://github.com/andy-ms">@andy-ms</a>, a developer on the TypeScript team, announcing a new parser for Babylon. <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-typescript">@babel/preset-typescript</a> arrived soon after and we felt it was finally time to give it a try. There was a catch, however: TypeScript support only works with Babel 7+!</p>

<p><strong>TLDR; <a href="https://github.com/damassi/babel-7-typescript-example" target="_blank">Check out the project on GitHub ></a></strong></p>

<p>Here's list of setup issues we faced in no specific order:</p>

<a name="L1..New..babel.Namespace"></a>
<h2>1) New @babel Namespace</h2>

<p>One of the first things Babel 7 users will notice is the package ecosystem now exists as a <a href="https://github.com/babel/babel/tree/master/packages">monorepo</a> and all NPM modules are namespaced behind the <code>@babel</code> org address. Packages that used to be installed via</p>

<pre><code class="sh">yarn add -D \
  babel-core \
  babel-preset-react \
  babel-preset-stage-3
  ...
</code></pre>

<p>are now installed via
<code>sh
yarn add -D \
  @babel/core \
  @babel/preset-react \
  @babel/preset-stage-3
  ...
</code>
which immediately creates upgrade conflicts between libraries that use Babel 6 and Babel 7. For example, <code>babel-jest</code> internally points to <code>babel-core</code> which supports a <a href="https://github.com/facebook/jest/blob/master/packages/babel-jest/package.json#L19">version range between 6 and 7</a> -- but! -- <code>babel-core</code> is now <code>@babel/core</code> so this breaks.</p>

<p>This wasn't immediately apparent at the time, and so we would often find errors like</p>

<pre><code class="sh">Error: Could not find preset "@babel/env" relative to directory
</code></pre>

<p>These errors appeared ambiguous because the folder structure was correct and commands like <code>yarn list @babel/preset-env</code> yielded expected results:</p>

<pre><code class="sh">└─ @babel/preset-env@7.0.0-beta.32
✨  Done in 0.58s.
</code></pre>

<p>Why was the package not found? Digging deeper, it seemed like Babel 6 was still being used somewhere. Running <code>yarn list babel-core</code> revealed the culprit:</p>

<pre><code class="sh">└─ babel-core@6.25.0
✨  Done in 0.58s.
</code></pre>

<p>Thankfully, <a href="https://github.com/babel/babel-bridge">babel-bridge</a> exists to "bridge" the gap, but one can see how complications can and will arise. Further, not all packages have implemented this fix and so we had to rely on <code>yarn</code>'s new <a href="https://yarnpkg.com/lang/en/docs/selective-version-resolutions/">selective dependency resolution</a> feature which overrides child dependency versions with a fixed number set directly in <code>package.json</code>:</p>

<pre><code class="json">"resolutions": {
  "babel-core": "^7.0.0-bridge.0"
},
</code></pre>

<p>With this in place many of our errors disappeared and packages like <code>jest</code> now worked like a charm.</p>

<a name="L2..Missing.ES2015.Features"></a>
<h2>2) Missing ES2015 Features</h2>

<p>Another error we faced early on surrounded language features that worked with Babel <em>or</em> TypeScript, but not with Babel <em>and</em> TypeScript. For example, take an existing Babel project that points to <code>index.js</code> as an entrypoint, configure it to support TypeScript via Babel 7, and then run it:</p>

<pre><code class="json">"scripts": {
  "start": "babel-node index.js"
}
</code></pre>

<pre><code class="js">// index.js
require('@babel/register', {
  extensions: ['.js', '.jsx', '.ts', '.tsx']
})
require('app/server.ts')
</code></pre>

<pre><code class="javascript">// app/server.ts
console.log('hi!')
</code></pre>

<p>Running</p>

<pre><code class="sh">yarn start
$ babel-node index.js

hi!
✨  Done in 1.88s.
</code></pre>

<p>Everything seems to be working; our <code>.js</code> entrypoint is configured to support <code>.ts</code> extensions and we kick off the boot process.</p>

<p>Let's now try to import a file from within <code>app/server.ts</code>:</p>

<pre><code class="javascript">import path from 'path'
console.log(`Hello ${path.resolve(process.cwd())}!`)
</code></pre>

<pre><code class="sh">yarn start
$ yarn run v1.3.2
$ babel-node index.js
sites/src/index.tsx:1
(function (exports, require, module, __filename, __dirname) { import path from 'path'
                                                              ^^^^^^

SyntaxError: Unexpected token import
</code></pre>

<p>Maybe my <code>tsconfig.json</code> file is misconfigured?</p>

<pre><code class="json">{
  "compilerOptions": {
    "module": "es2015"
  }
}
</code></pre>

<p>Nope, all good. How about my <code>.babelrc</code>?</p>

<pre><code class="json">{
  "presets": [
    ["@babel/env", {
      "targets": {
        "browsers": ["last 2 versions"]
      }
    }],
    "@babel/stage-3",
    "@babel/react",
    "@babel/typescript"
  ]
}
</code></pre>

<p>We're using <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-env"><code>@babel/preset-env</code></a> which handles selecting the JS features we need, so thats not it. And anyways, doesn't TypeScript support <code>ES2015</code> modules right out of the box?</p>

<p>Continuing, how about specifying the extension list directly in <code>package.json</code>:</p>

<pre><code class="json">"start": "babel-node --extensions '.ts,.tsx' index.js"
</code></pre>

<p>Still no go 🙁</p>

<p>Last try: Create a new entrypoint file that uses a <code>.ts</code> extension and then use <em>that</em> to boot the rest of the app:</p>

<pre><code class="json">"start": "babel-node --extensions '.ts,.tsx' index.ts"
</code></pre>

<pre><code class="javascript">// index.ts
import './app/server'
</code></pre>

<pre><code class="sh">yarn start
$ yarn run v1.3.2
$ babel-node index.js
Hello /sites!
</code></pre>

<p>Once this change was in place, we could ditch <code>@babel/register</code> and instead rely on the <code>--extensions</code> configuration from <code>package.json</code>, just like the <a href="https://github.com/babel/babel/tree/master/packages/babel-preset-typescript">README</a> suggests (doh! 🤦).</p>

<p><strong>NOTE:</strong> If you're using <a href="https://github.com/tleunen/babel-plugin-module-resolver"><code>babel-plugin-module-resolver</code></a> to support absolute path imports make sure to update the <code>extensions</code> <a href="https://github.com/tleunen/babel-plugin-module-resolver#options">option</a> with <code>.ts</code> and <code>.tsx</code>.</p>

<a name="L3..Type-Checking"></a>
<h2>3) Type-Checking</h2>

<p>Lastly, since Babel 7 is now responsible for compiling our TypeScript files we no longer need to rely on TypeScript's own <code>tsc</code> compiler to output JavaScript and instead just use it to type-check our code. Again, in <code>package.json</code>:</p>

<pre><code>"type-check": "tsc"
</code></pre>

<p>This reads in settings located in <code>tsconfig.json</code>:
<code>json
{
  "compilerOptions": {
    "noEmit": true,
    "pretty": true
    ...
  }
}
</code></p>

<p>Notice the <code>noEmit</code> flag? That tells <code>tsc</code> not to output any JS and instead only check for correctness. The "pretty" flag gives us nicer type-checker output.</p>

<p>While this seemed to be all that was needed, running <code>yarn type-check</code> would throw an error:</p>

<pre><code>$ yarn type-check
yarn run v1.3.2
$ tsc

node_modules/@types/jest/index.d.ts(1053,34): error TS2304: Cannot find name 'Set'.

1053         onRunComplete?(contexts: Set&lt;Context&gt;, results: AggregatedResult): Maybe&lt;Promise&lt;void&gt;&gt;;
                                      ~~~

error Command failed with exit code 1.
</code></pre>

<p>Why is it TypeChecking my <code>node_modules</code> folder when <code>rootDirs</code> is set to <code>src</code>? It looks like we missed a TypeScript setting:</p>

<pre><code class="json">{
  "compilerOptions": {
    "skipLibCheck": true
  }
}
</code></pre>

<p>With that last missing piece everything now works:</p>

<pre><code class="sh">yarn type-check -w
yarn run v1.3.2
$ tsc -w

src/index.tsx(5,7): error TS2451: Cannot redeclare block-scoped variable 'test'.

5 const test = (foo: string) =&gt; foo
        ~~~~

src/index.tsx(6,6): error TS2345: Argument of type '2' is not assignable to parameter of type 'string'.

6 test(2)
       ~
</code></pre>

<p>Proper type-checking, but compilation handled by Babel 😎.</p>

<a name="L4..TypeScript.and.Flow"></a>
<h2>4) TypeScript and Flow</h2>

<p>Unfortunately, the TypeScript and Flow plugins for Babel cannot be loaded at the same time, as there could be ambiguity about how to parse some code.</p>

<p>This is usually ok, because the general advice is to compile your library code to vanilla JS before publishing (and thus strip type annotations), but there are packages that could still enable the Flow plugin.</p>

<p>For example, <a href="https://github.com/babel/babel/pull/6118">the React Babel preset</a> in the past would enable the Flow plugin without really needing it for its own source, but just as a default for consumers of React.</p>

<p>This issue cannot really be worked around without patching the code that loads the plugin. Ideally this patch would be sent upstream so that the issue goes away for everybody.</p>

<p>This issue can be worked around by either eliminating the dependency on the preset that loads the plugin, for instance by depending on the individual plugins directly, or if that’s not possible by patching the code. Ideally that patch should go upstream, of course, but if you need something immediate then we highly recommend <a href="https://github.com/ds300/patch-package">patch-package</a>, as can be seen used in <a href="https://github.com/artsy/emission/pull/780/files#diff-29cf179661e0495e62e9cd67dd0307dd">this example</a>.</p>

<p>There’s even projects that publish their Flow annotated code <em>without</em> compiling/stripping type annotations, the one we know of and use is <a href="https://github.com/facebook/react-native/issues/7850#issuecomment-225415645">React Native</a>. There’s no way around this other than patching the code. You may think that you could use a plugin like <a href="https://babeljs.io/docs/plugins/transform-flow-strip-types/">babel-plugin-transform-flow-strip-types</a>, but in reality that transform needs the Flow plugin to be able to do its work and thus is a no-go.</p>

<p>The way we’ve worked around that is by <a href="https://github.com/artsy/emission/pull/780/files#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R36">stripping Flow type annotations from <em>all</em> dependencies</a> at <a href="https://github.com/artsy/emission/pull/780/files#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R39">dependency install time</a> using the <a href="https://github.com/flowtype/flow-remove-types"><code>flow-remove-types</code> tool</a>. It can get a little slow on many files which is why we do a bunch of filtering to only process files that have <code>@flow</code> directives, the downside is that some files don’t have directives like they should and so <a href="https://github.com/artsy/emission/pull/780/files#diff-d6d30dd9bd4cdb1ac0d1268937508814R65">we patch those to add them</a> using the aforementioned <a href="https://github.com/ds300/patch-package">patch-package</a>.</p>

<a name="L5..Limitations.in.TypeScript.support"></a>
<h2>5) Limitations in TypeScript support</h2>

<p>It is important to note that you <em>may</em> run into a few cases that TypeScript’s Babel plugin does/can not support. From <a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-typescript/README.md#babelplugin-transform-typescript">the plugin’s README</a>:</p>

<blockquote><p>Does not support <code>namespace</code>s or <code>const enum</code>s because those require type information to transpile.
Also does not support <code>export =</code> and <code>import =</code>, because those cannot be transpiled to ES.next.</p></blockquote>

<p>The lack of namespace support hasn’t been a problem for us, we’re only using it in one place which could easily be changed to use regular ES6 modules as namespace. This is also why for instance the ‘recommended’ list of TSLint checks includes <a href="https://palantir.github.io/tslint/rules/no-namespace/">the <code>no-namespace</code> rule</a>.</p>

<p>The <code>const enum</code> feature is a runtime optimization that will cause the compiler to inline code. We don’t have a need for this at the moment, but <a href="https://github.com/babel/babel/issues/6476">some discussion</a> is happening to possibly still being able to make use of this feature when compiling production builds with the TypeScript compiler instead.</p>

<p>The <code>export =</code> and <code>import =</code> syntax is meant to <a href="https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Modules.md#export--and-import--require">work with CommonJS and AMD modules</a>; however, we strictly use ES6 modules.</p>

<p><strong>References:</strong></p>

<ul>
<li><a href="https://github.com/damassi/babel-7-typescript-example">babel-7-typescript-example</a></li>
<li><a href="https://github.com/babel/babel/tree/master/packages/babel-preset-typescript">babel-preset-typescript</a></li>
<li><a href="https://github.com/artsy/emission">emission</a></li>
<li><a href="https://github.com/artsy/reaction">reaction</a></li>
<li><a href="https://github.com/ds300/patch-package">patch-package</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modernizing Force]]></title>
    <link href="http://artsy.github.io/blog/2017/09/05/Modernizing-Force/"/>
    <updated>2017-09-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/09/05/Modernizing-Force</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/artsy/force">Force</a> is Artsy's main website, <a href="https://www.artsy.net">artsy.net</a>. In the three years since it was <a href="http://artsy.github.io/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">open-sourced</a>, it has provided a solid foundation to build features on top of without a lot of the costs associated with growth. It is an early example of Isomorphic ("universal") JavaScript, built on top of Express, Backbone, CoffeeScript, Stylus and Jade. It is also highly modular, adopting patterns laid down by its parent project,  <a href="https://github.com/artsy/ezel">Ezel</a>.</p>

<p>When first developed these technologies made a lot of sense; CoffeeScript fixed many of the problems with JavaScript pre-ES6, and Jade / Stylus made working with HTML / CSS much more elegant. As time progressed and new technologies became a thing these solutions starting feeling more burdensome to continue building features with and many of our developers longed to start using next-generation tools like React.</p>

<!-- more -->


<p>Looking at output from <code>cloc</code>, the question is "But how?"</p>

<pre><code class="js">[artsy/force] $ cloc desktop mobile

--------------------------------------------------------
Language                     files                  code
--------------------------------------------------------
CoffeeScript                  1828                 81569
CSS                              9                 76632
Stylus                         577                 32324
JavaScript                     274                 18310
JSON                            30                  6145
Markdown                        41                  1097
HTML                             3                    25
XML                              3                    24
--------------------------------------------------------
SUM:                          2765                216126
--------------------------------------------------------
</code></pre>

<p>216k+ LOC, spread across multiple languages and formats. Given finite resources and a small team rebuilds can be difficult to execute, and so we had to figure out a way to marry the old with the new while also maintaining backwards compatibility / interoperability. Out of this exercise came a few patterns, libraries and projects that I would like to describe in an effort to help those caught in similar situations.</p>

<a name="Step.1:.Get.Your.House..aka.Compiler..in.Order"></a>
<h2>Step 1: Get Your House (aka Compiler) in Order</h2>

<p><a href="https://babeljs.io/">Babel</a> has been around for a while, but lately their team has been putting effort into making it as easy as possible to use. By dropping a <a href="https://github.com/artsy/force/blob/master/.babelrc">.babelrc</a> file into the root of your project, server and client-side JavaScript can share the same configuration, including <a href="https://github.com/tleunen/babel-plugin-module-resolver">module resolution</a> (aka, no more <code>../../../</code>).</p>

<p>A simplified example:</p>

<pre><code class="json">// .babelrc

{
  "presets": ["es2015", "react", "stage-3"],
  "plugins": [
    ["module-resolver", {
      "root": ["./"]
    }]
  ]
}
</code></pre>

<pre><code class="js">// index.js

require('coffee-script/register')
require('babel-core/register')

// Start the app
require('./boot')
</code></pre>

<p>On the client, we use <a href="http://browserify.org/">Browserify</a> with <a href="https://github.com/substack/coffeeify">Coffeeify</a> and <a href="https://github.com/babel/babelify">Babelify</a>:</p>

<pre><code class="json">// package.json

{
  "scripts": {
    "assets": "browserify -t babelify -t coffeeify -o bundle.js",
    "start": "yarn assets &amp;&amp; node index.js"
  }
}
</code></pre>

<p>And then boot it up:
<code>sh
$ yarn start
</code></p>

<p>By adding just a few lines, our existing CoffeeScript pipeline was augmented to support modern JavaScript on both the server and the client, with code that can be shared between.</p>

<a name="Step.2:.Tune-up.Iteration.Time"></a>
<h2>Step 2: Tune-up Iteration Time</h2>

<p><a name="iteration-time"></a></p>

<p>A question that every developer should ask of their stack is:</p>

<blockquote><p>"How long does it take for me to make a change and see that change reflected in a running process?"</p></blockquote>

<p>Does your code take one second to compile, or ten? When writing a back-end service, does your server <a href="https://github.com/remy/nodemon">automatically restart</a> after you make a change, or do you need to <code>ctrl+c</code> (stop it) and then restart manually?</p>

<p>For those of us working in Force, the bottleneck typically involved making changes to back-end code. Due to how we organize our sub-apps, client-side code compilation -- after the server heats up -- is pretty much instant, but that heat-up time can often take a while depending on which app we're working on. So even with a "restart on code change" setup that listens for updates it still felt terribly slow, and this iteration time would often discourage developers from touching certain areas of the codebase. We needed something better!</p>

<p>Enter Webpack and React, which helped popularize the concept of HMR, or "Hot Module Replacement".</p>

<p>From the Webpack docs:</p>

<blockquote><p>"Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload."</p></blockquote>

<p>That's more like it! But is there anything similar for the server given we don't use Webpack? This was the question <a href="https://github.com/alloy">@alloy</a>, one of our Engineering Leads, asked himself while researching various setups that ultimately led to <a href="https://github.com/artsy/reaction">Reaction</a>, and for which he found an answer to in Glen Mailer's excellent <a href="https://github.com/glenjamin/ultimate-hot-reloading-example">ultimate-hot-reloading-example</a>. Digging into the code, <a href="https://github.com/glenjamin/ultimate-hot-reloading-example/blob/master/server.js#L38-L45">this little snippet</a> jumped out:</p>

<pre><code class="js">watcher.on('ready', function() {
  watcher.on('all', function() {
    console.log("Clearing /server/ module cache from server");
    Object.keys(require.cache).forEach(function(id) {
      if (/[\/\\]server[\/\\]/.test(id)) delete require.cache[id];
    });
  });
});
</code></pre>

<p>The code seemed simple enough -- on change, iterate through Node.js's internal require cache, look for the changed module, and clear it out. When the module is <code>require</code>'d at a later point it will be like it was required for the first time, effectively hot-swapping out the code.</p>

<p>With this knowledge we wrapped a modified version of this snippet into <a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a>, a small utility package meant to be used with Express.</p>

<p>Here's a full example:</p>

<pre><code class="js">import express from 'express'
import { createReloadable, isDevelopment } from '@artsy/express-reloadable'

const app = express()

if (isDevelopment) {

  // Pass in app and current `require` context
  const reloadAndMount = createReloadable(app, require)

  // Note that if you need to mount an app at a particular root (`/api`), pass
  // in `mountPoint` as an option.
  app.use('/api', reloadAndMount(path.resolve(__dirname, 'api'), {
    mountPoint: '/api'
  }))

  // Otherwise, just pass in the path to the express app and everything is taken care of
  reloadAndMount(path.resolve(__dirname, 'client'))
} else {
  app.use('/api', require('./api')
  app.use(require('./client')
}

app.listen(3000, () =&gt; {
  console.log(`Listening on port 3000`)
})
</code></pre>

<p>In Force, we mounted this library <a href="https://github.com/artsy/force/blob/master/lib/setup.js#L205">at the root</a>, allowing us to make changes anywhere within our numerous sub-apps and with a fresh page reload instantly see those changes reflected without a restart. This approach also works great with API servers, as this implementation from Artsy's <a href="https://github.com/artsy/positron/blob/master/boot.js#L34">editorial app Positron</a> shows. Like magic, it "just works". Why isn't this trick more widely used and known?</p>

<a name="Step.3:.The.View.Layer..or:.How.I.Stopped.Worrying.and.Learned.to.Love.Legacy.UI"></a>
<h2>Step 3: The View Layer, or: How I Stopped Worrying and Learned to Love Legacy UI</h2>

<p>This one was a bit tricky to solve, but ultimately ended up being fairly straightforward and conceptually simple. In Force, we've got dozens of apps built on top of hundreds of components supported by thousands of tests stretched across desktop and mobile. From the perspective of sheer code volume these things aren't going anywhere any time soon. On top of that, our view templates are built using Jade (now known as <a href="https://pugjs.org">Pug</a>), which supports an interesting form of inheritance known as <a href="https://pugjs.org/language/inheritance.html">blocks</a>. What this means in practice is our UI has been extended in a variety of complex ways making alternative view engines difficult on the surface to interpolate.</p>

<p>What to do? It's 2017 and the era of handlebars templates bound to Backbone MVC views is over. We want <a href="https://facebook.github.io/react/">React</a>! We want <a href="https://www.styled-components.com/">Styled Components</a>! And when those tools are surpassed by the Next Big Thing we want that too! But we also want our existing CoffeeScript and Jade and old-school <code>Backbone.View</code>s as well.</p>

<p>Thinking through this problem, <a href="https://github.com/artsy/stitch">@artsy/stitch</a> was born.</p>

<p>Stitch helps your Template and Component dependencies peacefully co-exist. You feed it a layout and some data and out pops a string of compiled html that can be passed down to the client. "Blocks" can be added that represent portions of UI, injected by key. It aims for maximum flexibility: templating engines supported by <a href="https://github.com/tj/consolidate.js">consolidate</a> can be installed and custom rendering engines <a href="https://github.com/artsy/stitch#custom-renderers">can be swapped out or extended</a>. With very little setup it unlocks UI configurations that have been lost to time.</p>

<p>A basic example:</p>

<p>
```html</p>

<div>
  {{title}}
</div>


<pre><code>
</code></pre>

<p>const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello!'
  }
})</p>

<p>console.log(html)</p>

<p>// => Outputs:
/*</p>

<div>
  Hello!
</div>


<p>*/
```</p>

<p>By adding "blocks" you can begin assembling (or adapting to) more complex layouts. Blocks represent either a path to a template or a component (with "component" meaning a React or <a href="https://preactjs.com">React-like</a> function / class component):</p>

<p>
```html
// templates/layout.handlebars</p>

<p><html>
  <head>
    <title>
      {{title}}
    </title>
  </head>
  <body
    {{{body}}}
  </body>
</html>
```
</p>

<pre><code class="js">// index.js

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello World!',
  },
  blocks: {
    body: (props) =&gt; {
      return (
        &lt;h1&gt;
          {props.title}
        &lt;/h1&gt;
      )
    }
  }
})

console.log(html)

// =&gt; Outputs:
/*
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;
      Hello World!
    &lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
*/
</code></pre>

<p>In Force, we're using this pattern to incrementally migrate portions of our app over to React, by taking existing block-based Jade layouts and injecting <code>ReactDOM.renderToString</code> output into them, and then rendering the layout into an HTML string that is passed down from the server and rehydrated on the client, isomorphically.</p>

<p>Our existing Backbone views take advantage of the <code>templates</code> key:</p>

<pre><code class="js">// server.js

import LoginApp from 'apps/login/LoginApp'
import { Provider } from 'react-redux'
import { StaticRouter } from 'react-router'

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Login / Sign-up',
  },
  templates: {
    login: 'templates/login.jade'
  },
  blocks: {
    app: (props) =&gt; (
      &lt;Provider store={store}&gt;
        &lt;StaticRouter&gt;
          &lt;LoginApp {...props} /&gt;
        &lt;/StaticRouter&gt;
      &lt;/Provider&gt;
    )
  }
})

res.send(html)
</code></pre>

<p>Similar to blocks, templates located in this object are pre-compiled and available to your components as <code>props.templates</code>.</p>

<p>Once the html has been sent over the wire, we mount it like so:</p>

<pre><code class="js">// client.js

import LoginApp from 'apps/login/LoginApp'

React.render(
  &lt;LoginApp {...window.__BOOTSTRAP__} /&gt; // Data passed down from `data` key
)
</code></pre>

<pre><code class="js">// apps/login/LoginApp.js

import React from 'react'
import Login from 'apps/login/Login'

export default function LoginApp (props) {
  const {
    templates: {
      login
    }
  } = props

  return (
    &lt;Login
      template={login}
    /&gt;
  )
}
</code></pre>

<p>During the server-side render phase existing template code will be rendered with the component, and once the component is mounted on the client <code>componentDidMount</code> will fire and the Backbone view instantiated:</p>

<p>
```js
// apps/login/Login.js</p>

<p>import React, { Component } from 'react'
import LoginBackboneView from 'apps/login/views/LoginView'</p>

<p>export default class Login extends Component {
  componentDidMount () {
    this.loginView = new LoginBackboneView()
    this.loginView.render()
  }</p>

<p>  componentWillUnmount () {
    this.loginView.remove()
  }</p>

<p>  render () {
    return (
      <div>
        <div dangerouslySetInnerHtml={{
          __html: this.props.template
        }}>
      </div>
    )
  }
}
```
</p>

<p>All of the possibilities that Stitch provides are too numerous to go over here, but check out the <a href="https://github.com/artsy/stitch#usage">documentation</a> and <a href="https://github.com/artsy/stitch/tree/master/examples">example apps</a> for more complete usage. While new, this pattern has worked quite well for us and has allowed Force to evolve alongside existing code with very little friction.</p>

<a name="Moving.Forward"></a>
<h2>Moving Forward</h2>

<p>A common thread that connects <a href="https://github.com/artsy/force">Force</a> to <a href="https://github.com/artsy/eigen">Eigen</a> (Artsy's mobile app) is an understanding that while grand re-writes will gladly remove technical debt, technical debt is not our issue. A lot of the patterns we've laid down within our apps still work for us, and many of our implementations remain sufficient to the task. What we needed was an environment where <em>incremental revolution</em> was possible, where old ideas could merge with new and evolve. In terms of Eigen, we felt the best way forward was the adoption of <a href="https://facebook.github.io/react-native/">React Native</a> -- and <a href="https://github.com/artsy/emission">Emission</a> was born. Likewise, for our web and web-based mobile apps, <a href="https://github.com/artsy/reaction">Reaction</a> is serving a similar role. Both of these projects are built with <a href="https://www.typescriptlang.org/">TypeScript</a>, and both rely heavily on functionality that our <a href="http://graphql.org/">GraphQL</a> interface <a href="https://github.com/artsy/metaphysics">Metaphysics</a> provides. But crucially, these projects <em>augment</em> our existing infrastructure; they don't replace it. They fit in with existing ideas, tools and processes that have facilitated Artsy's growth, including highly-specific domain knowledge that our engineers have built up over time.</p>

<p>In conclusion, I hope this post has provided a bit of a window into some of our processes here at Artsy for those facing similar challenges. If you want to take a deeper dive, check out the links below:</p>

<ul>
<li><a href="https://github.com/artsy/express-reloadable">express-reloadable</a></li>
<li><a href="https://github.com/artsy/stitch">stitch</a></li>
<li><a href="https://github.com/artsy/reaction">reaction</a></li>
<li><a href="https://github.com/artsy/emission">emission</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
