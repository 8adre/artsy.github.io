<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2017-01-05T20:03:53+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Glossary for 2017]]></title>
    <link href="http://artsy.github.io/blog/2016/11/14/JS-Glossary/"/>
    <updated>2016-11-14T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/11/14/JS-Glossary</id>
    <content type="html"><![CDATA[<p>Getting to grips with the entire JavaScript ecosystem is a tough job when you're getting started. Coming from the native mobile space, there's a lot to learn. I've spent a few months immersed in the environment now, and can try summerize a lot of topics. This should make it easier to find more information when you need it. This post is semi-opinionated, with links for further reading so you can get a different perspective too.</p>

<p>This post focus specifically on the JavaScript tooling around React Native projects, but is applicable to all JavaScript projects.</p>

<!-- more -->


<p>Lets start with the entire reason we are using JavaScript for mobile in the first place: React and React Native,</p>

<a name="React"></a>
<h1>React</h1>

<a name="React"></a>
<h3>React</h3>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to all of their views and then React would handle finding the differences between view states.</p>

<p>Its model is that you would create a set of Components to encapsulate each part for the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up,here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less <a href="#state">state</a>.</p>

<a name="React.Native"></a>
<h3>React Native</h3>

<p>I came to this conclusion early this year that writing native apps using compiled code is a pain, and it's been amazing to be able to work in React Native in contrast.</p>

<p>React Native is an implementation of React where instead of having it abstract a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a UIView hierarchy. Note that it does not handle View Controllers. The MVC model from Apple's Cocoa framework does not directly map into React Natives. I've wrote about how we <a href="http://artsy.github.io/blog/2016/08/24/On-Emission/">bridge that gap earlier</a>.</p>

<p>React Native is cross platform. You write JavaScript like above, which React Native transforms into a native view hierarchy. That view hierarchy could be on a Samsung TV, a Windows phone or Android instead.</p>

<p>It's a smart move, most "Make apps in JS" try to have a native-like experience where they replicate the platform's UI in HTML. However, this technique tends to feel unnatural very easily. If I showed you our app, you could not distinguish between a view controller in React Native, Swift or Objective-C.</p>

<a name="App.State"></a>
<h3>App State</h3>

<p>Think of every variable inside your application, that is your application's state. You could not make an app worth using without state. In MVC, MVVM, VIPER and other native patterns, there is no consistent way to handle changes in those variables. React uses a common state pattern though the use of specific terminology: "<a href="#props">props</a>", "<a href="#context">context</a>" and "<a href="#state-again">state</a>".</p>

<p>Yes, the "state" and "state" thing is a little confusing, we'll get to it.</p>

<a name="Props"></a>
<h3>Props</h3>

<p>Props are chunks of app state that are passed into your component from a parent component. In <a href="#jsx">JSX</a> this is represented as an XML attribute.</p>

<p>Let's check out <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/header.js">an example</a>:</p>

<pre><code class="js">export default class Header extends React.Component {
  [...]
  render() {
    return (
        &lt;View style={styles.followButton}&gt;
            &lt;InvertedButton text={this.state.following ? 'Following' : 'Follow'}
                            selected={this.state.following}
                            onPress={this.handleFollowChange} /&gt;
        &lt;/View&gt;
    )
  }
}
</code></pre>

<p>See the <code>InvertedButton</code> component, it has three <code>props</code> being passed in: <code>text</code>, <code>selected</code> and <code>onPress</code>. If any of those props were to change the entire <code>InvertedButton</code> component would be re-rendered to the native view hierarchy. These <code>props</code> are the key to passing data downwards through your hierarchy. Note: you cannot access the parent component (without passing it in as a prop.)</p>

<p>You should therefore consider <code>props</code> as immutable bits of app state relevant to the component it's being passed into.</p>

<a name="State-again"></a>
<h3>State-again</h3>

<p>A component also has a <code>state</code> attribute. The key to understanding the difference between <code>props</code> and <code>state</code> is: <code>state</code> is something controlled within that component that can change - <code>props</code> do not.</p>

<p>The above example is a pretty good example of this, when this component is first added to the hierarchy, we send a networking request to get whether you are following something or not. The parent component (<code>Header</code>) does not need to update when we know whether you are following or not, but the <code>InvertedButton</code> does. So, it is <code>state</code> for the parent, but a <code>prop</code> for the <code>InvertedButton</code>. This means changing the state for <code>following</code> will only cause a re-render in the button.</p>

<p>So state is something which changes within a component, which <em>could</em> be used as <code>props</code> for it's children. Examples of this are around handling animation progress, whether you're following something, selection indices and any kind of networking which we do outside of <a href="#relay">Relay</a>.</p>

<p>If you'd like to read more, there is a much deeper explanation in <a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md#props-vs-state">uberVU/react-guide</a></p>

<a name="Context"></a>
<h3>Context</h3>

<p><a href="https://facebook.github.io/react/docs/context.html">The docs</a> are pretty specific about context:</p>

<blockquote><p>If you aren't an experienced React developer, don't use context. There is usually a better way to implement functionality just using props and state.</p></blockquote>

<p>Seems to be something that you should only be using in really, really specific places. If you need it, you don't need this glossary.</p>

<a name="JSX"></a>
<h3>JSX</h3>

<p>As we'll find out later, modern JavaScript is a collection of different ideas, and using <a href="#babel">Babel</a> - you can add them at will into your projects. JSX is one such feature, it is a way of describing nested data using XML-like syntax. These are used inside React's render function to express a component's children and their <a href="#props">props</a>.</p>

<p>Under the hood, JSX is quite simple, with code looking like this:</p>

<pre><code class="js">const element = (
  &lt;h1 className="greeting"&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre>

<p>Turning into</p>

<pre><code class="js">const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
</code></pre>

<p>Where <code>createElement</code> comes from the React <a href="#module">module</a>. You can find out more in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">the React docs</a></p>

<a name="Libraries"></a>
<h1>Libraries</h1>

<a name="GraphQL"></a>
<h3>GraphQL</h3>

<p>TLDR: An API format for requesting only the data you want, and getting back just that.</p>

<p>If you want the longer explanation, I wrote a <a href="/blog/2016/06/19/graphql-for-mobile/">blog post on it</a>.</p>

<a name="Relay"></a>
<h3>Relay</h3>

<p>Relay is what makes working in our React Native app shine. It is a library that allows a component to describe small chunks of a networking request it would need to render. Relay would then look through your component hierarchy, take all the networking fragments, make a single GraphQL request for all the data. Once it has the data, Relay passes in the response as <a href="#props">props</a> to all of the components in the tree.</p>

<p>This means you can throw away a significant amount of glue code.</p>

<a name="Redux"></a>
<h3>Redux</h3>

<p>Redux is a state management pattern, it builds on top of React's "state is only passed down" concept, and creates a single way to handle triggering changes to your state. I'm afraid I don't have any experience with it, so I can't provide much context. I feel like <a href="http://www.youhavetolearncomputers.com/blog/2015/9/15/a-conceptual-overview-of-redux-or-how-i-fell-in-love-with-a-javascript-state-container">this post</a> covers it well though.</p>

<a name="Tooling"></a>
<h1>Tooling</h1>

<a name="Node"></a>
<h3>Node</h3>

<p>Node is the JavaScript implementation from Google's Chrome (called v8) with an expanded API for doing useful systems tooling. It is a pretty recent creation, so it started off with an entirely asynchronous API for any potentially blocking code.</p>

<p>For web developers this was a big boon, you could share code between the browser and the server. The non-blocking API meant it was much easier to write faster servers, and there are lots of big companies putting a lot of time and money into improving the speed of JavaScript every day.</p>

<p>Node has an interesting history of ownership, I won't cover it here, but <a href="http://anandmanisankar.com/posts/nodejs-iojs-why-the-fork/">this link</a> provides some context.</p>

<a name="NPM"></a>
<h3>NPM</h3>

<p>NPM is the Node Package Manager. It is shipped with node, but it is a completely different project and team. NPM the project is ran by a private company.</p>

<p>NPM is one of the first dependency managers to offer the ability to install multiple versions of the same library inside your app. This contributes considerably to the issue of the number of dependencies inside any app's ecosystem.</p>

<p>JavaScript people will always complain about NPM, but people will always complain about their build tools. Dependency Manager's especially. From an outsider's view, it nearly always does what you expect, has a great team behind it and has more available dependencies than any other.</p>

<p>NPM works with a <code>Package.json</code> file as the key file to represent all the different dependencies, version, authors and misc project metadata.</p>

<a name="Yarn"></a>
<h3>Yarn</h3>

<p>Yarn is a NPM replacement (ish) by Facebook. It's very new. It solves three problems, which were particularly annoying to me personally.</p>

<ul>
<li>It flattens dependencies - this means that you're less likely to have multiple versions of the same library in your app.</li>
<li>It uses a lockfile by default - this means that everyone on your team gets the same build, instead of maybe getting it.</li>
<li>It is significantly faster.</li>
</ul>


<p>It uses the NPM infrastructure for downloading <a href="#modules">modules</a>, and works with the exact same <code>Package.json</code>. I moved most of our projects to it.</p>

<a name="Babel"></a>
<h3>Babel</h3>

<p>I mentioned JSX a few times above. JSX is not a part of JavaScript, it is transpiled from your source code (as XML-like code) into real JavaScript. The tool that does this is Babel.</p>

<p>Babel is a generic JavaScript transpilation engine. It does not provide any translation by default, but instead offers a plugin system for others to hook in their own transpilation steps. This becomes important because a lot of JavaScript features have staggered releases between browsers and you can't always guarantee each JavaScript runtime will have the features you want to use.</p>

<p>Babel's plugins can be configured inside your <code>Package.json</code>. To ship your code to the world, you then create a script of some sort to convert your source code into "olde world" JavaScript via Babel.</p>

<p>In the case of a react-native project, Babel is happening behind the scenes.</p>

<a name="Webpack"></a>
<h3>Webpack</h3>

<p>A JavaScript source code &amp; resource package manager. It can be easy to confuse Babel + Webpack, so in simple:</p>

<ul>
<li>Babel will directly transform your source code file by file</li>
<li>Webpack will take source code and merge it all into one file</li>
</ul>


<p>They work at different scopes. Webpack is mainly a web front-end tool, and isn't used in React Native. However, you'll come across it, and it's better to know the scope of it's domain.</p>

<a name="ESLint"></a>
<h3>ESLint</h3>

<p>How can you be sure your syntax is correct? JavaScript has a really powerful and extensible linter called ESLint. It parses your JavaScript and offers warnings and errors around your syntax. You can use this to provide a consistent codebase, or in my case, to be lazy with your formatting. Fixing a lot of issues is one command away. I have <a href="https://artsy.github.io/blog/2016/08/15/vscode/">my editor</a> auto indent using ESLint every time I press save.</p>

<a name="Development"></a>
<h1>Development</h1>

<a name="Live.Reload"></a>
<h3>Live Reload</h3>

<p>This is a common feature in JavaScript tooling. If you press save in a source file then some action is taken. Live Reloading tends to be a more blunt action, for example reloading the current view from scratch, or running all of the tests related to the file.</p>

<a name="Hot-Reloading"></a>
<h3>Hot-Reloading</h3>

<p>Hot Reloading is more rare, because it's significantly harder. Hot Reloading for React projects is injecting new functions into the running application, and keeping it in the same state.</p>

<p>For example if you had a filled-in form on your screen, you could make styling changes inside your source file and the text inside the form would not change. Hot reloading is amazing.</p>

<a name="Haste.Map"></a>
<h3>Haste Map</h3>

<p>Part of what makes React Native support Hot Reloading, and allows <a href="#jest">Jest</a> to understand changes for testing is by using a Haste Map. A Haste Map is a dependency resolver for JavaScript, looking through every function to know how it connects to every other function within the JavaScript project.</p>

<p>With the dependencies mapped, it becomes possible to know what functions would need replacing or testing when you press save after writing some changes. This is why it takes a bit of time to start up a React Native project.</p>

<p>The public API is deprecated, you shouldn't use it in your projects, but the <a href="https://github.com/facebookarchive/node-haste/tree/master#node-haste-">old README is still around</a>.</p>

<a name="Testing"></a>
<h1>Testing</h1>

<a name="Jest"></a>
<h3>Jest</h3>

<p>Facebook have their own test runner called Jest. It builds on <a href="https://jasmine.github.io">Jasmine</a>, and offers a few features that kick ass for me:</p>

<ul>
<li>Re-runs failing tests first</li>
<li>Assumes all tests unrelated to changes are green and doesn't run them</li>
<li>Watch mode that works reliably</li>
</ul>


<p>I miss these features when I'm not in a Jest project.</p>

<a name="Jest.Snapshots"></a>
<h3>Jest Snapshots</h3>

<p>Jest has a feature called Jest Snapshots, that allows you to take "snapshots" of JavaScript objects, and then verify they are they are the same as they were last time. In iOS we <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">used visual snapshot</a> testing a lot.</p>

<a name="VSCode-Jest"></a>
<h3>VSCode-Jest</h3>

<p>I created a project to auto-run Jest inside projects that use it as a test runner when using Visual Studio Code: <a href="https://github.com/orta/vscode-jest">vscode-jest</a>. I've wrote about our usage of VS Code <a href="https://artsy.github.io/blog/2016/08/15/vscode/">on this blog series</a> also.</p>

<a name="JavaScript.the.Language"></a>
<h1>JavaScript the Language</h1>

<p>I'm always told that JavaScript was created in 10 days, which is a cute anecdote, but JavaScript has evolved for the next 21 years. The JavaScript you wrote 10 years ago would still run, however modern JavaScript is an amazing and expressive programming language once you start using modern features.</p>

<p>Sometimes these features aren't available in <a href="#node">node</a>, or your browser's JavaScript engine, you can work around this by using a transpiler, which takes your source code and backports the features you are using to an older version of JavaScript.</p>

<a name="ES6"></a>
<h3>ES6</h3>

<p>JavaScript is run by a committee. Around the time that people were starting to talk about HTML5 and CSS3, work was started on a new specification for JavaScript called ECMAScript 6.</p>

<p>ES6 represents the first point at which JavaScript really started to take a lot of the best features from transpile to JavaScript languages like CoffeeScript. Making it feasible for larger systems programming to be possible in vanilla JavaScript.</p>

<a name="ES2016"></a>
<h3>ES2016</h3>

<p>It took forever for <a href="#es6">ES6</a> to come out, and every time they created / amended a specification there were multiple implementations of the specification available for transpiling via <a href="#babel">babel</a>. This I can imagine was frustrating for developers wanting to use new features, and specification authors trying to put out documentation for discussion as a work in progress. This happened a lot <a href="#promises">with the Promises</a> API.</p>

<p>To fix this they opted to discuss specification features on a year basis. So that specifications could be smaller and more focused, instead of major multi-year projects. Quite a SemVer jump from 6 to 2016.</p>

<a name="Stages"></a>
<h3>Stages</h3>

<p>Turns out that didn't work out too well, so the terminology changed again. The change is mainly to set expectations between the Specification authors and developers transpiling those specifications into their apps.</p>

<p>Now an ECMAScript language improvement specification moves through a series of stages, depending on their maturity. I <a href="https://twitter.com/logicoder/status/799919558429736960">believe starting</a> at 0, and working up to 4. 0 Idea, 1 Proposal, 2 Draft, 3 Accepted and 4 Done.</p>

<p>So a ECMAScript Stage 0 feature is going to be really new, if you're using it via a transpiler then you should expect a lot of potential API changes and code churn. The higher the number, the longer the spec has been discussed, and the more likely for the code you're transpiling to be the vanilla JavaScript code in time.</p>

<p>The committee who discussed these improvements are the <a href="http://ecma-international.org/memento/TC39.htm">TC39</a> commitee, the cool bit is that you can see <a href="https://github.com/tc39">all the proposals</a> as individual GitHub repos so it's convient to browse.</p>

<a name="Modules...Imports"></a>
<h3>Modules / Imports</h3>

<p>A modules is the terminology for a group of JavaScript code. Terminology can get confusing, as the import structure for a library is very similar to importing a local file.</p>

<p>You can import a module using syntax like <code>import { thin, other } from "thingy"</code>. Here's some examples <a href="https://github.com/artsy/emission/blob/master/lib/components/artist/shows/show.js#L4-L9">from our project</a>:</p>

<pre><code class="js">// Import modules
import Relay from 'react-relay'
import React from 'react'
// Import two items from the react-native module 
import { View, TouchableWithoutFeedback } from 'react-native'

// Import the default class from a local file
import ImageView from '../../opaque_image_view'
import SwitchBoard from '../../../native_modules/switch_board'
</code></pre>

<p>An import can either have <a href="https://github.com/danger/danger-js/blob/61557ac7b6de37ef9a7e4a1aa0c0cbe0bd00977d/source/ci_source/Fake.js#L6">a default export</a>, or a set of <a href="https://github.com/artsy/Mitosis/blob/0c1d73055122bd61559df3b1a2913cf4e272b4ed/source/bot/artsy-api.js#L31-L94">exportable function/objects</a>.</p>

<p>You might see an import like <code>const _ = require("underscore")</code> around the internet, this is an older format for packaging JavaScript called <a href="https://www.wikiwand.com/en/CommonJS">CommonJS</a>. It was replaced by the <code>import</code> statements above because you can make guarantees about the individual items exported between module boundries. This is interesting because of <a href="#tree-shaking">tree-shaking</a>, which we'll get to later.</p>

<a name="Classes"></a>
<h3>Classes</h3>

<p>Modern JavaScript has classes introduced in <a href="#es6">es6</a>, this means that instead of writing something like:</p>

<pre><code class="js">const danger = {
  name: "Danger",
  hello: function () {
    console.log("Hi!")
  }
}

danger.hello();
</code></pre>

<p>Instead you could write:</p>

<pre><code class="js">class Person {
  constructor(name) {
    this.name = name
  }
  hello() {
    console.log("Hi!")
  }
}

const danger = new Person("danger")
danger.hello()
</code></pre>

<p>Classes provide the option of doing object-oriented programming, which is still a solid way to write code. Classes provide a simple tool for making interfaces, which is really useful when you're working to the <a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=5S2XB3C32NLP7IVQ">Gang of Four</a> principals:</p>

<blockquote><p>“Program to an interface, not an implementation,” and “favor object composition over class inheritance.”</p></blockquote>

<a name="Prototypical"></a>
<h3>Prototypical</h3>

<p>So, classes - it took 20ish years before they happened? Before that JavaScript was basically only a prototype-based language. This meant you created "objects" but that they were just effectively just key-value stores, and you used functions to do everything else.</p>

<p>The language is a great fit for functional programming, I ended up building <a href="https://github.com/artsy/Mitosis/">an Artsy chat bot</a> using only functions by accident. Really, a few days into it when I started looking for an example class to show in this post I realised I didn't have one. Whereas in Danger I do almost exclusive OOP in JavaScript, sometimes the project fits the paradigm too.</p>

<p>A really good, and highly opinionated post on the values of prototypical/functional programming in JavaScript is <a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.knm7xb7zr">The Two Pillars of JavaScript</a> - I agree with a lot of it.</p>

<a name="Mutablilty"></a>
<h3>Mutablilty</h3>

<p>JavaScript has had a keyword <code>var</code> to indicate a variable forever. You should basically never use this. I've never written one this year, except by accident. It's a keyword that has a really confusing scope, leading to odd bugs. <a href="#es6">ES6</a> brought two replacements, both of which will give you a little bit of cognitive dissonance if you have a lot of Swift experience.</p>

<p><code>let</code> - the replacement for <code>var</code>, this is a <em>mutable</em> variable, you can replace the value of a <code>let</code>. The scope of a <code>let</code> is exactly what you think from every other programming language.
<code>const</code> - this is a <code>let</code> that won't allow you to change the <em>value</em>. So it creates a mutable object (all JS objects are mutable) but you cannot replace the object from the initial assignment.</p>

<a name="This"></a>
<h3>This</h3>

<p>The keyword <code>this</code> is a tricky one. It is confusing because <code>this</code> gets assigned to the object that invokes the function where you use <code>this</code>.</p>

<p>It's confusing because you may have a function inside a class, and would expect <code>this</code> to be the instance to which the function is attached to, but it very easily could not be. For <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/articles/article.js#L11-L22">example</a>:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap() {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap}&gt;
</code></pre>

<p>In the above example <code>this</code> inside <code>handleTap</code> does not refer to the instance of Article. Tricky right?</p>

<p>There are two "easy" fixes, <a href="http://exploringjs.com/es6/ch_arrow-functions.html">using arrow functions</a> instead if normal functions:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap = () =&gt; {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }
  [...]
</code></pre>

<p>Or you can use the <code>bind</code> function to ensure that <code>this</code> inside the function is what you want it to be.</p>

<pre><code class="js">class Article extends React.Component {
  [...]

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
</code></pre>

<p>This is a great in-depth explanation of the way it works: <a href="https://toddmotto.com/understanding-the-this-keyword-in-javascript/">Understanding the “this” keyword in JavaScript</a>.</p>

<a name="Strict.Mode"></a>
<h3>Strict Mode</h3>

<p>Introduced in ECMAScript 5.1, it provides a way to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">opt-in to more errors</a> inside the JavaScript runtime. As you're likely to be using both a linter and a transpiler to keep your source clean, I'm less worried about including it on every page.</p>

<a name="Destructuring"></a>
<h3>Destructuring</h3>

<p>Object destructuring is one of those things that saves a little bit of code all the time. It's especially useful given the amount of time you spend passing around plain old JavaScript objects. This is something that CoffeeScript took from Ruby:</p>

<pre><code class="js">&gt; const [orta, danger] = [33, 23]
undefined
&gt; danger
23
&gt; orta
33
</code></pre>

<p>or for an Object</p>

<pre><code>&gt; const user = { name: "Danger", age: 27 }
undefined
&gt; const { name,  age }  = user
undefined
&gt; name
'Danger'
&gt; age
27
</code></pre>

<p>This makes it really easy to pull out subsets of existing objects and set them as variables.</p>

<a name="Arrow.Functions"></a>
<h3>Arrow Functions</h3>

<p>In JavaScript a function has always looked like:</p>

<pre><code class="js">function(arg1, arg2) {
  [...]
}
</code></pre>

<p>This gets frustrating when you're doing functional-style programming, where you use closures for mapping, filtering and others. So instead <a href="#es6">ES6</a> introduced terser ways of doing this. So I'm going to write the same function multiple times:</p>

<pre><code class="js">// The way it's always been
function (lhs, rhs) {
    return lhs.order &gt; rhs.order
}

// An arrow function version
(lhs, rhs) =&gt; {
    return lhs.order &gt; rhs.order
}

// An implicit return, and no braced one-liner arrow function
(lhs, rhs) =&gt; lhs.order &gt; rhs.order 
</code></pre>

<a name="Promises"></a>
<h3>Promises</h3>

<p><a href="#node">Node</a> is renowned for having a non-blocking API from day one. The way they worked around this is by using callbacks everywhere. This can work out pretty well, but eventually maintaining and controlling your callbacks turns into it's own problem. This can be extra tricky around handing errors.</p>

<p>One way to fix this is to have a Promise API, Promises offer consistent ways to handle errors wand callback chaining.</p>

<p>JavaScript now has a built-in a Promise API, this means every library can work to one API when handling any kind of asynchronous task. I'm not sure what ECMA Specification brought it in. This makes it really easy to make consistent code between libraries. However, more importantly, it makes it possible to have async/await.</p>

<a name="Async.Await"></a>
<h3>Async/Await</h3>

<p>Once Promises were in, then a language construct could be created for using them elegantly. They work by declaring the entire function to be an <code>async</code> function. An async function is a function which pretends to be synchronous, but behind the scenes is waiting for specific promises to resolve asynchronously.</p>

<p>There are a few rules for an <code>async</code> function:</p>

<ul>
<li>You cannot use <code>await</code> inside a function that has not been declared <code>async</code>.</li>
<li>Anything you do return will be implicitly wrapped in a Promise</li>
<li>Non-async functions can just handle the promise an <code>async</code> function returns</li>
</ul>


<p>So, a typical <code>async</code> function</p>

<pre><code class="js">  async getReviewInfo() : Promise&lt;any&gt; {              // this function will do async
    const details = await this.getPullRequestInfo()   // wait for the promise in getPullRequestInfo to resolve 
    return await details.json()                       // wait for the promise in json to resolve
  }                                                   // return the json
</code></pre>

<p>You aren't always given a promise to work with as not all APIs support promises and callbacks, wrapping a callback function is pretty simple:</p>

<pre><code class="js">  readFile(path: String): Promise&lt;string&gt; {                       // returns a promise with a string
    return new Promise((resolve: any, reject: any) =&gt; {           // create a new promise, with 2 callbacks
      fs.readFile(path, "utf8", (err: Error, data: string) =&gt; {   // do the work
        if (err) { return reject(err) }                           // did it fail? reject the promise
        resolve(data)                                             // did it pass? resolve the promise
      })
    })
  }
</code></pre>

<p>The <code>await</code> part of an <code>async</code> function using <code>await readFile</code> will now wait on the synchronous execution until the promise has resolved. This makes complicated code look very simple.</p>

<a name="Tree.Shaking"></a>
<h3>Tree Shaking</h3>

<p>All development ecosystems have trade-offs which shape their culture. For web developers reducing the amount of JavaScript they send to a client is an easy, and vital part of their day job. This started with minifying their source code, e.g. reducing the number of characters but having the same behavior.</p>

<p>The current state of the art is tree-shaking, wherein you can know what functions are unused and remove those from the source code before shipping the code to a client. A <a href="#haste-map">haste-map</a> is one way to handle these dependencies, but it's not the only one. <a href="http://rollupjs.org/">Rollup</a> is considered the de-facto ruler of the space, but it is in <a href="#babel">babel</a> and <a href="#babel">webpack</a> also.</p>

<p>Does this affect you if you're using React Native? Not really, but it's an interesting part of the ecosystem you should be aware of.</p>

<a name="Types"></a>
<h1>Types</h1>

<p>Types can provide an amazing developer experience, as an editor can understand the shape of all the object's inside your project. This can make it possible to build rich refactoring, static analysis or auto-complete experiences without relying on a runtime.</p>

<p>For JavaScript there are two main ways to use types. <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a>. Both are amazing choices for building non-trivial applications. IMO, these two projects are what makes JavaScript a real systems language.</p>

<p>Both take the approach of providing an optional typing system. This means you can choose to add types to existing applications bit by bit. By doing that you can easily add either to an existing project and progressively add types to unstructured data.</p>

<a name="Interfaces"></a>
<h3>Interfaces</h3>

<p>As both <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a> interact with JavaScript, the mindset for applying types is through Interfaces. This is very similar to protocol oriented programming, where you only care about the responsibilities  of an object - not the specific type. Here is a Flow interface from DangerJS:</p>

<pre><code class="js">/** An API representation for a Code Review site */
export interface Platform {
/** Mainly for logging and error reporting */
name: string;
/** Used internally for getting PR/Repo metadata */
ciSource: CISource;
/** Pulls in the Code Review Metadata for inspection */
getReviewInfo: () =&gt; Promise&lt;any&gt;;
/** Pulls in the Code Review Diff, and offers a succinct user-API for it */
getReviewDiff: () =&gt; Promise&lt;GitDSL&gt;;
/** Creates a comment on the PR */
createComment: (body: string) =&gt; Promise&lt;?Comment&gt;;
[...]
}
</code></pre>

<p>This interface defines the shape of an object, e.g. what functions/properties it will it have. Using interfaces means that you can expose the least amount of about an object, but you can be certain that if someone refactors the object and changes any interface properties - it provide errors.</p>

<a name="Flow"></a>
<h3>Flow</h3>

<p><a href="https://flowtype.org">Flow</a> is a fascinating tool that infers types through-out your codebase. Our React Native uses a lot of Flow, we have a lot of <a href="#eslint">linter rules</a> for it too, so instead of writing a function like:</p>

<pre><code class="js">function getPlatformForEnv(env, source) {
return [...]
}
</code></pre>

<p>We would write it like this:</p>

<pre><code class="js">function getPlatformForEnv(env: Env, source: CISource): ?Platform {
return [...]
}
</code></pre>

<p>Wherein we now have interfaces for our arguments and the return value of the function. This means better error message from Flow, and better auto-complete in your editor.</p>

<a name="TypeScript"></a>
<h3>TypeScript</h3>

<p>TypeScript is a typed language that compiles JavaScript by Microsoft. It's awesome, it has all of the advantages that I talked about with Flow and a lot more. With TypeScript you can get a much more consistent build environment (you are not picking and choosing different features of ES6) as Microsoft implement all of it into TypeScript.</p>

<p>We opted to go for JS + Flow for Artsy's React Native mainly because we could incrementally add types, and you can find a lot more examples of JavaScript on the internet. It also is the way in which React Native is built, so you get the ecosystem advantage.</p>

<p>That said, if we start a new React Native from scratch project, I would pitch that we should use TypeScript after my experiences with <a href="https://github.com/Microsoft/vscode/pull/12628">making PRs</a> to VS Code. TypeScript feels more comprehensive, I got better error messages and VS Code is very well optimised for working in TypeScript projects.</p>

<a name="Typings.Flow-Typed"></a>
<h3>Typings/Flow-Typed</h3>

<p>Shockingly, not all JavaScript <a href="#modules">modules</a> ship with a typed interface for others. This makes it a pain to work with any code outside your perfectly crafted/typed codebase. This isn't optimal, especially in JavaScript where you rely on so many external libraries.</p>

<p>Meaning that you can either look up the function definitions in their individual docs, or you can read through the source. This breaks your programming flow.</p>

<p>Both TypeScript and Flow offer a tool to provide external definitions for their libraries. For typescript that is <a href="https://github.com/typings/typings">typings</a> and for Flow, <a href="https://github.com/flowtype/flow-typed/">flow-typed</a>. These tools pull into your project definition files that tell TypeScript/Flow what each module's input/outputs are shaped like, and provides inline documentation for them.</p>

<p>Flow-Typed is new, so it's not really got many definitions at all. Typings on the other hand has quite a lot, so in our React Native we use typings to get auto-complete for our libraries.</p>

<hr />

<p>So that's my glossary, there's a lot of interesting projects out in the JS world.</p>

<p>They have a term "<a href="http://www.confluentforms.com/2016/01/javascript-churn-technology-investment-effect.html">JavaScript fatigue</a>" which represents the concept of the churn in choosing and learning from so many projects. This is very real, which is something we're taking into account. Given the amount of flexibility in the ecosystem, it's really easy to create anything you want. If I wanted to implement a simplified version of Swift's guard function for our JavaScript, I could probably do it in about 2 days using a Babel plugin, then we can opt-in on any project we want.</p>

<p>This can make it easy to freeze and flip the table, but it also makes JavaScript a weird, kind of ideal, primordial soup where some <em>extremely</em> interesting ideas come out. It's your job to use your smarts to decide which are the ideas which will evolve further, then help them stablize and mature.</p>

<script>
// Ain't optimal, but it does it for now, need to figure a better way in the future.
$("a[name]").each(function(i, el){
  var $el = $(el)
  $el.attr("name", $el.attr("name").toLowerCase().replace(".", "-"))
})
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improving Page Speed with GraphQL]]></title>
    <link href="http://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql/"/>
    <updated>2016-11-02T14:21:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql</id>
    <content type="html"><![CDATA[<p>This past year, our team started using a GraphQL orchestration layer that connects various APIs with multiple front-end apps including <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile">iOS</a>. It also handles caching and extracts some business logic out of our client apps. This helped us not only to be more consistent with the way we fetch data across apps, but also improved developer happiness and even bridged teams by having our web and iOS developers work with the same API layer. This got me thinking what other problems GraphQL could solve at Artsy.</p>

<p>I work on the Publishing Team at Artsy, and we've recently been focused on page speed as a KPI. With so many ways of measuring speed, it's a daunting task but for this post, I'll focus on the way we handled things on the server-side and how integrating GraphQL on our API improved page speed.</p>

<!-- more -->


<a name="Prior.to.GraphQL"></a>
<h2>Prior to GraphQL</h2>

<p>In our publishing CMS called <a href="http://github.com/artsy/positron">Positron</a>, we serve a separate API, database, and front-end from the rest of the Artsy stack. We're also responsible for the delivery and presentation of the content itself. Over the past year we've focused a lot on how the content appears, and now we've opened up time to focus on speed since in the land of content, every second counts.</p>

<p>Before we went ahead with adding a GraphQL-based endpoint to Positron, I spent about a week and refactoring our current codebase. We refactored our router code to make less fetches, made better use of caching, and moved some below-the-fold rendering into the client side. These are important steps towards a faster page, but it doesn't push our technology in a direction that lets us reimagine things.</p>

<a name="Speed.Issues"></a>
<h2>Speed Issues</h2>

<p>We split the speed problem in two: <code>Server Response Time</code> (server-side) and <code>Document Interactive Time</code> (client-side). We currently use Google Analytics to track these <a href="https://support.google.com/analytics/answer/2383341?hl=en">metrics</a>. There are some inaccuracies with GA such as small sampling, geographic noise (countries with different download speeds), and timeouts being counted as zero, but for our initial testing this will suffice for relative measuring.</p>

<a name="Enter.GraphQL.and.JoiQL"></a>
<h2>Enter GraphQL and JoiQL</h2>

<p>Our very own <a href="https://twitter.com/craigspaeth">Craig Spaeth</a> recently started working on a project called <a href="https://github.com/muraljs/mural">Mural</a>. It's a framework for React and GraphQL. One library that came out of this project is called <a href="http://github.com/muraljs/joiql">JoiQL</a>. It's a The main purpose of JoiQL is to convert <a href="http://github.com/hapijs/joi">Joi</a> schemas into GraphQL schemas.</p>

<p>We already use Joi in Positron so creating a GraphQL-based endpoint was trivial with JoiQL. Note that while JoiQL is currently used in production, it's still a beta project! Below is an example of how the JoiQL setup works.</p>

<pre><code class="javascript">const joiql = require('../')
const { object, string, number, array, date } = require('joi')
const app = require('express')()
const graphqlHTTP = require('express-graphql')

// Given a Joi schema:
const Article = object({
  title: string(),
  body: string(),
  published_at: date()
}).meta({
  args: { id: number().required() }
})

// Define api with JoiQL like this:
const api = joiql({
  query: {
    article: Article
  }
})

// Resolve the request using a Koa 2 style middleware pattern:
api.use((ctx, next) =&gt; {
  return new Promise (resolve, reject) -&gt;
    // Method that fetches an article based on the query
    findArticle(ctx.req.query.article.args), (err, results) -&gt;
      ctx.res.article = results.article
      next()
      resolve()
})

// Finally, mount our schema to express:
app.use('/graphql', graphqlHTTP({
  schema: api.schema,
  graphiql: true
}))
app.listen(3000, () =&gt; console.log('listening on 3000'))
</code></pre>

<p>You can see how simple it becomes to convert apps that already use Joi with JoiQL. Joi provides a nice API for building GraphQL schemas with minimal boilerplate and we also get a nice Koa 2 style middleware pattern that lets us hook into a downstream/upstream flow. This downstream/upstream flow could be useful later on if we were to get really granular with measuring speed. For instance, if we decide to track the speed of the whole lifecycle of a request, we could do something like this:</p>

<pre><code class="javascript">api.use((ctx, next) =&gt; {
  startTIme = Date.now()
  next()
  console.log(Date.now() - startTime)
}

api.use((ctx, next) =&gt; {
  // fetch content here
  next() #we get bumped back up after this
})
</code></pre>

<a name="Results"></a>
<h2>Results</h2>

<p>The two features of GraphQL that have been helpful for reducing page speed are:
1. Reduced payload because you only request the data you need
2. Multiple fetches can be coalesced into a single request</p>

<p>Not surprisingly, decreased payload and coalesced requests are the same two features <a href="http://twitter.com/orta">Orta</a> describes in part of his post on the killer features of <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile">GraphQL for Mobile</a>.</p>

<a name="Reduced.Payload"></a>
<h3>Reduced Payload</h3>

<p>Reduced payload turned out to be one of the biggest factors in reducing speed. Just after October 27 we switched over to using GraphQL on our <a href="http://m.artsy.net/articles">mobile articles landing page</a>.</p>

<p></div></div><a href='/images/2016-11-02-improving-page-speed-with-graphql/download_time.png'><img src="/images/2016-11-02-improving-page-speed-with-graphql/download_time.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Since we were previously getting back collection of articles with all of its content, rendering a simple page with a list of articles meant the payload size was unnecessarily huge. Now, we only request a few things like the title and image without having to do any extra work. This is especially important for mobile devices where we encounter slow network speeds!</p>

<a name="Multiple.fetches"></a>
<h3>Multiple fetches</h3>

<p>Although we haven't made use of this in production yet, I anticipate that the ability to coalesce requests will be significant. For example, to render an article page, there are up to five fetches that can be requested by our front-end app with a normal REST API. Now, we can combine the requests to a single fetch, which moves the responsibility of coalescing requests from aggregating slow HTTP requests to fanning out fast database queries. If we aggregate the request and cache the response using a client like <a href="https://github.com/kadirahq/lokka">Lokka</a>, our future looks bright.</p>

<a name="What.s.next."></a>
<h2>What's next?</h2>

<p>Besides making use of this new endpoint on all the things, I think the next big win with GraphQL is to add <a href="http://graphql.org/learn/queries/#mutations">mutations</a>. By adding support for mutations, we can modify our data with GraphQL just as simply as we can query it.</p>

<p>We currently use a combination of Backbone and React to edit articles on our front-end CMS. After we move our CMS's data platform to GraphQL, we can move away from frameworks like Backbone and towards managing state containers like Redux which are made to work with GraphQL. Features like revision history and undo events would feel natural with state containers like Redux and a joy for our editors!</p>

<p>In the context of speed, some other topics I look forward to exploring are optimizing expensive database queries and client-side asset compression.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Helping the Web Towards OSS by Default]]></title>
    <link href="http://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default/"/>
    <updated>2016-09-06T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default</id>
    <content type="html"><![CDATA[<p>The main Artsy.net website for the desktop, <a href="https://github.com/artsy/force">Force</a>, was our first Artsy application to open its source code, <a href="http://artsy.github.io/author/craig">Craig</a> and <a href="http://artsy.github.io/author/brennan">Brennan</a> did it <a href="/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">back in 2014</a>. Force's public offering laid the groundwork for the iOS OSS projects to come afterwards: <a href="/blog/2014/11/13/eidolon-retrospective/">Eidolon</a>, <a href="/blog/2015/04/28/how-we-open-sourced-eigen/">Eigen</a>, <a href="/blog/2015/08/06/open-sourcing-energy/">Energy</a> and <a href="/blog/2015/11/05/Emergence-Code-Review/">Emergence</a>.</p>

<p>Though Force wasn't quite Open Source by Default, it represented a <em>really</em> important step for  Artsy's OSS perspective but was not the end goal. We were opening our source, but not opening our process.</p>

<p>This month both <a href="https://github.com/artsy/force">Force</a>, the desktop version of <a href="https://www.artsy.net/">Artsy.net</a> and <a href="https://github.com/artsy/microgravity">Microgravity</a>, the mobile version - moved to being built entirely in the open. Read on to find out how.</p>

<!-- more -->


<a name="Force"></a>
<h2>Force</h2>

<p>Over the course of the last month, I've sat on and off with Charles "<a href="http://charlesbroskoski.com/_/">Cab</a>" Broskoski, and figured out what it would take to migrate Force to work in the public. Previous to this, work happened on a private repo, and we would push that code to the public.</p>

<p>We scoped out what it would require, creating an issue that summarized the work. Then we waited for 2 weeks, to give people the chance to discuss the idea and to offer examples for why we should delay or not move. Not all projects <em>should</em> be OSS, and everyone should have a say when it affects them - giving some time let the team speak their mind. Especially during summer, when people were less active at work.</p>

<p></div></div><a href='/images/oss-milestone/force-oss.png'><img src="/images/oss-milestone/force-oss.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It had been 9 months since the last commit to the public repo, and so auditing the commits was a matter of investigating into configuration files, and seeing what's changed since the last public commit.</p>

<p>Next up, we renamed the current <code>force</code> repo to <code>force-private</code>. This was to keep the old issues and PRs around after we moved to working in the public. With <code>force</code> now available we re-named the already public project.</p>

<p>We then ensured all outstanding PRs were merged or closed, and pushed the commits from <code>force-private</code> to the now OSS <code>force</code>.</p>

<a name="CI"></a>
<h3>CI</h3>

<p>To get back up to speed we needed to set up CI, figuring this out took time.</p>

<p>We got testing up and running in no time. However, Force is deployed via <a href="https://semaphoreci.com/">Semaphore CI</a>, and to deploy we needed to push compiled assets to S3. To pull that off, we needed access to an S3 key, and token.</p>

<p>In our iOS projects, <a href="https://github.com/artsy/eidolon/pull/607">we do not expose environment variables</a> to PRs from forks, so we don't expect them to pass from external contributors. This is fine, because we have <a href="http://artsy.github.io/blog/2016/01/13/OSS-Expectations/">different expectations</a> for OSS apps vs libraries. We do this to ensure that we don't receive a PR that adds <code>printenv</code> to the CI scripts, exposing our secret keys.</p>

<p>As we couldn't add the keys to our testing environment, we added them to our heroku environment then took them from that. Semaphore sets up our heroku environment only during deployment, so in the deployment phase, we can use a line like:</p>

<pre><code class="sh">export FORCE_S3_KEY=$(heroku config:get FORCE_S3_KEY --app force-production)
</code></pre>

<p>This sets up the environment like we used to have it when force was private.</p>

<a name="Team"></a>
<h3>Team</h3>

<p>We needed to move all the team members to using the OSS version of our apps. This is a little bit complicated as <a href="/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/">we work from forks</a>. <a href="http://www.anandarooproy.com/portfolio">Roop</a>, an engineer on the web team, created a "Force OSS Dance Script" ( sidenote: <a href="http://www.anandarooproy.com/portfolio">his site</a> is worth a visit, there's 15 years of interesting maps. )</p>

<pre><code class="sh">## RENAME THE OLD REPO

# on GitHub

# - Go to my fork https://github.com/&lt;username&gt;/force
# - Go to Settings tab
# - Rename repo to "force-private"

# on my local machine

mv force force-private
cd force-private
git remote set-url upstream git@github.com:artsy/force-private.git
git remote set-url origin git@github.com:&lt;username&gt;/force-private.git


## FORK AND CLONE THE NEW REPO

# back to GitHub

# - Go to the new Force repo https://github.com/artsy/force
# - Fork it to my account

# back to my local machine

git clone git@github.com:&lt;username&gt;/force.git
cd force
git remote add upstream git@github.com:artsy/force.git
cp ../force-private/.env ./
cp ../force-private/node_modules ./ # or just 'npm install' again


# all good now - both repos on local machine with correct remotes, envs, deps
</code></pre>

<p>For Force, all the same commits existed in both repos, so it would be difficult to push secrets to the open repo by accident. However, individuals did to sync up a new version of their forks.</p>

<p>And that, is how we moved force into OSS by Default. :+1: - We'll cover the issues migration later.</p>

<a name="Microgravity"></a>
<h2>Microgravity</h2>

<p>I have a lot of love for Microgravity. It's the web project that made <a href="/blog/2015/04/28/how-we-open-sourced-eigen/">Eigen</a> possible. Once Force had moved, I started spending time with Craig trying to understand what it would take to open up Microgravity.</p>

<p></div></div><a href='/images/oss-milestone/micrograv-oss.png'><img src="/images/oss-milestone/micrograv-oss.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It is no surprise to find a lot of overlap, both projects are based on the same foundations: <a href="http://ezeljs.com">Ezel.js</a>.</p>

<p>We didn't trust the commit history for microgravity, so we nuked it. Same as our native OSS apps.</p>

<p>We came up with a pattern to make it easier for people to migrate issues, we created a <code>migrate</code> GitHub label that anyone can apply to an issue in a private repo. Then we use <a href="https://github-issue-mover.appspot.com">Issue Mover for GitHub</a> with some inline JavaScript to loop through all our issues to migrate. As it's applying a label we can ask product owners and designers to choose ones that are important to them too.</p>

<p>--</p>

<p>I love that I got to help make these changes, the web team started the process of opening our apps at Artsy, then the mobile team took the next big step. Now the teams are both in lock-step, and if you work on the front-end at Artsy - OSS by Default is the way we all work now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Tech Behind Live Auction Integration]]></title>
    <link href="http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration/"/>
    <updated>2016-08-09T11:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration</id>
    <content type="html"><![CDATA[<p>In late June, the <a href="https://www.artsy.net/auctions/">Artsy auctions</a> team launched our Live Auction Integration (LAI) product. It allows people to participate online in live sales held at auction houses <a href="https://www.artsy.net/auction-partnerships">that partner with Artsy</a>. It was a big project, begun in December, involving both brand new software and extensive integration work with the rest of our systems. This is the first in what will be a series of blog posts discussing the engineering work we did to get a complex product from inception to launch in such a brief time window, with a go-live deadline set in stone weeks in advance. In this, I’ll dig into what we shipped on a high level, as well as some of the overarching technical decisions.</p>

<!-- more -->


<p>LAI raised challenges that were novel to our engineering team. The product is a real-time experience from the perspectives of the bidder and the auction house. Producing that experience requires a complex human + computer system. There are two main flows of information: from auction house to bidder, and vice versa. These are mediated by our systems and staff as follows:</p>

<ul>
<li>As bids occur in the auction house sale room, an Artsy operator working on-site inputs that activity into a web interface so that online participants can keep track of what’s happening.</li>
<li>As online participants place bids, our system records those as “prospective bids”, and an Artsy bidding clerk on site at the auction house bids on their behalf in the auction house. As those bids are recognized, they are reflected back to all participants, through the prior flow.</li>
</ul>


<p>To make this easier to visualize:</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Artsy%20Live%20Auction%20Integration%20flow.png" alt="Artsy Live Auction Integration Flow" /></p>

<p>This needs to happen in a tight loop to allow online bidders to be competitive with those in the room and via auction house phone clerks. The architecture and UX of the LAI product were optimized for that goal. In addition, we built the system to integrate with live events hosted by our partners. As the events are outside our direct control, there are many, many ways things can deviate from this idealized flow. We had to carefully account for these situations.</p>

<p>Where possible, we leveraged our existing auctions technology. But we took the opportunity to upgrade that technology in some places and chose new approaches in others. Meanwhile, we were running the busiest Artsy auction season to date, and we had to ensure that we weren’t disrupting our existing stack. Below, I discuss the pieces of the end-to-end product.</p>

<a name="The.Live.user.experience"></a>
<h1>The Live user experience</h1>

<p>When the live auction actually begins, participants and Artsy staff interact with the system with front-end software developed from scratch. Web users (desktop and mobile) and staff use a new, dedicated Artsy Live web application, which is implemented in a project we call Prediction. iOS Artsy App users can also participate with newly developed UX within that app.</p>

<a name="The.web.app:.Prediction"></a>
<h2>The web app: Prediction</h2>

<p>Our bidder and operator web interfaces are implemented in an application we call Prediction, a <a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.ev1yd3juy">universal</a> <a href="https://facebook.github.io/react/">React</a>+<a href="http://redux.js.org/">Redux</a> Javascript app, served from an <a href="http://expressjs.com/">Express</a> server. Using React allowed us to completely share our view layer code for prerendering in the server and making updates in the client.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Prediction%20Bidder%20Screenshot.png" alt="Prediction Bidder UI" /></p>

<p>Keeping our state management and transition code organized with Redux allowed us to achieve a massive amount of reuse of model and controller code between our web interfaces. To solve Redux's <a href="http://stackoverflow.com/q/34570758/807674">async</a> and <a href="http://stackoverflow.com/q/34299460/807674">data conveyance</a> “problems", we built an integration layer for React and Redux called <a href="https://github.com/artsy/react-redux-controller">React Redux Controller</a>.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Prediction%20Operator%20Screenshot.png" alt="Prediction Operator UI" /></p>

<p>We found the React+Redux approach to model-view-controller app development to be a major win in what it gave us for maintainability, code reuse, easy testability, and the ability to reason about our code.</p>

<a name="The.iOS.native.app:.Eigen"></a>
<h2>The iOS native app: Eigen</h2>

<p>For users of the Artsy iOS app, known to our engineering team as <a href="https://github.com/artsy/eigen">Eigen</a>, a touch-optimized LAI experience was coded in Swift. It shares the same app with existing Objective-C code as well as <a href="https://facebook.github.io/react-native/">React Native</a> code used for other aspects of the iOS experience. We considered using React Native for this, but we decided to go with more familiar technology to contain the risk.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Eigen%20Bidder%20Screenshot.png" alt="Eigen Bidder UI" /></p>

<p>Both of these applications interact with our central Artsy back-end service to pull in artist, artwork, and sale metadata when the user enters the auction. These queries are mediated by a <a href="http://graphql.org/">GraphQL</a> middleware service we call <a href="https://github.com/artsy/metaphysics">Metaphysics</a> (also discussed <a href="/blog/2016/06/19/graphql-for-mobile/">here</a>), which vastly simplified the fetching process in the front-end services. But from that point forward, the apps interact with a brand new auction state management system over a bidirectional <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> API for live updating.</p>

<a name="The.auction.state.management.service:.Causality"></a>
<h1>The auction state management service: Causality</h1>

<p>The other recently launched piece of software delivered for LAI was a new auction state management system we call Causality. It processes bids and other auction events, computes the derived state of a sale, and hosts the bidirectional WebSocket API.</p>

<p>Causality was developed in Scala, using the <a href="http://doc.akka.io/docs/akka/current/intro/what-is-akka.html">Akka</a> technology suite for distributed computing. At its core is an append-only storage engine, based on <a href="http://doc.akka.io/docs/akka/current/scala/persistence.html">Akka Persistence</a>, with a small library we developed called <a href="https://github.com/artsy/atomic-store">Atomic Store</a> that allowed us to achieve strict consistency, at the cost of maximal throughput -- a trade-off that is explored in the readme of that project.</p>

<p>Lastly, Causality has an <a href="http://doc.akka.io/docs/akka/current/scala/http/introduction.html">Akka HTTP</a>-based API layer, with a WebSocket server implemented using <a href="http://doc.akka.io/docs/akka/current/scala/stream/stream-introduction.html">Akka Streams</a>. Asynchronous updates generated in the event processing logic are published across the cluster using <a href="http://doc.akka.io/docs/akka/current/scala/distributed-pub-sub.html">Akka Distributed Pub/Sub</a>, and they are merged into the WebSocket outflow.</p>

<a name="Pre-bidding..tooling..and.other.concerns"></a>
<h1>Pre-bidding, tooling, and other concerns</h1>

<p>In addition to accepting bids placed during a live sale, we also allow users to place bids before the event begins. In practice, this is almost the same workflow as our existing timed auction experience. For this reason, we chose to leverage all of our existing technology. The work of preparing our preexisting tech for LAI involved widespread modifications to our front-end UI, messaging services, admin tooling, and monitoring to make them appropriate for a live sale, as well as a reliable handoff of responsibility from these preexisting front- and back-end services to the new ones at the time the sale goes live.</p>

<p>We relied on our automated test suites, as well as thorough manual testing by the entire Artsy auctions team, to ensure that this handoff functioned smoothly under various circumstances. We will eventually eliminate this duplication. But this will require delicate refactoring of our preexisting tooling, which we will take on, even as we execute a fall auction season significantly busier than the last.</p>

<a name="Reflection"></a>
<h1>Reflection</h1>

<p>In the process of architecting our LAI product, we had to make some tough decisions in the face of new challenges. Chief among these were the decisions on where on the spectrum of bleeding-edge technology versus tried-and-true choices to land, for many of our subcomponents. Bleeding-edge tech often offers more elegant and performant solutions, but at the cost of learning curve and risk of immaturity. We also had to carefully prioritize functionality. Choosing wisely througout the process was critical to shipping on time. The rationale behind these decisions and their outcomes will be the result of future pieces.</p>

<p>To close, I want to express huge thanks to the auctions product &amp; engineering team for putting in long hours to design, implement, and troubleshoot the software; the auctions arts team for providing the domain knowledge and operational feedback; and our broader Artsy engineering team, at least half of whom directly contributed code to this effort.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trying out React]]></title>
    <link href="http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react/"/>
    <updated>2015-04-08T11:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react</id>
    <content type="html"><![CDATA[<p>We recently picked up a Rails application that was a few features away from completion. This application allows our <a href="https://www.artsy.net/about/the-art-genome-project">Genome Team</a> to classify multiple artworks based on visual and art historical characteristics. These characteristics, or "genes", can be added, removed, and changed for any of the artworks on the panel.</p>

<center><img src='/images/2015-04-08-creating-a-dynamic-single-page-app-for-our-genome-team-using-react/helix_screenshot.png'></center>


<p>Our genomers are masters of efficiency, and over the years we have worked closely with them to tailor a dynamic interface to their specific workflow.</p>

<p>When we started working on the app, the back-end was organized, modular, and interfaced seamlessly with the Artsy API, but there were still a few front-end features we needed to implement before it could be used by the Genome Team. The app did not use a front-end framework, and as our features scaled it was difficult to keep track of UI state with pure CoffeeScript and global event listeners. Eventually, we decided to stop trying to patch our leaky roof and build a new one.</p>

<!-- more -->


<a name="Choosing.a.Suitable.Framework"></a>
<h3>Choosing a Suitable Framework</h3>

<p>We decided to introduce a front-end framework to make it easier to add new features, and spent a day researching different options. Our requirements were:
- A robust view layer that could work on top of our already-solid Rails back-end,
- A framework performant enough for an interaction-heavy single-page app with hundreds of editable fields autosaving on change,
- A streamlined framework that favors freedom over unnecessary structure.</p>

<p>We chose <a href="http://facebook.github.io/react/">React</a>, Facebook's view layer framework, because it provides much-needed structure and support for components in a single page app without too much boilerplate.</p>

<p>Our plan was to eventually replace all of the existing <code>*.haml.erb</code> templates and global CoffeeScript mixins with discrete React components. We used the <a href="https://github.com/reactjs/react-rails">react-rails</a> gem, which easily integrates React components with Rails views.</p>

<p>In line with the <a href="https://facebook.github.io/react/docs/tutorial.html">React tutorial</a>, we first broke up our UI into functional and visual components. For each component we found the relevant HAML template, converted it into <a href="https://facebook.github.io/react/docs/jsx-in-depth.html">jsx</a> and React components using dummy data, and eventually updated it to accept the correct state from our top-level component which did all of the dynamic fetching and saving. Then we deleted the associated HAML and CoffeeScript code.</p>

<a name="Thinking.the.React.Way"></a>
<h3>Thinking the React Way</h3>

<p>At this point we have replaced the majority of the app's front-end with React components. We love React because it encourages you to follow certain <a href="http://www.reactivemanifesto.org/">ideological conventions</a>, but it does not force you into a structure that may not exactly align with your goals.</p>

<p>In React, having a single source of truth is ideal. Gone are liberally distributed global event listeners that can conflict and cause pages to get bogged down with transition logic. State is held at the topmost level in React and when state changes, React automatically re-renders only the affected components.</p>

<p>For example, we hold a hash <code>artworks</code> in the highest-level state of the page:
<code>javascript
getInitialState: function() {
  var artworks = _.map(this.props.artwork_ids, function(id) {
    return [id, {
      _id: id,
      isLoaded: false,
      isSelected: false,
      isMinimized: false
    }];
  });
  return {
    artworks: _.object(artworks),
    ...
  }
},
</code></p>

<p>We also store a method at this level to update the <code>artworks</code> state when there is a change:
<code>javascript
updateArtwork: function(artwork_id, cb) {
  // finds an artwork, passes it to callback (cb) to be mutated,
  // sets the mutated artwork on state from the return value of
  // the callback
  var new_artwork = cb(this.state.artworks[artwork_id]);
  var state_copy = this.state;
  state_copy.artworks[artwork_id] = new_artwork;
  this.setState(state_copy);
},
</code></p>

<p>That method is passed to child components, and when there is an update to an <code>artwork</code>, such as when it becomes selected, we invoke it to update all affected components:
<code>javascript
changeIsSelected: function (e) {
  e.preventDefault();
  var newSelectedState = !this.props.artwork.isSelected;
  this.props.updateArtwork(this.props.artwork._id, function(artwork) {
    artwork.isSelected = newSelectedState;
    return artwork;
  })
},
</code></p>

<p>React lets us define our components and interactions in a declarative style instead of stringing together possible transitions triggered by events. Before converting this app to React, we had many bugs around form submission and saving genome progress. However, by modeling state instead of UI transitions, we can easily track changes and save progress incrementally in the background without requiring a page refresh from the user.</p>

<a name="From.CoffeeScript.to.React:.Selecting.Artworks"></a>
<h4>From CoffeeScript to React: Selecting Artworks</h4>

<p>In this app, genomers are able to 'select' artworks on the panel for the purposes of saving and conducting batch actions. In our initial implementation, clicking the 'select all' button would individually click each artwork and used global event listeners to change UI state:</p>

<pre><code class="javascript">($ 'body').on 'click', '.artwork-selector', (evt) -&gt;
  container = $(this)
  currentSlug = container.data('id')
  artworkIdsElement = $('#selected_artwork_ids')
  selectedArtworkIds = _.compact(_.uniq(artworkIdsElement.val().split(',')))
  indexOfCurrentSlug = selectedArtworkIds.indexOf(currentSlug)
  if selectedArtworkIds.indexOf(currentSlug) != -1
    selectedArtworkIds.splice(indexOfCurrentSlug, 1)
    container.text('Not selected')
    container.removeClass('btn-purple')
  else
    selectedArtworkIds.push currentSlug
    container.text('Selected')
    container.addClass('btn-purple')
  $('#selected_artwork_ids').val(selectedArtworkIds.join(','))
  return false
</code></pre>

<p>With React, we store whether or not an artwork is selected as part of our state, and the appearance of elements results from this variable. We use <a href="https://facebook.github.io/react/docs/class-name-manipulation.html">class sets</a> to dynamically alter styles such as button color. When the <code>selected</code> state changes, React re-renders all components that depend on that variable.</p>

<pre><code class="javascript">var SelectedButton = React.createClass({
  changeIsSelected: function (e) {
    e.preventDefault();
    var newSelectedState = !this.props.artwork.isSelected;
    this.props.updateArtwork(this.props.artwork._id, function(artwork) {
      artwork.isSelected = newSelectedState;
      return artwork;
    })
  },
  render: function() {
    var cx = React.addons.classSet;
    var selectedButtonClasses = cx({
      'btn-purple': this.props.artwork.isSelected,
      'btn-tiny': true,
      'btn': true,
      'artwork-selector': true
    });
    return (
      &lt;div className="panel-artwork-actions"&gt;
        &lt;a className={selectedButtonClasses}
           data-id='false'
           href='#'
           onClick={ this.changeIsSelected }&gt;
         {this.props.artwork.isSelected ? '' : 'Not '}Selected&lt;/a&gt;
      &lt;/div&gt;
    )
  }
});
</code></pre>

<a name="Challenges"></a>
<h3>Challenges</h3>

<a name="React.s.Virtual.DOM"></a>
<h4>React's Virtual DOM</h4>

<p>React keeps track of a Virtual DOM created by components you define. This can lead to issues, especially when trying to integrate React with jQuery plugins. For example, our modals kept showing up within other components until we explicitly rendered them on the outermost level. We also had issues trying to use an existing drag/drop plugin with the way we set up our state, and ended up <a href="https://gist.github.com/sweir27/4ea941dd717da69527d6">building one from scratch</a>.</p>

<p>React also crashes when the Virtual DOM becomes out-of-sync with the page DOM. We unearthed a mysterious bug in which the browser was automatically inserting a <code>tbody</code> tag when it saw a table rendered without one... causing React (and therefore our entire app) to crash. In order to rectify this, we had to explicitly include these normally optional tags:
<code>javascript
if (geneList.length) {
  var results = (&lt;table className="triple-margin-top"&gt;
                   &lt;thead&gt;{DictionaryView.header}&lt;/thead&gt;
                   &lt;tbody&gt;{geneList}&lt;/tbody&gt;
                 &lt;/table&gt;);
 } else {
   var results = null;
 }
</code></p>

<a name="Working.with.the.React.Lifecycle"></a>
<h4>Working with the React Lifecycle</h4>

<p>Sometimes it is unavoidable to model transitions directly with JavaScript/jQuery, instead of using React's built-in lifecycle methods. In one case, we had to dynamically change the top padding of a component based on the height of a different one. Although we tried to do this using the <a href="https://facebook.github.io/react/docs/component-specs.html">React lifecycle</a> methods, there ended up being too many edge cases and we were having to add more and more states just to avoid:</p>

<pre><code class="javascript">currentTemplateHeight=$('.panel-template-wrap').height();
$('.panel-data-items').css('padding-top', currentTemplateHeight);
</code></pre>

<p>In this case, we found it more straightforward to go with the jQuery solution.</p>

<a name="React....Refactor"></a>
<h3>React == Refactor</h3>

<p>When we started out converting the app to React, it was hard to know whether or not an element should be its own component or if it could exist within another one. Often when we add new features, we have to refactor to make sure that we are reusing components and maintaining a single source of truth.</p>

<p>For example, we originally had one component to hold metadata on an artwork, such as artist, title, and date:
<code>javascript
var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    var artistName;
    var artworkTitle;
    var artworkDate;
    ...
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist['name']) {
      artistName = &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;;
    } else {
      artistName = &lt;span&gt;Unattributed&lt;/span&gt;;
    }
    artworkTitle = this.props.artwork.title ? this.props.artwork.title : 'Untitled';
    artworkDate = this.props.artwork.date ? this.props.artwork.date : 'No Date';
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;div className="artist-name"&gt;
              {artistName}
            &lt;/div&gt;
            &lt;div className="title"&gt;
              {artworkTitle}
            &lt;/div&gt;
            &lt;div className="date"&gt;
              {artworkDate}
            &lt;/div&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></p>

<p>When we implemented a new 'minimized' view for artworks, we also showed the title and artist, and so we broke these bits of information into separate components:
```javascript
var ArtistName = React.createClass({
  handleClick: function() {
    if (this.props.artwork.artist['name']) {
      this.props.setTemplateArtistId(this.props.artwork.artist['_id'])
    }
  },
  render: function() {
    var artistName;
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist['name']) {
      artistName = <a className="artist-as-template-link"
                      data-template-id={this.props.artwork.artist['_id']}
                      onClick={this.handleClick}
                      data-template-type="Artist" href="#">
                    {this.props.artwork.artist['name']}
                  </a>;
    } else if (this.props.artwork['cultural_maker']) {
      artistName = <span>{this.props.artwork['cultural_maker']}</span>;
    } else {
      artistName = <span>Unattributed</span>;
    }
    return (
      <div className="artist-name">
        {artistName}
      </div>
    );
  }
});</p>

<p>var ArtworkTitle = React.createClass({
  render: function() {
    var artworkTitle = this.props.artwork.title ? this.props.artwork.title : 'Untitled';
    return (
      <div className="title">
        {artworkTitle}
      </div>
    );
  }
});</p>

<p>var ArtworkDate = React.createClass({
  render: function() {
    var artworkDate = this.props.artwork.date ? this.props.artwork.date : 'No Date';
    return (
      <div className="date">
        {artworkDate}
      </div>
    );
  }
});
```</p>

<p>And updated our parent to reuse the new child components:
<code>javascript
var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;
            &lt;ArtworkTitle artwork={this.props.artwork} /&gt;
            &lt;ArtworkDate artwork={this.props.artwork} /&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></p>

<a name="Writing.Specs"></a>
<h3>Writing Specs</h3>

<p>All of the existing specs for the app were written in RSpec, so we chose to write integration tests using RSpec+Capybara. The headless Capybara webkit did not integrate with our React setup, so we switched to using Selenium as our Capybara JavaScript driver (which also conveniently let us debug our specs within the browser).</p>

<p>Our main challenge with specs had to do with RSpec not waiting long enough for components (such as autocomplete results) to appear, perhaps due to React's Virtual DOM. We spent many sad hours debugging spurious tests, and even included a few dreaded 'sleep' commands. Eventually, we integrated the <a href="https://github.com/y310/rspec-retry">rspec-retry</a> gem to retry spurious tests during CI.</p>

<a name="Conclusion"></a>
<h3>Conclusion</h3>

<p>Converting our app to use a React-based front-end went surprisingly smoothly. We were able to incrementally change certain templates to React components, which made it easy to test as we went along. Additionally, our development time in adding new features since then has decreased dramatically. It is much easier to add new components or edit existing ones when there is a single source of truth and you don't have to search through global event listeners.</p>

<p>Choosing a front-end framework is non-trivial but incredibly important, and we are glad we found React. Because it does not require much overhead and it is possible to only use it on a portion of a page, React can be integrated into small or large projects. Although we deliberated for a long time over whether or not to use a framework, we never regretted moving to React and investing in the future of the app.</p>
]]></content>
  </entry>
  
</feed>
