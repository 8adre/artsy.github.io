<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-09-10T17:38:05+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Relay Network Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive/"/>
    <updated>2018-07-25T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive</id>
    <content type="html"><![CDATA[<blockquote><p>Hey all, we have another guest post, this one comes from <a href="https://github.com/sibelius">Sibelius Seraphini</a> - a very active contributor to
Relay and its eco-system. When we spotted he had wrote an amazing article on how the networking aspects of Relay
comes together, we wanted to expand his reach and inform more people on how Relay comes together.</p>

<p>-- Orta</p></blockquote>

<p>Data fetching is a hard problem for apps. You need to ask yourself a lot of questions: How do you ask for data from
a server? How do you handle authentication? When is the right time to request data? How can you ensure you have all
the necessary data to render your views? How can you make sure you're not over-fetching? Can you do lazy loading?
When should you trigger lazy loading of data? What about pre-fetching data?</p>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a framework for building data-driven applications which handles data fetching for you. For an
introduction to Relay, read <a href="https://facebook.github.io/relay/">their docs</a>, and also check out my Relay talk at <a href="https://speakerdeck.com/sibelius/reactconfbr-is-relay-modern-the-future">React Conf BR</a>.</p>

<blockquote><p>You don’t deep dive if you don’t know how to swim</p></blockquote>

<a name="TL.DR.Relay.Modern.Network"></a>
<h2>TL;DR Relay Modern Network</h2>

<p>Relay will aggregate the data requirements (fragments) for your components, then create a request to fulfill it. The
API to do this is via the <a href="https://facebook.github.io/relay/docs/en/relay-environment.html">Relay Environment</a>:</p>

<blockquote><p>The Relay "Environment" bundles together the configuration, cache storage, and network-handling that Relay needs
in order to operate.</p></blockquote>

<p>This post focuses on the "network-handling" part, the <a href="https://facebook.github.io/relay/docs/en/network-layer.html">Network Layer</a>. The network layer's responsibility
is to make a request to a server (or a local graphql) and return the response data to Relay. Your implementation
should conform to either <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L79-L90">FetchFunction</a> for a Promise-like API, or <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L92-L107">SubscribeFunction</a> for an
Observable-like API.</p>

<p>This article will provide 5 implementations of a Relay Network Interface, each of one providing more capabilities
than the other one, eventually enabling GraphQL Live Queries and Deferrable Queries.</p>

<p>You can see the code for these 5 network layers on GitHub here, open source under MIT license:
<a href="https://github.com/sibelius/relay-modern-network-deep-dive">https://github.com/sibelius/relay-modern-network-deep-dive</a>.</p>

<!-- more -->


<a name="Simplest.Network.Layer"></a>
<h3>Simplest Network Layer</h3>

<p>The simplest network layer would; get the request, send it to a GraphQL server to resolve and return the data to
Relay environment.</p>

<pre><code class="js">const fetchFunction = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  // Most GraphQL APIs expect a POST with a JSON
  // string containing the query and associated variables
  const body = JSON.stringify({
    query: request.text, // GraphQL text from input
    variables
  });

  const headers = {
    Accept: "application/json",
    "Content-type": "application/json",
    authorization: getToken()
  };

  const response = await fetchWithRetries(ENV.GRAPHQL_URL, {
    method: "POST",
    headers,
    body,
    fetchTimeout: 20000,
    retryDelays: [1000, 3000, 5000, 10000]
  });

  const data = await response.json();

  // Mutations should throw when they have errors, making it easier
  // for client code to react
  if (isMutation(request) &amp;&amp; data.errors) {
    throw data;
  }

  // We return the GraphQL response to update the Relay Environment
  // which updates internal store where relay keeps its data
  return data;
};
</code></pre>

<a name="Network.that.Handle.Uploadables"></a>
<h3>Network that Handle Uploadables</h3>

<p>The GraphQL spec does not handle form data, and so if you need to send along files to upload to your server with a
mutation, you'll want to use the uploadables API in Relay when you commit the mutation.</p>

<p>Adding uploadables in a mutation will inevitably get passed to your network interface, where you'll need to change
your request body to use FormData instead of the JSON string above:</p>

<pre><code class="js">function getRequestBodyWithUploadables(request, variables, uploadables) {
  let formData = new FormData();
  formData.append("query", request.text);
  formData.append("variables", JSON.stringify(variables));

  Object.keys(uploadables).forEach(key =&gt; {
    if (Object.prototype.hasOwnProperty.call(uploadables, key)) {
      formData.append(key, uploadables[key]);
    }
  });

  return formData;
}
</code></pre>

<a name="Network.that.Caches.Requests"></a>
<h3>Network that Caches Requests</h3>

<p>This builds on top of the other 2 implementations, we use
<a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayQueryResponseCache.js#L24-L29">RelayQueryResponseCache</a>
to query GraphQL requests based on query and variables.</p>

<p>Every time a mutation happens, we should invalidate our cache as we are not sure how a change can affect all cached
query responses.</p>

<pre><code class="js">// Create our own in-memory cache
const relayResponseCache = new RelayQueryResponseCache({ size: 250, ttl: oneMinute });

const cacheHandler = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: UploadableMap
) =&gt; {
  const queryID = request.text;

  // If it's a mutation, clear all cache, then call the implementation above
  if (isMutation(request)) {
    relayResponseCache.clear();
    return fetchFunction(request, variables, cacheConfig, uploadables);
  }

  // Try grab the request from the cache first
  const fromCache = relayResponseCache.get(queryID, variables);
  // Did it hit? Or did we suppress the cache for this request
  if (isQuery(request) &amp;&amp; fromCache !== null &amp;&amp; !forceFetch(cacheConfig)) {
    return fromCache;
  }

  // Make the request, and cache it if we get a response
  const fromServer = await fetchFunction(request, variables, cacheConfig, uploadables);
  if (fromServer) {
    relayResponseCache.set(queryID, variables, fromServer);
  }

  return fromServer;
};
</code></pre>

<a name="Network.using.Observable"></a>
<h3>Network using Observable</h3>

<p>Relay provides a limited implementation of the upcoming <a href="https://github.com/tc39/proposal-observable">ESObservables</a> spec. I recommend reading <a href="https://kriskowal.gitbooks.io/gtor/content/">A General
Theory of Reactivity</a> to understand why Observables are a great solution instead of promises in some
situations. Notably; a promise is one value in a time space, an observable is a stream of values in a time space.</p>

<!-- [TODO: Why Sink and not the Relay Observable? Observable is exported but has one more function (complete)] -->


<p>To work with this API, we're going to use a private interface for the observable object called Sink:</p>

<pre><code class="js">/**
 * A Sink is an object of methods provided by Observable during construction.
 * The methods are to be called to trigger each event. It also contains a closed
 * field to see if the resulting subscription has closed.
 */
export type Sink&lt;-T&gt; = {|
  +next: T =&gt; void,
  +error: (Error, isUncaughtThrownError?: boolean) =&gt; void,
  +complete: () =&gt; void,
  +closed: boolean
|};
</code></pre>

<p>Which is the shape of the Observable object we pass back to Relay:</p>

<pre><code class="js">const fetchFunction = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap,
  sink: Sink&lt;any&gt;
) =&gt; {
  const body = getRequestBody(request, variables, uploadables);

  const headers = {
    ...getHeaders(uploadables),
    authorization: getToken()
  };

  const response = await fetchWithRetries(ENV.GRAPHQL_URL, {
    method: "POST",
    headers,
    body,
    fetchTimeout: 20000,
    retryDelays: [1000, 3000, 5000, 10000]
  });

  const data = await handleData(response);

  if (isMutation(request) &amp;&amp; data.errors) {
    sink.error(data);
    sink.complete();

    return;
  }

  sink.next(data);
  sink.complete();
};

// Instead of returning a Promise that will resolve a single GraphQL response.
// We return an Observable that could fulfill many responses before it finishes.

const executeFunction = (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  return Observable.create(sink =&gt; {
    fetchFunction(request, variables, cacheConfig, uploadables, sink);
  });
};
</code></pre>

<p>This is an implementation you would need when working with <a href="https://github.com/facebook/relay/issues/2174">GraphQL Live Queries</a> (based on polling), as you
are going to resolve the same query more than once.</p>

<a name="Deferrable.Queries.Network"></a>
<h3>Deferrable Queries Network</h3>

<p>A common case for deferrable queries is to lazy load fragments. This lets you get request content above the page
fold first, and then request additional data after. A good example is loading a Post's content first and then
subsequently loading all comments of this post after the post has finished.</p>

<p>Without deferrable queries you could simulate this using the <a href="https://facebook.github.io/relay/docs/en/graphql-in-relay.html#directives">@include</a> directive in your Relay fragment
and a <a href="https://facebook.github.io/relay/docs/en/refetch-container.html">refetch container</a>. When the component mounts the refetch container changes the variable used on the
<code>@include</code> to true and it will request the rest of the data.</p>

<p>The problem with above approach is that you need to wait for the component to mount before you can start the next
request. This becomes a bigger problem as React does more work asynchronously.</p>

<!-- TODO: There are no docs for relay deferrable -->


<p>An ideal deferrable query will start as soon as the previous query has finished, rather than depending on your React
components render cycles. Relay provides a <a href="https://github.com/facebook/relay/issues/2194#issuecomment-383466255">directive</a> for this: <code>@relay(deferrable: true)</code>:</p>

<pre><code class="js">const PostFragment = createFragmentContainer(Post, {
  post: graphql`
    fragment Post_post on Post {
      title
      commentsCount
      ...CommentsList_post @relay(deferrable: true)
    }
  `
});
</code></pre>

<p>In the fragment above, Relay will first get the <code>title</code> and <code>commentsCount</code> from the Post, then afterwards Relay
will get the data for <code>CommentsList_post</code> fragment. Sending both through the observable.</p>

<p>Here is the implementation of an execute function to handle a batched request:</p>

<pre><code class="js">const executeFunction = (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  return Observable.create(sink =&gt; {
    if (request.kind === "Request") {
      cacheHandler(request, variables, cacheConfig, uploadables, sink, true);
    }

    if (request.kind === "BatchRequest") {
      batchRequestQuery(request, variables, cacheConfig, uploadables, sink);
    }
  });
};
</code></pre>

<p>This execute function now can handle 2 types of requests:</p>

<ul>
<li>a single GraphQL query <code>Request</code></li>
<li>or a <code>BatchRequest</code> that could have be many queries with inter-related data</li>
</ul>


<p>So, what does the <code>batchRequestQuery</code> function look like?</p>

<!-- TODO: Annotate ths code, I'm not 100% what it's doing myself -->


<pre><code class="js">// Get variables from the results that have already been sent
const getDeferrableVariables = (requests, request, variables: Variables) =&gt; {
  const { argumentDependencies } = request;

  if (argumentDependencies.length === 0) {
    return variables;
  }

  return argumentDependencies.reduce((acc, ad) =&gt; {
    const { response } = requests[ad.fromRequestName];

    const variable = get(response.data, ad.fromRequestPath);

    // TODO - handle ifList, ifNull
    // See: https://github.com/facebook/relay/issues/2194
    return {
      ...acc,
      [ad.name]: variable
    };
  }, {});
};

// Execute each of the requests, and call `sink.next()` as soon as it has the GraphQL
/// server response data.
//
// It will only close the Observable stream when all requests has been fulfilled.
const batchRequestQuery = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap,
  sink: Sink&lt;ExecutePayload&gt;
) =&gt; {
  const requests = {};

  for (const r of request.requests) {
    const v = getDeferrableVariables(requests, r, variables);

    const response = await cacheHandler(r, v, cacheConfig, uploadables, sink, false);

    requests[r.name] = response;
  }

  sink.complete();
};
</code></pre>

<a name="Relay.Modern.is.very.flexible"></a>
<h2>Relay Modern is very flexible</h2>

<p>Depending on your application needs, you can scale from a simpler Promise-based API for your custom network layer to
one that uses Observables to always resolves from cache data first and then resolves from the server.</p>

<p>Here are some production examples:</p>

<ul>
<li><p><a href="https://github.com/artsy/emission/blob/master/src/lib/relay/fetchQuery.ts">Artsy Emission</a>: Uses the Promise API, caches the results locally, and shares logic with native code in an
iOS app so that queries can be pre-cached before the JavaScript runtime has started.</p></li>
<li><p><a href="https://github.com/relay-tools/react-relay-network-modern">ReactRelayNetworkModern</a>: A network layer that uses the middleware pattern to separate responsibilities like
retrying, logging, caching and auth.</p></li>
<li><p><a href="https://github.com/facebook/relay/issues/2174#issuecomment-375274003">timobetina's example</a>: The simplest Observable network layer you can start with.</p></li>
</ul>


<!-- TODO: More, @sibelius do you have some good examples? -->


<a name="More.Resources"></a>
<h2>More Resources</h2>

<p>If you want to expand your understanding of GraphQL and Relay Modern, I have two great related resources:</p>

<ul>
<li><p>A boilerplate that uses dataloader to batch and cache requests to your database in a GraphQL API:
<a href="https://github.com/entria/graphql-dataloader-boilerplate">https://github.com/entria/graphql-dataloader-boilerplate</a></p></li>
<li><p>A simple boilerplate for working with Relay Modern and React Navigation:
<a href="https://github.com/entria/ReactNavigationRelayModern">https://github.com/entria/ReactNavigationRelayModern</a></p></li>
</ul>


<p>If you have questions about this or anything send me a DM on twitter <a href="https://twitter.com/sseraphini">https://twitter.com/sseraphini</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Managing Secrets in a React Native App]]></title>
    <link href="http://artsy.github.io/blog/2018/06/15/cocoapods-keys-react-native/"/>
    <updated>2018-06-15T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/06/15/cocoapods-keys-react-native</id>
    <content type="html"><![CDATA[<!--
Iɴᴛʀᴏᴅᴜᴄᴛɪᴏɴ
-->


<p>Hi! I'm Erik, a software engineer on the Purchase team. One of the most visible payoffs from Artsy's investments in React Native <a href="https://artsy.github.io/search/?q=react+native">over the past two years</a> has been the opening up of our mobile codebase to contributors like myself coming primarily from web stacks. It's nice to be able to build mobile interfaces with the same declarative API used by so many of our web projects, but sometimes we still need to bridge the divide to our Objective-C and Swift ecosystem. One such case: replacing the app secrets typically loaded from a deploy environment or web developer's <a href="https://www.npmjs.com/package/dotenv">dotenv</a> file.</p>

<!-- more -->


<!--
Mᴀɪɴ Bᴏᴅʏ
-->


<p><a href="https://github.com/artsy/emission">Emission</a> is Artsy's React Native component library. It contains its own native app in the <code>/Example</code> folder, which uses <a href="https://artsy.github.io/blog/2015/01/21/cocoapods-keys-and-CI/">cocoapods-keys</a> to store secrets while still letting us code in the open. In order to expose these keys to our React Native components, however, we must do a fair bit of setup. Here's a straightforward how-to that also makes a quick tour through the iOS ecosystem for web developers looking at the React Native JavaScript runtime today.</p>

<p>Links to examples below come from <a href="https://github.com/artsy/emission/pull/1086/commits/4a2a3e9260e97d791536cf38376a06b0ad0946a8">this commit</a> which adds a key for the Stripe API to Emission. When we are finished, a client app (<code>/Example</code>, <a href="https://github.com/artsy/eigen">Eigen</a>, etc.) will be able to initialize Emission with this secret, which will in turn make it available to React Native components.</p>

<a name="Steps"></a>
<h2>Steps</h2>

<a name="L1..Add.the.key.to.the.app.s.Podfile."></a>
<h4>1. Add the key to the app's Podfile.</h4>

<p>This is the extent of <code>cocoapods-keys</code> official <a href="https://github.com/orta/cocoapods-keys#usage">setup</a>, and after this you <strong>could</strong> set the key via <code>pod keys set &lt;NAME&gt;</code> or <code>pod install</code>... but we have more to do.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Example/Podfile#L63">/Example/Podfile</a>:</p>

<pre><code class="diff">plugin 'cocoapods-keys', {
  :target =&gt; 'Emission',
  :keys =&gt; [
    'ArtsyAPIClientSecret',
    'ArtsyAPIClientKey',
+    'StripePublishableKey',
  ]
}
</code></pre>

<hr />

<a name="L2..Configure.the.library.to.consume.our.new.key"></a>
<h4>2. Configure the library to consume our new key</h4>

<p>We'll need to update the <code>initWithUserId...</code> function — one <strong>fun</strong> part of adjusting to Objective-C is that rather than named functions, we just refer to them by their entire signatures — to expose the new key as a property and add it to <code>constantsToExport</code> (<a href="https://facebook.github.io/react-native/docs/native-modules-ios.html#exporting-constants">docs</a>).</p>

<p>Note that this is happening in our <em>Emission Pod</em>; The pod now expects that key to be available in our <em>consuming</em> Example app as defined above.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Pod/Classes/Core/AREmission.h#L17-L34">/Pod/Classes/Core/AREmission.h</a>:</p>

<pre><code class="diff">// ENV Variables
 #import &lt;React/RCTBridgeModule.h&gt;

 @interface AREmissionConfiguration : NSObject &lt;RCTBridgeModule&gt;

+ @property (nonatomic, copy, readonly, nullable) NSString *stripePublishableKey;

 - (instancetype)initWithUserID:(NSString *)userID
           authenticationToken:(NSString *)token
                     sentryDSN:(nullable NSString *)sentryDSN
+         stripePublishableKey:(NSString *)stripePublishableKey
              googleMapsAPIKey:(nullable NSString *)googleAPIKey
                    gravityURL:(NSString *)gravity
                metaphysicsURL:(NSString *)metaphysics
                     userAgent:(NSString *)userAgent;
</code></pre>

<p><code>AREmission</code>'s implementation (.m) needs to be configured to take this new key- It will be exported to our React Native components as <code>Emission</code>. We make our initializer match the signature defined in the header (.h) file, and add an instance <code>_stripePublishableKey</code> to match the <code>@property</code> declaration.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Pod/Classes/Core/AREmission.m#L24-L60">/Pod/Classes/Core/AREmission.m</a>:</p>

<pre><code class="diff"> @implementation AREmissionConfiguration
 RCT_EXPORT_MODULE(Emission);
 # ...

 - (NSDictionary *)constantsToExport
 {
   return @{
+    @"stripePublishableKey": self.stripePublishableKey ?: @"",
     # ...lots more
   };
 }

 - (instancetype)initWithUserID:(NSString *)userID
            authenticationToken:(NSString *)token
                      sentryDSN:(NSString *)sentryDSN
+          stripePublishableKey:(NSString *)stripePublishableKey
               googleMapsAPIKey:(NSString *)googleAPIKey
                     gravityURL:(NSString *)gravity
                 metaphysicsURL:(NSString *)metaphysics
                      userAgent:(nonnull NSString *)userAgent
 {
     self = [super init];
     _userID = [userID copy];
+    _stripePublishableKey = [stripePublishableKey copy];
     # ... More copies...
     return self;
 }
</code></pre>

<p><em>Why is <code>copy</code> needed at all? See <a href="https://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain/388002#388002">here</a>.</em></p>

<hr />

<a name="L3..Configure.the.example.app.to.expose.the.new.key.to.our.library"></a>
<h4>3. Configure the example app to expose the new key to our library</h4>

<p>After making sure we have imported the keys from <code>cocoapods-keys</code> we update Emission's setup to use the new initializer signature we defined above.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/Example/Emission/AppDelegate.m#L109">Example/Emission/AppDelegate.m</a>:</p>

<pre><code class="diff">#import &lt;Keys/EmissionKeys.h&gt;

  - (void)setupEmissionWithUserID:(NSString *)userID accessToken:(NSString *)accessToken keychainService:(NSString *)service;
  {
    # ...
     AREmissionConfiguration *config = [[AREmissionConfiguration alloc]
      initWithUserID:userID
      authenticationToken:accessToken
      sentryDSN:nil
+     stripePublishableKey:keys.stripePublishableKey
      googleMapsAPIKey:nil
      gravityURL:setup.gravityURL
      metaphysicsURL:setup.metaphysicsURL
      userAgent:@"Emission Example"];
    # ...
</code></pre>

<hr />

<a name="L4..Use.that.configured.key.in.a.React.Native.component."></a>
<h4>4. Use that configured key in a React Native component.</h4>

<p><code>Emission</code> is now exposed along with its configured keys via React Native's <a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">NativeModules</a>.</p>

<p><a href="https://github.com/artsy/emission/blob/4a2a3e9260e97d791536cf38376a06b0ad0946a8/src/lib/components/bidding/screens/confirmfirsttimebid.tsx#l31">src/lib/Components/Bidding/Screens/ConfirmFirstTimeBid.tsx</a>:</p>

<pre><code class="js">import { NativeModules } from "react-native";
const Emission = NativeModules.Emission || {};

stripe.setOptions({
  publishableKey: Emission.stripePublishableKey
});
</code></pre>

<!--
Cᴏɴᴄʟᴜsɪᴏɴ
-->


<p>That's it! Compared to a familiar dotenv file, <strong>it</strong> certainly means a bit more ceremony here, but we are working through React Native code, its containing Pod <em>and</em> a consuming app. The process is more complicated, but it's also a nice overview of some fundamentals of Objective-C, iOS development and bridging the gap between react and mobile native code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing: Artsy x React Native]]></title>
    <link href="http://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native/"/>
    <updated>2018-06-03T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native</id>
    <content type="html"><![CDATA[<p>React Native has a lot of buzz around it. It is some serious and cool tech, yet can feel like a big departure from
your native iOS codebase. At Artsy, we like it. It has been the right choice for us. We've <a href="http://artsy.github.io/search/?q=react+native">documented</a> <a href="http://artsy.github.io/series/react-native-at-artsy/">our</a>
<a href="http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy/">journey</a> and <a href="http://artsy.github.io/blog/2018/03/17/two-years-of-react-native/">reasoning</a> quite extensively, but naturally, developers around the world are still wondering
whether the trade-offs make sense to <em>their</em> team, and <em>their</em> situation.</p>

<p>Enter <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a>.</p>

<p>Who better to partner with than Facebook? We're bringing a day full of hands-on informative insight and practical
play. With the focus on what building world class applications with RN can be like.</p>

<p>We'll demo, through talks and workshops, how to add React Native bit by bit to an existing codebase, set your
tooling up for success, and create solid animations.</p>

<p>We want <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a> to be about getting you up to speed with the framework, so you can make your
own decisions going forward.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScriptures 3 - Styled Components]]></title>
    <link href="http://artsy.github.io/blog/2018/05/04/JavaScriptures-3-Styled-Components/"/>
    <updated>2018-05-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/05/04/JavaScriptures-3-Styled-Components</id>
    <content type="html"><![CDATA[<p>The third in our JavaScriptures series on the Artsy <a href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">omakase</a>. This workshop is a deep dive into <a href="https://www.styled-components.com">Styled
Components</a>, where we take our React app from the first workshop and convert it to use Styled Components. We
have Anandaroop Roy and Jon Allured covering all the details.</p>

<!-- more -->




<center>
<iframe width='100%' height='400' src='https://www.youtube.com/embed/K7xafqfcC-4' frameborder='0' allowfullscreen></iframe>
</center>




<p style='text-align:right;'><a href="https://speakerdeck.com/artsyopensource/javascriptures-3-styled-components">
Slides on Speakerdeck
</a></p>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScriptures 2 - TypeScript]]></title>
    <link href="http://artsy.github.io/blog/2018/05/02/JavaScriptures-2-TypeScript/"/>
    <updated>2018-05-02T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/05/02/JavaScriptures-2-TypeScript</id>
    <content type="html"><![CDATA[<p>The second in our JavaScriptures series on the Artsy <a href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">omakase</a>. This one is a deep dive in TypeScript with
a minor-focus on working with React. We run through a series of excercises you can run <a href="https://github.com/artsy/javascriptures/tree/master/2_intro-to-typescript">through yourself
here</a>.</p>

<p>It's ran by <a href="https://twitter.com/alloy">@alloy</a> and <a href="https://github.com/sarahscott">Sarah Scott</a> and covers compilation, errors, default types, interfaces,
inference, generics and how they all come together in your tools.</p>

<!-- more -->




<center>
<iframe width='100%' height='400' src='https://www.youtube.com/embed/KXPZvjCUlAA' frameborder='0' allowfullscreen></iframe>
</center>




<p style='text-align:right;'><a href="https://speakerdeck.com/artsyopensource/javascriptures-2-typescript">
Slides on Speakerdeck
</a></p>



]]></content>
  </entry>
  
</feed>
