<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-11-18T17:21:02+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy]]></title>
    <link href="http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy/"/>
    <updated>2016-08-15T21:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy</id>
    <content type="html"><![CDATA[<center>
<img src="/images/react-native/artsy_react_logo.svg" style="width:300px;">
</center>


<p>As <a href="https://github.com/artsy/eigen">the Artsy iOS app</a> grew larger, we started hitting pain
points:</p>

<ul>
<li>We want to support other future platforms such as Android without creating more teams.</li>
<li>We want different business teams to work on the app without disrupting each other.</li>
<li>We want our architecture to evolve in order to increase programmer efficiency.</li>
</ul>


<p>It took us <a href="https://github.com/artsy/mobile/issues/22">about a year</a> to start resolving these issues.
Ideally, we wanted to find a solution to our architectural issues that would also improve the user
experience. Notably we wanted more efficient networking, due to mobile device constraints.</p>

<p>It would have been an easy leap to start using Swift and, as a matter of fact, we do use Swift in parts of
our flagship application and entirely in <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">2 other apps</a>.</p>

<p>However, while Swift is a great language, it’s also just that: <em>another</em> language. It does not do much in terms of new
paradigms that solved our architectural needs, it does not help in terms of cross-platform - as most of our code is
building views and thus very framework specific, and it did not really offer anything in terms of more efficient network
data fetching.</p>

<p>We've seen that the web teams integrate React in their projects with really great results. We've been
<a href="https://github.com/artsy/mobile/issues/22">paying attention</a> to React Native since it came out; the solutions provided
by the React ecosystem ticked all of our boxes.</p>

<p>Six months ago we took the plunge, and last month we formalized that this is the direction we want to go.</p>

<!-- more -->


<a name="Cons"></a>
<h1>Cons</h1>

<p>So you decided to read the full post and the first thing you got confronted with is a list of cons… <em>boo</em>. Let’s just get
these out of the way first, it will only get better afterwards.</p>

<ul>
<li><p>Dependencies, dependencies, dependencies, both in libraries and tooling. Once you open this can, you’ll have worms
<em>everywhere</em> in no time; 593 packages to be exactly, at the time of writing, for a new React Native project. Good luck
maintaining that.</p>

<p>Having created <a href="https://cocoapods.org">a dependency manager</a>, I’m not afraid of some dependencies and don’t subscribe
to NIH, but the JavaScript community has gone <em>way</em> overboard for my taste. If, like me, you subscribe to the idea
that dependencies are <em>part</em> of your application and you want to be able to know what packages are being pulled in so
you can maintain them, then you probably won’t like this aspect very much either.</p>

<p>I’m not quite sure yet how I feel about this in the long run and what we can do about it, short of trying to get the
maintainers of the packages we directly depend on to accept changes that simplify their dependency graphs.</p></li>
<li><p>As is often the case, error reporting does not always receive the attention it should get. With the amount of tools
and libs that make up the full stack you need to work with, this lack in attention to failure resolution can quickly
cascade into deep rabbit holes.</p></li>
<li><p>React Native is still very young and fast moving. If you don’t like living on the edge (i.e. lots of updating and
dealing with breaking changes) nor have an interest in shaping an unfinished framework, this currently is not for you.</p></li>
<li><p>All Facebook open-source code is made to solve the problems that Facebook has first, thus with young projects you may
well need to put in a bunch of time to make it work for your problem set. React Native provides a lot of basic view
building blocks, but you do lose a lot that you would get with UIKit for free, e.g. <code>UICollectionView</code>.</p>

<p>However, it is important to note that this is only a heads-up for those that might think they can solve any problem
out-of-the-box; in terms of open-source code I prefer code used in production over other code <em>any</em> day.</p></li>
<li><p>There are currently many more people trying to get help, with often arguably simple questions in the context of iOS
development, compared to those willing to spend time on answering questions. Most forums I’ve seen suffer from the
tragedy of the commons problem, which can be a real problem if you have incidental framework specific questions, but
jumping to React-Native probably is a complete disaster if you know very little about iOS development yet.</p>

<p>If you’re not already knowledgable about iOS development, are not motivated to put in the time to learn about the
platform specific details, and think making rich iOS applications with React Native will be a breeze, you’ll
<a href="http://www.dwotd.nl/2008/06/443-van-een-kouwe-kermis-thuiskomen.html">come home from a very cold fair</a> indeed.</p>

<p>While you can definitely make applications that way, in my experience those often end up not feeling like proper
citizens of the platform they inhibit.</p></li>
<li><p>Due to React Natives immaturity, you will not be able to find nuanced post-mortems on the subject. The project
is only at the beginning of the <a href="https://en.wikipedia.org/wiki/Hype_cycle">hype cycle</a>, meaning there is a lot
to gain in writing about how great it is, but less incentive to discuss where it doesn't work out well.</p></li>
</ul>


<a name="Pros..why.we.wanted.to.use.React.Native"></a>
<h1>Pros, why we wanted to use React Native</h1>

<ul>
<li><p>From <a href="https://facebook.github.io/react/">the React website</a>:</p>

<blockquote><p>React will efficiently update and render just the right components when your data changes.
Build encapsulated components that manage their own state, then compose them to make complex UIs.</p></blockquote>

<p>The functional model that React introduces that allows you to reason about the state of your views in much simpler
ways has for us been a welcome change that should make it much easier to write decoupled code going forward.</p>

<p>I’m by no means a functional programming purist, nor do I really care for being one. I found the React/React Native
communities to be very welcome to functional enthusiasts and pragmatists alike, a healthy mix that I find leads to
more productive outcomes.</p></li>
<li><p>Relay. From <a href="https://facebook.github.io/relay/">its website</a>:</p>

<blockquote><p>Queries live next to the views that rely on them, so you can easily reason about your app.
Relay aggregates queries into efficient network requests to fetch only what you need.</p></blockquote>

<p>The clarity this brings to the view codebase - coupled with its smart caching, networking is just ground-breaking.
No more multiple levels of model code in your application that you need to trace, just a single file with
<a href="https://github.com/artsy/emission/blob/a2e4dbdb/lib/components/artist/header.js#L87">the view component</a> <em>and</em>
<a href="https://github.com/artsy/emission/blob/a2e4dbdb/lib/components/artist/header.js#L143-L144">the data it needs</a>. Neat.</p>

<p>We do still have ‘view models’, however, those now pretty much all live in
<a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">our GraphQL service</a>. The added benefit here is that we
share that model logic with Artsy’s other (web) clients.</p></li>
<li><p>“Learn once, write anywhere.” is the neo-cross-platform slogan deployed by React, which is a play on the tried
“Write once, run anywhere.” slogan of yesteryear. The difference being that you can use the same paradigms to create
products on various platforms, rather than pure code-reuse.</p>

<p>While we haven’t put this to the test yet at Artsy, we do plan to team up people across platforms to implement single
features on each respective platform, rather than having multiple people implement the same feature <em>on their own</em>.
The hope is that this will lead to better understanding of features and thus the implementations thereof, while still
taking each platform’s unique nature into account. The added benefit would be that people learn to understand and
appreciate those unique platform traits, thus making them more well-rounded engineers.</p>

<p>In the long run, we hope to extend this way of working as we start work on a React Native Android client.</p></li>
<li><p>While Auto Layout is a great step up from manual frame calculation, most of our views don’t need the granularity that
Auto Layout offers. React Native ditches Auto Layout and instead uses
<a href="https://en.wikipedia.org/wiki/CSS_Flex_Box_Layout">flexbox</a> for its layout. While my head has never been able to
fully wrap around classic CSS, I find that flexbox is an abstraction that nicely fits most of our needs.</p>

<p>I can definitely imagine situations in which more granularity would be required, however, in those cases we can always
decide to ‘drop down’ to native view code, so I don’t really worry too much about that.</p></li>
<li><p>Layout calculations are performed on a background thread, the so-called ‘shadow’ thread. This can make a big
difference when e.g. scrolling through a large complex list view.</p>

<p>Granted, you <em>can</em> do this with <code>UIView</code>, but the pattern is not as ingrained in UIKit thus usually leading to more holistic
replacements such as <a href="http://asyncdisplaykit.org">AsyncDisplayKit</a>.</p></li>
<li><p>Great separation of declarative view layout (JS, single-threaded) and technical details (native code, multi-threaded).
Because of the hard constraint of having a JS/native bridge, there really is no way to take shortcuts (e.g. spaghetti
code) that in the long run would only lead to technical debt. Constraints are great.</p></li>
<li><p>Because there’s very little code that needs to be compiled and how the isolated component nature of React makes it
it very easy to reload code in-process, development velocity lies much higher than with your typical native UIKit-based
development.</p></li>
<li><p>While, as mentioned above, there are definitely issues with the tooling and libs, on the flip-side it is all
open-source software and you <em>can</em> (officially) dive in and figure it out, unlike e.g. Xcode and UIKit. (Granted, you
still need to deal with these when using React Native, but it can be kept to a minimal surface.)</p></li>
<li><p>Because React Native is still young, fast moving, and open-source, this is a great time to help shape the framework
you’d <em>want</em> to use.</p></li>
</ul>


<a name="Things.we.learned"></a>
<h1>Things we learned</h1>

<ul>
<li><p>When we started out with React Native, I didn't want to have to re-write our application in order to take advantage of
the technology. To address this I worked within our existing application structure. We consider the App to
<a href="https://artsy.github.io/blog/2015/08/24/Cocoa-Architecture-Hybrid-Apps/">be a browser</a> of native and web view controllers. So,
we added routes <a href="http://artsy.github.io/blog/2015/08/19/Cocoa-Architecture-Switchboard-Pattern/">to our SwitchBoard</a> for
view controllers which are created in React Native. To the rest of the app, there is no difference between a Swift view controller,
or one with React Native inside.</p></li>
<li><p>All of the React Native code is kept in a completely separate repo, <a href="https://github.com/artsy/emission">Emission</a>, which
when deployed generates a minified version of the JavaScript. This means to build the Artsy iOS app you do not need to have
a JavaScript development environment.</p></li>
<li><p>We reused a lot of our existing native views, starting with loading indicators and native switch views.</p></li>
<li><p>We used new native classes to improve integration, for example the <code>&lt;OpaqueImageView&gt;</code>
<a href="https://github.com/artsy/emission/blob/master/lib/components/opaque_image_view.js">component</a> is a
<a href="https://github.com/artsy/emission/tree/master/Pod/Classes/OpaqueImageViewComponent">native</a> <code>UIImageView</code>
subclass that works with our application-wide <a href="https://cocoapods.org/pods/SDWebImage">SDWebImage</a> image cache.</p></li>
</ul>


<a name="Conclusion"></a>
<h1>Conclusion</h1>

<p>To really shine with React Native, you need native experience. JavaScript has not eaten everything yet. However,
you don't need a team of native experts. For example, we expect to be able to get quite far with Android support based on
our work in React Native, but to make it amazing, we will need someone with history and context in the space.</p>

<p>This frees up our engineers to widen their <a href="https://artsy.github.io/blog/2016/01/30/iOS-Junior-Interviews/">T-shaped skills</a>,
and to help remove the idea that the mobile team has to be a completely separate team with foreign tools and ideas.</p>

<p>This is only the tip of the iceberg for our writings about React Native. Follow <a href="https://twitter.com/ArtsyOpenSource">@ArtsyOpenSource</a>
to stay up to date.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Tech Behind Live Auction Integration]]></title>
    <link href="http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration/"/>
    <updated>2016-08-09T11:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration</id>
    <content type="html"><![CDATA[<p>In late June, the <a href="https://www.artsy.net/auctions/">Artsy auctions</a> team launched our Live Auction Integration (LAI) product. It allows people to participate online in live sales held at auction houses <a href="https://www.artsy.net/auction-partnerships">that partner with Artsy</a>. It was a big project, begun in December, involving both brand new software and extensive integration work with the rest of our systems. This is the first in what will be a series of blog posts discussing the engineering work we did to get a complex product from inception to launch in such a brief time window, with a go-live deadline set in stone weeks in advance. In this, I’ll dig into what we shipped on a high level, as well as some of the overarching technical decisions.</p>

<!-- more -->


<p>LAI raised challenges that were novel to our engineering team. The product is a real-time experience from the perspectives of the bidder and the auction house. Producing that experience requires a complex human + computer system. There are two main flows of information: from auction house to bidder, and vice versa. These are mediated by our systems and staff as follows:</p>

<ul>
<li>As bids occur in the auction house sale room, an Artsy operator working on-site inputs that activity into a web interface so that online participants can keep track of what’s happening.</li>
<li>As online participants place bids, our system records those as “prospective bids”, and an Artsy bidding clerk on site at the auction house bids on their behalf in the auction house. As those bids are recognized, they are reflected back to all participants, through the prior flow.</li>
</ul>


<p>To make this easier to visualize:</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Artsy%20Live%20Auction%20Integration%20flow.png" alt="Artsy Live Auction Integration Flow" /></p>

<p>This needs to happen in a tight loop to allow online bidders to be competitive with those in the room and via auction house phone clerks. The architecture and UX of the LAI product were optimized for that goal. In addition, we built the system to integrate with live events hosted by our partners. As the events are outside our direct control, there are many, many ways things can deviate from this idealized flow. We had to carefully account for these situations.</p>

<p>Where possible, we leveraged our existing auctions technology. But we took the opportunity to upgrade that technology in some places and chose new approaches in others. Meanwhile, we were running the busiest Artsy auction season to date, and we had to ensure that we weren’t disrupting our existing stack. Below, I discuss the pieces of the end-to-end product.</p>

<a name="The.Live.user.experience"></a>
<h1>The Live user experience</h1>

<p>When the live auction actually begins, participants and Artsy staff interact with the system with front-end software developed from scratch. Web users (desktop and mobile) and staff use a new, dedicated Artsy Live web application, which is implemented in a project we call Prediction. iOS Artsy App users can also participate with newly developed UX within that app.</p>

<a name="The.web.app:.Prediction"></a>
<h2>The web app: Prediction</h2>

<p>Our bidder and operator web interfaces are implemented in an application we call Prediction, a <a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.ev1yd3juy">universal</a> <a href="https://facebook.github.io/react/">React</a>+<a href="http://redux.js.org/">Redux</a> Javascript app, served from an <a href="http://expressjs.com/">Express</a> server. Using React allowed us to completely share our view layer code for prerendering in the server and making updates in the client.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Prediction%20Bidder%20Screenshot.png" alt="Prediction Bidder UI" /></p>

<p>Keeping our state management and transition code organized with Redux allowed us to achieve a massive amount of reuse of model and controller code between our web interfaces. To solve Redux's <a href="http://stackoverflow.com/q/34570758/807674">async</a> and <a href="http://stackoverflow.com/q/34299460/807674">data conveyance</a> “problems", we built an integration layer for React and Redux called <a href="https://github.com/artsy/react-redux-controller">React Redux Controller</a>.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Prediction%20Operator%20Screenshot.png" alt="Prediction Operator UI" /></p>

<p>We found the React+Redux approach to model-view-controller app development to be a major win in what it gave us for maintainability, code reuse, easy testability, and the ability to reason about our code.</p>

<a name="The.iOS.native.app:.Eigen"></a>
<h2>The iOS native app: Eigen</h2>

<p>For users of the Artsy iOS app, known to our engineering team as <a href="https://github.com/artsy/eigen">Eigen</a>, a touch-optimized LAI experience was coded in Swift. It shares the same app with existing Objective-C code as well as <a href="https://facebook.github.io/react-native/">React Native</a> code used for other aspects of the iOS experience. We considered using React Native for this, but we decided to go with more familiar technology to contain the risk.</p>

<p><img src="/images/2016-08-09-the-tech-behind-live-auction-integration/Eigen%20Bidder%20Screenshot.png" alt="Eigen Bidder UI" /></p>

<p>Both of these applications interact with our central Artsy back-end service to pull in artist, artwork, and sale metadata when the user enters the auction. These queries are mediated by a <a href="http://graphql.org/">GraphQL</a> middleware service we call <a href="https://github.com/artsy/metaphysics">Metaphysics</a> (also discussed <a href="/blog/2016/06/19/graphql-for-mobile/">here</a>), which vastly simplified the fetching process in the front-end services. But from that point forward, the apps interact with a brand new auction state management system over a bidirectional <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a> API for live updating.</p>

<a name="The.auction.state.management.service:.Causality"></a>
<h1>The auction state management service: Causality</h1>

<p>The other recently launched piece of software delivered for LAI was a new auction state management system we call Causality. It processes bids and other auction events, computes the derived state of a sale, and hosts the bidirectional WebSocket API.</p>

<p>Causality was developed in Scala, using the <a href="http://doc.akka.io/docs/akka/current/intro/what-is-akka.html">Akka</a> technology suite for distributed computing. At its core is an append-only storage engine, based on <a href="http://doc.akka.io/docs/akka/current/scala/persistence.html">Akka Persistence</a>, with a small library we developed called <a href="https://github.com/artsy/atomic-store">Atomic Store</a> that allowed us to achieve strict consistency, at the cost of maximal throughput -- a trade-off that is explored in the readme of that project.</p>

<p>Lastly, Causality has an <a href="http://doc.akka.io/docs/akka/current/scala/http/introduction.html">Akka HTTP</a>-based API layer, with a WebSocket server implemented using <a href="http://doc.akka.io/docs/akka/current/scala/stream/stream-introduction.html">Akka Streams</a>. Asynchronous updates generated in the event processing logic are published across the cluster using <a href="http://doc.akka.io/docs/akka/current/scala/distributed-pub-sub.html">Akka Distributed Pub/Sub</a>, and they are merged into the WebSocket outflow.</p>

<a name="Pre-bidding..tooling..and.other.concerns"></a>
<h1>Pre-bidding, tooling, and other concerns</h1>

<p>In addition to accepting bids placed during a live sale, we also allow users to place bids before the event begins. In practice, this is almost the same workflow as our existing timed auction experience. For this reason, we chose to leverage all of our existing technology. The work of preparing our preexisting tech for LAI involved widespread modifications to our front-end UI, messaging services, admin tooling, and monitoring to make them appropriate for a live sale, as well as a reliable handoff of responsibility from these preexisting front- and back-end services to the new ones at the time the sale goes live.</p>

<p>We relied on our automated test suites, as well as thorough manual testing by the entire Artsy auctions team, to ensure that this handoff functioned smoothly under various circumstances. We will eventually eliminate this duplication. But this will require delicate refactoring of our preexisting tooling, which we will take on, even as we execute a fall auction season significantly busier than the last.</p>

<a name="Reflection"></a>
<h1>Reflection</h1>

<p>In the process of architecting our LAI product, we had to make some tough decisions in the face of new challenges. Chief among these were the decisions on where on the spectrum of bleeding-edge technology versus tried-and-true choices to land, for many of our subcomponents. Bleeding-edge tech often offers more elegant and performant solutions, but at the cost of learning curve and risk of immaturity. We also had to carefully prioritize functionality. Choosing wisely througout the process was critical to shipping on time. The rationale behind these decisions and their outcomes will be the result of future pieces.</p>

<p>To close, I want to express huge thanks to the auctions product &amp; engineering team for putting in long hours to design, implement, and troubleshoot the software; the auctions arts team for providing the domain knowledge and operational feedback; and our broader Artsy engineering team, at least half of whom directly contributed code to this effort.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trying out React]]></title>
    <link href="http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react/"/>
    <updated>2015-04-08T11:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react</id>
    <content type="html"><![CDATA[<p>We recently picked up a Rails application that was a few features away from completion. This application allows our <a href="https://www.artsy.net/about/the-art-genome-project">Genome Team</a> to classify multiple artworks based on visual and art historical characteristics. These characteristics, or "genes", can be added, removed, and changed for any of the artworks on the panel.</p>

<center><img src='/images/2015-04-08-creating-a-dynamic-single-page-app-for-our-genome-team-using-react/helix_screenshot.png'></center>


<p>Our genomers are masters of efficiency, and over the years we have worked closely with them to tailor a dynamic interface to their specific workflow.</p>

<p>When we started working on the app, the back-end was organized, modular, and interfaced seamlessly with the Artsy API, but there were still a few front-end features we needed to implement before it could be used by the Genome Team. The app did not use a front-end framework, and as our features scaled it was difficult to keep track of UI state with pure CoffeeScript and global event listeners. Eventually, we decided to stop trying to patch our leaky roof and build a new one.</p>

<!-- more -->


<a name="Choosing.a.Suitable.Framework"></a>
<h3>Choosing a Suitable Framework</h3>

<p>We decided to introduce a front-end framework to make it easier to add new features, and spent a day researching different options. Our requirements were:
- A robust view layer that could work on top of our already-solid Rails back-end,
- A framework performant enough for an interaction-heavy single-page app with hundreds of editable fields autosaving on change,
- A streamlined framework that favors freedom over unnecessary structure.</p>

<p>We chose <a href="http://facebook.github.io/react/">React</a>, Facebook's view layer framework, because it provides much-needed structure and support for components in a single page app without too much boilerplate.</p>

<p>Our plan was to eventually replace all of the existing <code>*.haml.erb</code> templates and global CoffeeScript mixins with discrete React components. We used the <a href="https://github.com/reactjs/react-rails">react-rails</a> gem, which easily integrates React components with Rails views.</p>

<p>In line with the <a href="https://facebook.github.io/react/docs/tutorial.html">React tutorial</a>, we first broke up our UI into functional and visual components. For each component we found the relevant HAML template, converted it into <a href="https://facebook.github.io/react/docs/jsx-in-depth.html">jsx</a> and React components using dummy data, and eventually updated it to accept the correct state from our top-level component which did all of the dynamic fetching and saving. Then we deleted the associated HAML and CoffeeScript code.</p>

<a name="Thinking.the.React.Way"></a>
<h3>Thinking the React Way</h3>

<p>At this point we have replaced the majority of the app's front-end with React components. We love React because it encourages you to follow certain <a href="http://www.reactivemanifesto.org/">ideological conventions</a>, but it does not force you into a structure that may not exactly align with your goals.</p>

<p>In React, having a single source of truth is ideal. Gone are liberally distributed global event listeners that can conflict and cause pages to get bogged down with transition logic. State is held at the topmost level in React and when state changes, React automatically re-renders only the affected components.</p>

<p>For example, we hold a hash <code>artworks</code> in the highest-level state of the page:
<code>javascript
getInitialState: function() {
  var artworks = _.map(this.props.artwork_ids, function(id) {
    return [id, {
      _id: id,
      isLoaded: false,
      isSelected: false,
      isMinimized: false
    }];
  });
  return {
    artworks: _.object(artworks),
    ...
  }
},
</code></p>

<p>We also store a method at this level to update the <code>artworks</code> state when there is a change:
<code>javascript
updateArtwork: function(artwork_id, cb) {
  // finds an artwork, passes it to callback (cb) to be mutated,
  // sets the mutated artwork on state from the return value of
  // the callback
  var new_artwork = cb(this.state.artworks[artwork_id]);
  var state_copy = this.state;
  state_copy.artworks[artwork_id] = new_artwork;
  this.setState(state_copy);
},
</code></p>

<p>That method is passed to child components, and when there is an update to an <code>artwork</code>, such as when it becomes selected, we invoke it to update all affected components:
<code>javascript
changeIsSelected: function (e) {
  e.preventDefault();
  var newSelectedState = !this.props.artwork.isSelected;
  this.props.updateArtwork(this.props.artwork._id, function(artwork) {
    artwork.isSelected = newSelectedState;
    return artwork;
  })
},
</code></p>

<p>React lets us define our components and interactions in a declarative style instead of stringing together possible transitions triggered by events. Before converting this app to React, we had many bugs around form submission and saving genome progress. However, by modeling state instead of UI transitions, we can easily track changes and save progress incrementally in the background without requiring a page refresh from the user.</p>

<a name="From.CoffeeScript.to.React:.Selecting.Artworks"></a>
<h4>From CoffeeScript to React: Selecting Artworks</h4>

<p>In this app, genomers are able to 'select' artworks on the panel for the purposes of saving and conducting batch actions. In our initial implementation, clicking the 'select all' button would individually click each artwork and used global event listeners to change UI state:</p>

<pre><code class="javascript">($ 'body').on 'click', '.artwork-selector', (evt) -&gt;
  container = $(this)
  currentSlug = container.data('id')
  artworkIdsElement = $('#selected_artwork_ids')
  selectedArtworkIds = _.compact(_.uniq(artworkIdsElement.val().split(',')))
  indexOfCurrentSlug = selectedArtworkIds.indexOf(currentSlug)
  if selectedArtworkIds.indexOf(currentSlug) != -1
    selectedArtworkIds.splice(indexOfCurrentSlug, 1)
    container.text('Not selected')
    container.removeClass('btn-purple')
  else
    selectedArtworkIds.push currentSlug
    container.text('Selected')
    container.addClass('btn-purple')
  $('#selected_artwork_ids').val(selectedArtworkIds.join(','))
  return false
</code></pre>

<p>With React, we store whether or not an artwork is selected as part of our state, and the appearance of elements results from this variable. We use <a href="https://facebook.github.io/react/docs/class-name-manipulation.html">class sets</a> to dynamically alter styles such as button color. When the <code>selected</code> state changes, React re-renders all components that depend on that variable.</p>

<pre><code class="javascript">var SelectedButton = React.createClass({
  changeIsSelected: function (e) {
    e.preventDefault();
    var newSelectedState = !this.props.artwork.isSelected;
    this.props.updateArtwork(this.props.artwork._id, function(artwork) {
      artwork.isSelected = newSelectedState;
      return artwork;
    })
  },
  render: function() {
    var cx = React.addons.classSet;
    var selectedButtonClasses = cx({
      'btn-purple': this.props.artwork.isSelected,
      'btn-tiny': true,
      'btn': true,
      'artwork-selector': true
    });
    return (
      &lt;div className="panel-artwork-actions"&gt;
        &lt;a className={selectedButtonClasses}
           data-id='false'
           href='#'
           onClick={ this.changeIsSelected }&gt;
         {this.props.artwork.isSelected ? '' : 'Not '}Selected&lt;/a&gt;
      &lt;/div&gt;
    )
  }
});
</code></pre>

<a name="Challenges"></a>
<h3>Challenges</h3>

<a name="React.s.Virtual.DOM"></a>
<h4>React's Virtual DOM</h4>

<p>React keeps track of a Virtual DOM created by components you define. This can lead to issues, especially when trying to integrate React with jQuery plugins. For example, our modals kept showing up within other components until we explicitly rendered them on the outermost level. We also had issues trying to use an existing drag/drop plugin with the way we set up our state, and ended up <a href="https://gist.github.com/sweir27/4ea941dd717da69527d6">building one from scratch</a>.</p>

<p>React also crashes when the Virtual DOM becomes out-of-sync with the page DOM. We unearthed a mysterious bug in which the browser was automatically inserting a <code>tbody</code> tag when it saw a table rendered without one... causing React (and therefore our entire app) to crash. In order to rectify this, we had to explicitly include these normally optional tags:
<code>javascript
if (geneList.length) {
  var results = (&lt;table className="triple-margin-top"&gt;
                   &lt;thead&gt;{DictionaryView.header}&lt;/thead&gt;
                   &lt;tbody&gt;{geneList}&lt;/tbody&gt;
                 &lt;/table&gt;);
 } else {
   var results = null;
 }
</code></p>

<a name="Working.with.the.React.Lifecycle"></a>
<h4>Working with the React Lifecycle</h4>

<p>Sometimes it is unavoidable to model transitions directly with JavaScript/jQuery, instead of using React's built-in lifecycle methods. In one case, we had to dynamically change the top padding of a component based on the height of a different one. Although we tried to do this using the <a href="https://facebook.github.io/react/docs/component-specs.html">React lifecycle</a> methods, there ended up being too many edge cases and we were having to add more and more states just to avoid:</p>

<pre><code class="javascript">currentTemplateHeight=$('.panel-template-wrap').height();
$('.panel-data-items').css('padding-top', currentTemplateHeight);
</code></pre>

<p>In this case, we found it more straightforward to go with the jQuery solution.</p>

<a name="React....Refactor"></a>
<h3>React == Refactor</h3>

<p>When we started out converting the app to React, it was hard to know whether or not an element should be its own component or if it could exist within another one. Often when we add new features, we have to refactor to make sure that we are reusing components and maintaining a single source of truth.</p>

<p>For example, we originally had one component to hold metadata on an artwork, such as artist, title, and date:
<code>javascript
var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    var artistName;
    var artworkTitle;
    var artworkDate;
    ...
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist['name']) {
      artistName = &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;;
    } else {
      artistName = &lt;span&gt;Unattributed&lt;/span&gt;;
    }
    artworkTitle = this.props.artwork.title ? this.props.artwork.title : 'Untitled';
    artworkDate = this.props.artwork.date ? this.props.artwork.date : 'No Date';
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;div className="artist-name"&gt;
              {artistName}
            &lt;/div&gt;
            &lt;div className="title"&gt;
              {artworkTitle}
            &lt;/div&gt;
            &lt;div className="date"&gt;
              {artworkDate}
            &lt;/div&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></p>

<p>When we implemented a new 'minimized' view for artworks, we also showed the title and artist, and so we broke these bits of information into separate components:
```javascript
var ArtistName = React.createClass({
  handleClick: function() {
    if (this.props.artwork.artist['name']) {
      this.props.setTemplateArtistId(this.props.artwork.artist['_id'])
    }
  },
  render: function() {
    var artistName;
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist['name']) {
      artistName = <a className="artist-as-template-link"
                      data-template-id={this.props.artwork.artist['_id']}
                      onClick={this.handleClick}
                      data-template-type="Artist" href="#">
                    {this.props.artwork.artist['name']}
                  </a>;
    } else if (this.props.artwork['cultural_maker']) {
      artistName = <span>{this.props.artwork['cultural_maker']}</span>;
    } else {
      artistName = <span>Unattributed</span>;
    }
    return (
      <div className="artist-name">
        {artistName}
      </div>
    );
  }
});</p>

<p>var ArtworkTitle = React.createClass({
  render: function() {
    var artworkTitle = this.props.artwork.title ? this.props.artwork.title : 'Untitled';
    return (
      <div className="title">
        {artworkTitle}
      </div>
    );
  }
});</p>

<p>var ArtworkDate = React.createClass({
  render: function() {
    var artworkDate = this.props.artwork.date ? this.props.artwork.date : 'No Date';
    return (
      <div className="date">
        {artworkDate}
      </div>
    );
  }
});
```</p>

<p>And updated our parent to reuse the new child components:
<code>javascript
var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;
            &lt;ArtworkTitle artwork={this.props.artwork} /&gt;
            &lt;ArtworkDate artwork={this.props.artwork} /&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></p>

<a name="Writing.Specs"></a>
<h3>Writing Specs</h3>

<p>All of the existing specs for the app were written in RSpec, so we chose to write integration tests using RSpec+Capybara. The headless Capybara webkit did not integrate with our React setup, so we switched to using Selenium as our Capybara JavaScript driver (which also conveniently let us debug our specs within the browser).</p>

<p>Our main challenge with specs had to do with RSpec not waiting long enough for components (such as autocomplete results) to appear, perhaps due to React's Virtual DOM. We spent many sad hours debugging spurious tests, and even included a few dreaded 'sleep' commands. Eventually, we integrated the <a href="https://github.com/y310/rspec-retry">rspec-retry</a> gem to retry spurious tests during CI.</p>

<a name="Conclusion"></a>
<h3>Conclusion</h3>

<p>Converting our app to use a React-based front-end went surprisingly smoothly. We were able to incrementally change certain templates to React components, which made it easy to test as we went along. Additionally, our development time in adding new features since then has decreased dramatically. It is much easier to add new components or edit existing ones when there is a single source of truth and you don't have to search through global event listeners.</p>

<p>Choosing a front-end framework is non-trivial but incredibly important, and we are glad we found React. Because it does not require much overhead and it is possible to only use it on a portion of a page, React can be integrated into small or large projects. Although we deliberated for a long time over whether or not to use a framework, we never regretted moving to React and investing in the future of the app.</p>
]]></content>
  </entry>
  
</feed>
