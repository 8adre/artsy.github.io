<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: danger | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/danger/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-09-12T19:45:32+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using VS Code for JavaScript]]></title>
    <link href="http://artsy.github.io/blog/2016/08/15/vscode/"/>
    <updated>2016-08-15T22:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/15/vscode</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<p>I'm an old school TextMate user, who has also been using Xcode for the last decade. These two sit at a very opposite ends of an "editor" spectrum.</p>

<p>TextMate is extremely bare bones at the core, but introduced the idea of bundles as plugins. Making it really easy for others to build their own plugins for their own contexts. Xcode on the other-hand includes a 3D scene editor, the best interface builder I've seen, super rich debugging tools and close to zero support for improving it yourself.</p>

<p>As we agreed on moving to React Native, we needed to decide what the team should use for <a href="https://github.com/artsy/emission/blob/master/docs/vscode.md">working in that environment</a>. After experimentation with many editors, we decided on Microsoft's <a href="https://code.visualstudio.com/">Visual Studio Code</a>.</p>

<p>We wanted to keep a lot of the best features from Xcode, while working in a completely JavaScript environment. For example: debuggers, inline errors, auto-complete, symbol mapping and to ideally have them all inside a single editor.</p>

<p>Let's dig into the principals of how Visual Studio Code works, what makes it a better option for us, and what parts of it really shine.</p>

<!-- more -->


<hr />

<h3>What is Visual Studio Code?</h3>

<p>Visual Studio Code (VS Code) is <em>yet another</em>, JavaScript-based text editor. It's built atop of GitHub's <a href="http://electron.atom.io">Electron</a>. Electron is a framework for writing native apps as easy as building websites. It started as a web component for some Microsoft web-service, and eventually evolved into a fully-fledged text editor.</p>

<h4>IDE - Editor hybrid</h4>

<p>Visual Studio Code (VS Code) believes that the sweet-spot between and IDE and a plain Text Editor, is somewhere a little bit closer to the IDE side.</p>

<p></div></div><a href='/images/vscode/editors.png'><img src="/images/vscode/editors.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>This means instead of the Text-Editor style folder based approach, VS Code expects to set up a project structure per-project to start supporting from of the more useful IDE-like features.</p>

<p>It supports TextMate style plugins (called Extensions) through a controlled, but expanding <a href="https://code.visualstudio.com/docs/extensions/overview">extension API</a>. The extension API work takes an <a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html">Apple-like</a> approach to ensuring stability by having all extensions run outside of the host process. <a href="https://code.visualstudio.com/docs/extensions/our-approach">This approach</a> ensures any extension crash does not take down the editor.</p>

<p>It's also smart about deciding when to load an extension, for example, my <a href="https://marketplace.visualstudio.com/items?itemName=Orta.vscode-danger">Danger</a> extension will <a href="https://github.com/orta/vscode-danger/blob/a21ccc101b2b1c1be595b10565bca9c88242fb6f/package.json#L18-L20">only load</a> if there is a <code>Dangerfile</code> in the root of the workspace.</p>

<p>These two approaches to extensions are specifically aimed at <a href="https://discuss.atom.io/t/why-is-atom-so-slow/11376">addressing issues</a> seen inside Atom, where any user actions can be / are blocked by extensions, and extensions have full-reign to make any change they want. Even on my Mac Pro, there is a noticable lag. I initially assumed this was the "JavaScript tax" for all Electron apps, but VS Code is fast.</p>

<h3>Making Intellisense</h3>

<p>By default a JavaScript project does not have a way to provide auto-completion, or in VS Code's terminology: Intellisense. Trying to make auto-complete based on a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> can only get you so far, because it has to be wary against functions with side-effects. Other alternatives are to build an <a href="http://jointjs.com/demos/javascript-ast">AST</a> from the code, and then introspect that.</p>

<p>In Xcode the auto-complete tools are powered by the type systems of Objective-C and Swift. This means that you can know the structure of an object, without having to dig inside it, potentially breaking it in the process. Vanilla JavaScript does not have a type system. There are a few root classes though: String, Object, Number etc.</p>

<p>To work around this problem, VS Code uses <a href="http://www.typescriptlang.org">TypeScript</a> behind the scenes. TypeScript is a language that compiles down to JavaScript which provides a typing structure on top of JavaScript. This is a similar approach to how <a href="https://flowtype.org">Flow works</a> too, which is the language <a href="https://github.com/artsy/emission/pull/220">we write React Native</a> in.</p>

<p>This can work out really well for your own classes if you are declaring your types, but the npm ecosystem is <em>full</em> of untyped JavaScript, and a lot of your work is about sitting atop those abstractions. The fix for this is offered via <a href="http://definitelytyped.org">DefinitelyTyped</a> which provides type definitions for popular npm modules. For example here is <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/redux/redux.d.ts">one for Redux</a> - these act like <a href="https://github.com/artsy/eigen/blob/master/Artsy/App/ARSwitchBoard.h">header files in Objective-C</a> - offering inline documentation, and the shape of the object.</p>

<p>I use an extension to keep these up to date and to have them installed in every project I work in: <a href="https://marketplace.visualstudio.com/items?itemName=jvitor83.types-autoinstaller">Types auto installer</a>. Here's an example of auto-complete for <a href="http://redux.js.org/docs/api/Store.html">a Redux store</a>.</p>

<p></div></div><a href='/images/vscode/redux.png'><img src="/images/vscode/redux.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It'll also provide information about the parameters, which is a life-saver for me. Having grown up with <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html">named</a> <a href="https://robots.thoughtbot.com/ruby-2-keyword-arguments">parameters</a>.</p>

<p></div></div><a href='/images/vscode/redux-params.png'><img src="/images/vscode/redux-params.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<h3>Runtime</h3>

<p>Using console logs to debug isn't an acceptable answer when debugging for me anymore. <a href="http://blog.cleancoder.com/uncle-bob/2016/07/27/TheChurn.html">That's churn</a> that I'm not willing to lose time to. Luckily for me, VS Code supports debugging across many languages.</p>

<p>It does this by having a generic VS Code <a href="https://code.visualstudio.com/docs/extensions/example-debuggers">Debug Protocol</a> which lets extensions use their own processes to run the debugger. So the ruby debugger runs on the <a href="https://github.com/rubyide/vscode-ruby#debugger"><code>ruby-debug-ide</code></a> gem, and for node-based projects it uses the debugger built into node.</p>

<p>So, here is a common case. I want to start up my web-server, so I need to run <code>npm dev</code>. I can run this from VS Code:</p>

<p></div></div><a href='/images/vscode/start.png'><img src="/images/vscode/start.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Once that's running - I can attach a debugger. This is listing all of the available node processes on my computer:</p>

<p></div></div><a href='/images/vscode/attatch.png'><img src="/images/vscode/attatch.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Then I can add a breakpoint, and when it is triggered, I have a full stack trace and REPL. The REPL is very barebones, for example - there's no auto-complete. However, it's good for quick exploration. I keep <a href="https://www.objc.io/issues/19-debugging/lldb-debugging/#printing-objects">accidentally prefixing</a> my REPL code with <code>po</code>.</p>

<p></div></div><a href='/images/vscode/debug.png'><img src="/images/vscode/debug.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>The breakpoint works through a <a href="http://blog.teamtreehouse.com/introduction-source-maps">source map</a>, and so the line you expect is the one that you're working in. That stuff is all pretty magic to me. Good on Microsoft, and the node community for pulling that off.</p>

<h3>Wrapup</h3>

<p>I still feel a little bit uncomfortable in JavaScript projects, as a long-time native developer. However feel like VS Code is a nice mix of the freeform "just do something" style of Text Editors, which work across a lot of systems and the tight-knit IDEs that are bound to a specific domain. It can be a bridge between worlds.</p>

<p>VS Code has become my main editor in Ruby and JavaScript, due to having great support for the projects and being an OSS project which I feel like I can contribute to. No more being <a href="https://github.com/alcatraz/Alcatraz/issues/475">locked out</a> of improving my editor. Awesome!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling Large OSS Projects Defensively]]></title>
    <link href="http://artsy.github.io/blog/2016/07/03/handling-big-projects/"/>
    <updated>2016-07-03T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/07/03/handling-big-projects</id>
    <content type="html"><![CDATA[<p>I help maintain big OSS projects: from a third-party <a href="https://cocoapods.org">dependency manager</a> used in most iOS apps (<a href="https://github.com/CocoaPods/cocoapods.org">CocoaPods</a>), to the most popular Objective-C <a href="http://cocoapods.org/pods/Specta">testing framework</a> and the most popular Swift <a href="http://cocoapods.org/pods/Moya">networking API client</a>. I've been doing this for years.</p>

<p>Projects with this much impact are big time-sinks. This time comes from ensuring infrastructure continues to work, support tickets need replies, new code needs reviewing and releases need coordinating.</p>

<p><img src="/images/2016-07-03-big-oss/danger_logo_black@2x.png" alt="" /></p>

<p>Last September, almost a year ago, I started work on a new project, <a href="https://github.com/danger/danger/">Danger</a>. Danger fixes a problem we were seeing in the Artsy mobile team around adding "<a href="https://github.com/artsy/mobile/issues/31">process</a>" to our team.</p>

<p>As a part of discussing Danger internally, I've referenced that building CocoaPods has greatly influenced Danger. This blog post is about the way I've built Danger, knowing fully well that I cannot afford the level of time to maintain it at the scale it may get to.</p>

<!-- more -->


<hr />

<p>Danger is a project that could end up with a lot more users than CocoaPods. So I want to be cautious about how I create the community around Danger. If you're interested in some of the baseline setup required to run a popular project, the post "<a href="https://ashfurrow.com/blog/building-popular-projects/">Building Popular Projects</a>" by <a href="/author/ash">Ash</a> is a great place to start, this builds on that.</p>

<p>My maintenance time on CocoaPods resolves around:</p>

<ul>
<li>Handling new issues</li>
<li>Keeping infrastructure running</li>
<li>Requests around user data</li>
<li>Keeping disparate communities together</li>
</ul>


<h2>Issues</h2>

<p>From the ground up, Danger could not end up as complex as CocoaPods, the domain they cover is different and CocoaPods sits atop of an annually moving (and <em>somewhat</em> hostile) <a href="https://developer.apple.com/news/">platform</a>.</p>

<p>However, get enough people using a product and you end up with three types of issues: Bug Reports, How Do I X? and Feature Requests.</p>

<p>I wanted to keep bug-reports down, as much as possible, and so I built a system wherein the default error reporting system would also search GitHub issues <a href="https://github.com/orta/gh_inspector">for similar problems</a>. Knowing this was a generic problem, I built it with <a href="https://github.com/fastlane/fastlane/releases/tag/1.96.0">other</a> <a href="https://github.com/CocoaPods/CocoaPods/pull/5421">large</a> ruby projects in mind too.</p>

<p><code>How do I X?</code> are issues that haven't appeared much on Danger. For CocoaPods we request people use the CocoaPods tag on StackOverflow. That saves us from 5 to 6 issues a day, and provides others a great place to get internet points by responding instead.</p>

<p>Feature Requests issues are always fascinating, it gives you a chance to really see the difference between what you imagined a project's scope is, and how others perceive it. One thing that helps here is that Danger has a <a href="https://github.com/danger/danger/blob/master/VISION.md">VISION.md</a> file. This helped vocalise a lot of internal discussion, and let contributors understand the roadmap:</p>

<blockquote><p>The core concept is that the Danger project itself creates a system that is extremely easy to build upon. The codebase for Danger should resolve specifically around systems for CI, communication with Peer Review tools and providing APIs to Source Control changes. For example: Travis CI - GitHub - git.</p></blockquote>

<p>As well as providing a heuristic for determining whether something should be added to Danger:</p>

<blockquote><p>This means that decisions on new code integrated into Danger should ask "is this valid for every CI provider, every review system and source control type?" by making this domain so big, we can keep the core of Danger small.</p></blockquote>

<h3>Infrastructure</h3>

<p>CocoaPods has about 6 web properties, 3 of which are critical. The others can go down, or be behind the Xcode update schedules and people's projects will work fine. The 3 the critical projects are all simple, focused projects: <a href="https://github.com/CocoaPods/trunk.cocoapods.org">trunk</a> (provide auth, and submitting new libraries) <a href="https://github.com/CocoaPods/cocoapods.org">cocoapods.org</a>, and <a href="https://github.com/CocoaPods/search.cocoapods.org">search</a>. We control everything there.</p>

<p>Meanwhile the less critical ones like <a href="https://github.com/CocoaPods/cocoadocs.org">cocoadocs.org</a> have dependencies all over the show: AppleDoc, CLOC, Xcode, Carthage, Jazzy - every one of these can, and has, been a source of unreliability for infrastructure that I maintain.</p>

<p>With Danger, I wanted to avoid building any infrastructure that does not sit on top of solid, mature projects. The website is statically created in <a href="https://middlemanapp.com">Middleman</a>, using <a href="https://rubygems.org/gems/slim">boring</a> <a href="https://rubygems.org/gems/sass">old</a> technology, this means no server to host.</p>

<p>To support dynamic content on the website, I have a rake command to use <a href="https://rubygems.org/gems/yard/versions">a decade old</a> documentation formatter to pull content from a <a href="https://en.wikipedia.org/wiki/RubyGems">13 year old</a> dependency manager - that lets others describer their project's. In order to let them keep it up to date, I have a tiny 35 line web-server that allows specific projects to trigger a new CI build.</p>

<h3>Plugins</h3>

<center>
<blockquote class="twitter-tweet" data-lang="en-gb"><p lang="en" dir="ltr">Summary of every big OSS project. Monolith -&gt; Plugin support.<a href="https://t.co/7x4vuW4bRd">https://t.co/7x4vuW4bRd</a></p>&mdash; Orta Therox (@orta) <a href="https://twitter.com/orta/status/748561323164864512">30 June 2016</a></blockquote> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>


<p><br/></p>

<p>It's almost inevitable that once a project becomes big, maintainers have to become a lot more conservative about how they introduce new code. You become good at saying 'no', but a lot of people have legitimate needs. So, instead you end up converting your tool into a platform.</p>

<p>Some of the most interesting ideas in the CocoaPods ecosystem come from plugins.</p>

<p>I wanted plugins to be a first class citizen within Danger from day one. It's in the <a href="https://github.com/danger/danger/blob/master/VISION.md">VISION</a> file, and it's applied into how I've designed a lot of the user-facing site. I was <a href="https://github.com/danger/danger/issues/74">torn</a> after a few months of development <a href="https://github.com/danger/danger/pull/156#issuecomment-205907128">where things</a> should go. Now the core of Danger is <a href="https://github.com/danger/danger/pull/227">built as plugins</a>.</p>

<h3>Documentation</h3>

<p>My second big project on CocoaPods was collating documentation and scoping different types of documentation. In CocoaPods I ended with:</p>

<ul>
<li><strong>Highlight pages</strong> (intro pages, app pages, team pages)</li>
<li><strong>Guides</strong> (tutorials, overviews, FAQs)</li>
<li><strong>Reference</strong> (Command-line interface, APIs for developers)</li>
</ul>


<p>These 3 buckets for documentation makes it pretty easy to separate where people should look depending on what they're looking for. This pattern I'm stealing outright for Danger. Just not quite yet, it's a blocker on 1.0 though.</p>

<p>One trick I took from CocoaPods is to have as much documentation as possible generated from the source code. With Danger, all of the work that's gone into documenting the code is turned into public API documentation for end-users. This makes it really easy to ensure it's consistent and up-to-date. The same tools used to generate documentation for Danger are used for plugins. Any improvements there helps everyone.</p>

<h2>User Data</h2>

<p>Not storing any, phew! Though if <a href="https://github.com/danger/danger/issues/42">Danger as a Service</a> happens, then it will.</p>

<h2>People</h2>

<p>People are hard, Ash said in <a href="https://ashfurrow.com/blog/building-popular-projects/">Building Popular Projects</a>:</p>

<blockquote><p>The biggest existential threat to your library is this: you get burned out and stop working on it – and no one else contributes to it –</p></blockquote>

<p>Understanding motivations, encouraging ownership and accommodating multiple viewpoints are vital parts of anyone who wants to make a project bigger than themselves. There <a href="https://github.com/danger/danger/graphs/contributors">are lots of times</a> when I'm not the lead developer on Danger.</p>

<p>I owe a lot of this to the policy Ash and I created with Moya, the wordy "<a href="https://github.com/Moya/contributors">Moya Community Continuity Guidelines</a>" which define the expectations of the maintainers of a project towards contributors.</p>

<p>It's helped let a lot of other contributors make an impact. In the future, I hope those are the people that I get to hand Danger off to. Danger is bigger than me.</p>

<hr />

<p>Maintaining big projects is a learned activity, for most people it's a spectator sport, but it's not too hard to jump from writing issues to helping out. It's how I ended up contributing to CocoaPods.</p>
]]></content>
  </entry>
  
</feed>
