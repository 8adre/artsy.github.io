<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: engineering | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/engineering/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-02-24T22:09:37+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kubernetes and Hokusai]]></title>
    <link href="http://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai/"/>
    <updated>2019-10-18T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai</id>
    <content type="html"><![CDATA[<p>When I joined Artsy Engineering a few months ago, I had roughly zero knowledge of Kubernetes. I'd heard the term
thrown around a few times, but had no idea how it worked or what it was used for.</p>

<p>Kubernetes is still a bit of a mystery to me, but I'm able to do a lot of Kubernetes operations quickly and easily
thanks to an open-source tool developed at Artsy: <a href="https://github.com/artsy/hokusai">Hokusai</a>.</p>

<p>In this post, I'll give some background on <a href="https://kubernetes.io">Kubernetes</a>, a brief history of Hokusai, a
description of its functionality, and some pointers for how to get started using it.</p>

<!-- more -->


<a name="What.is.Kubernetes."></a>
<h1>What is Kubernetes?</h1>

<p>On a high level, Kubernetes is a tool designed to <em>orchestrate containers at scale.</em></p>

<p>Let's break that down a bit. First, some helpful vocab:</p>

<p><strong>Container</strong>: Effectively code + all necessary dependencies for an application. A
<a href="https://www.docker.com/resources/what-container">"standardized unit of software"</a>.</p>

<p><strong>Pods</strong>: A group of one or more containers. One container per pod is the most common use case.</p>

<p><strong>Deployment</strong>: A Kubernetes component (read: program) that provides declarative updates to pods and manages their
lifecycles (i.e. creating new pods when new code is rolled out, rolling back to an earlier state, scaling up to
more pods, etc.).</p>

<p><strong>Node</strong>: A physical or virtual machine that runs a pod or pods.</p>

<p><strong>Cluster</strong>: A node or group of nodes.</p>

<p><strong>Container orchestration</strong>: A systemized approach to managing containers. Allows for things like auto-scaling,
easy rollouts and rollbacks, and automation of container downtime (i.e. something goes wrong in your process and
causes your app to crash; a new container gets spun up immediately so that your app doesn't go down).</p>

<p>Sources: <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">Kubernetes docs</a>,
<a href="https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html">Infoworld</a>,
<a href="https://www.docker.com/resources/what-container">Docker docs</a></p>

<p>Kubernetes, in a general sense, allows you to configure the containers in which your application will run. With a
properly configured Kubernetes cluster, this makes it easy to scale applications up or down as needed to deal with
traffic patters, maintain a zero-downtime deployment, and more. Very cool.</p>

<p>To sum up the structure of applications running on Kubernetes: clusters contain nodes which contain pods (which are
managed by deployments) which contain containers. This can be tricky to wrap your head around without
experimentation and personal experience—Hokusai aims to simplify the ways in which a developer can interact with
applications running on Kubernetes.</p>

<a name="What.is.Hokusai."></a>
<h1>What is Hokusai?</h1>

<p>When Artsy's Engineering team was contemplating a move to Kubernetes from Heroku, we had beef with a few things.</p>

<p>For one, we wanted to be able to do a few core things simply and easily using the command line. While Kubernetes
has a robust API and CLI tooling using <a href="https://kubernetes.io/docs/reference/kubectl/overview/">kubectl</a>, it's also
very complex. We wanted to be able to quickly and easily do the things we were used to doing with Heroku; we
preferred <code>heroku logs</code> to <code>kubectl logs [POD]</code> (where we would have to either look up or know the specific pod
name we wanted, even though pods are being spun up and taken down all the time).</p>

<p><a href="https://helm.sh">Helm</a>, the de-facto package manager for Kubernetes, also didn't quite fit our needs. Helm is
great for big, complex implementations with Kubernetes, and it's very useful for managing releases. Artsy
Engineering wanted something that didn't involve quite as many complex charts, and we're not as concerned as some
orgs with versioned releases since our focus is mostly on web apps.</p>

<p>Basically, we wanted our commands to be application-level instead of pod- or node-level. We wanted a little more
abstraction than was offered by <code>kubectl</code>, and a little less than Helm.</p>

<p>And there was the issue of review apps. Review apps are basically standalone versions of an application that fall
completely outside a normal production pipeline. They allow you to test big or scary changes in functionality
without even putting them on a staging instance (which could affect other developers' work or be deployed
accidentally).</p>

<p>Kubernetes doesn't support review apps out of the box. There are some add-ons that offer them, but at the time
Artsy was looking to switch, I don't think they existed or were widespread.</p>

<p>Thus was born Hokusai: a tool that makes interacting with applications deployed on Kubernetes from the command line
simple. Need logs? <code>hokusai production logs</code>. Need to run a rake task? <code>hokusai staging run 'rake db:migrate'</code>. Or
want to set up a review app? There are a
<a href="https://github.com/artsy/hokusai/blob/master/docs/Review_Apps.md">few steps involved</a>, but you can have a
fully-featured copy of your app up and running in a few minutes.</p>

<p>The end of this post has a larger cheatsheet for handy Hokusai commands, but for now, let's talk about how you can
use it yourself.</p>

<a name="How.can.I.set.up.Hokusai.with.my.project."></a>
<h1>How can I set up Hokusai with my project?</h1>

<p>I should begin by noting that Hokusai is developed to work with AWS—if your application is running on a different
provider, you might have to hold off on Hokusai for now :( (or
<a href="https://github.com/artsy/hokusai">open a PR in Hokusai</a> yourself!) We do aim to support more clouds in the future,
and Hokusai mostly interacts directly with Kubernetes or Docker APIs.</p>

<p>Installing hokusai is super easy! You can see full instructions in the README on
<a href="https://github.com/artsy/hokusai">GitHub</a>, but if you're already set up with Python, pip, Docker, Docker Compose,
and Git, you can do a quick install of Hokusai packed by <a href="https://www.pyinstaller.org/">PyInstaller</a> with Homebrew:</p>

<pre><code>$ brew tap artsy/formulas
$ brew install hokusai
</code></pre>

<p>There's more robust directions
<a href="https://github.com/artsy/hokusai/blob/master/docs/Getting_Started.md">in the Hokusai repo</a>, but the very short
version is that <code>hokusai setup</code> handles most of the basics (creation of a Dockerfile, a config folder, and a few
other bits and bobs). From there, you can customize according to the needs of your project. It's also possible to
write boilerplate templates to share with developers in your organization—you can see Artsy's
<a href="https://github.com/artsy/artsy-hokusai-templates">here</a>.</p>

<p>You should also check out Ash's <a href="https://artsy.github.io/blog/2018/01/24/kubernetes-and-hokusai/">great post</a> on
setting up a new Hokusai project—he runs through the process of setting up a new Rails application with Hokusai in
an easy-to-follow way that also details small hitches he ran into along the way.</p>

<a name="What.s.next.for.Hokusai."></a>
<h1>What's next for Hokusai?</h1>

<p>As Hokusai has grown and changed over the years (the GH repo was created in November 2016!), a few things have
changed.</p>

<p>For one, it's been increasingly used in coordination with CircleCI. Hokusai has made it really easy to standardize
a lot of application configuration across Artsy's applications. We have
<a href="https://github.com/artsy/orbs/blob/master/src/hokusai">CircleCI orbs</a> set up for Hokusai specifically, which
standardize the way Hokusai is invoked in our CI, among other things. Given how helpful it's been to have a single
source of CircleCI config for many of our apps, we're pondering the idea of a central source for Kubernetes Hokusai
config. In other words, we'd like to have a "baseline" for things like deployments—something that could be
overriden as necessary in specific projects but would make spinning up new projects easy. This would effectively
allow Hokusai to support functionality similar to Helm's <a href="https://helm.sh/docs/chart_template_guide/">templates</a>,
but in a way that can be consumed across project repos.</p>

<a name="Hokusai.and.beyond"></a>
<h1>Hokusai and beyond</h1>

<p>Personally, Hokusai has been very useful to me as a kind of "training wheels" for Kubernetes. To be able to quickly
and easily start interacting with Kubernetes, even as a complete Kubernetes noob, was very empowering and helped me
be less intimidated by it. As I've spent more time interacting with Hokusai, I've started to understand what's
going on behind the scenes, and I've found myself poking around in the Kubernetes docs more than once. I'm excited
to keep learning more about Kubernetes and to start contributing to Hokusai!</p>

<p>Hokusai significantly lowers the barriers to interacting with Kubernetes apps and centralizes the complexity
inherent in doing so. It's been invaluable in transitioning our engineering team to working with Kubernetes. If you
or your organization are in the midst of a similar transition—or if you have a sharp divide in Kubernetes knowledge
and comfort within your team—we suggest giving it a try! Our issues are open for bug reports and feature requests,
and we certainly welcome PRs with improvements.</p>

<a name="Appendix.A:.Useful.Hokusai.commands"></a>
<h2>Appendix A: Useful Hokusai commands</h2>

<p>These are the commands I find myself using on a regular basis. If you're playing around with Hokusai, you can also
run most commands with <code>--help</code> to get more information on their usage.</p>

<ul>
<li><code>hokusai [production|staging] env get</code>: Print all of the environment variables from your application's pod</li>
<li><code>hokusai [production|staging] env set "ENV=value"</code>: Set an environment variable on your application's pod</li>
<li><code>hokusai [production|staging] run 'rake db:migrate'</code>: run a Rails migration</li>
<li><code>hokusai [production|staging] run 'bundle exec rails c' --tty</code>: Open a Rails console for your app (I have this
one aliased to <code>hokusai-[production|staging]-console</code>)</li>
<li><code>hokusai [production|staging] refresh</code>: Refresh the application's deployment by recreating its containers</li>
<li><code>hokusai build</code>: Build your application's Docker image as defined in a <code>hokusai/build.yml</code> file</li>
<li><code>hokusai test</code>: Boot a test environment and run a test suite as defined in <code>hokusai/test.yml</code></li>
<li><code>hokusai pipeline gitcompare --org-name [org]</code>: Spits out a URL for a git comparison between production and
staging images</li>
<li><code>hokusai pipeline gitlog</code>: Print a git log for commits between the image deployed on production and the image on
staging. Handy if you need to get the SHA of a staged commit quickly, e.g. for rollback purposes (?)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Projects Need Code Names]]></title>
    <link href="http://artsy.github.io/blog/2019/05/10/why-projects-need-codenames/"/>
    <updated>2019-05-10T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/05/10/why-projects-need-codenames</id>
    <content type="html"><![CDATA[<p>Before I joined Artsy, I worked at companies where software projects tended to have meaningful, predictable names. If we were building a system for flagging media uploads, it might be called <code>media-review</code>. In many cases, our code repositories' names matched the main product's branding or even the company's name. Life was simple and there was no risk of ambiguity.</p>

<p>At Artsy, our systems have peculiar code names like <em>Gravity</em>, <em>Pulse</em>, and <em>Vortex</em>. There's a persistent learning curve as you contribute to different repositories or as new services get created. Numerous times, I've wondered: are code names worth the trouble?</p>

<!-- more -->


<p><img src="/images/2019-05-10-why-projects-need-codenames/github_projects.png" alt="" /></p>

<p>To be clear, <em>any</em> project naming scheme works in small quantities. Personal projects or libraries for public release should probably just be named for clarity and find-ability. Code names start to offer benefits as a team grows and a product evolves over the longer term:</p>

<p>Code names embrace that <strong>we don't necessarily know the fit or scope of a system when it's first conceived</strong>. To <em>not</em> employ code names would require accurately predicting a system's eventual function. A project named <code>artsy-admin</code> starts to grate when we make the architectural decision to split apart management utilities or introduce more fine-grained administrative roles. An <code>artwork-taxonomy</code> label loses meaning when that system expands to include less structured tags</p>

<p><strong>Branding shifts, products pivot, and companies merge.</strong> Project code names introduce a level of indirection between what engineers build and the labels, URLs, or brands that end users experience. Over a long enough period, these external or superficial changes <em>will</em> happen and risk introducing confusion or just subtle misalignment between form and function. As with software design in general, abstractions can be a powerful tool to <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separate concerns</a>. Ask yourself: what code changes might be required if your company were to spin off your product or be merged into an acquirer?</p>

<p><strong>Language is important</strong>, and not just for communication but for shaping our thoughts and assumptions. We frequently find ourselves debating which system should serve as the authority for a given domain model or where to implement a new feature, and project names that overlap with these topics (e.g., <code>search</code>, <code>images</code>, <code>suggestions</code>) would predispose us to certain decisions. Code names free us to focus on the architectural and organizational merits instead.</p>

<p>We like to <strong>have fun at work</strong> and it's more joyful to proclaim that "Torque is in the wild" than "data-sync has been deployed." Over time these names gain mythologies and personalities within the team and organization.</p>

<p>With this in mind, how should you choose a naming scheme?</p>

<a name="Rules.for.a.project.naming.scheme"></a>
<h2>Rules for a project naming scheme</h2>

<ul>
<li>Avoid implicit value judgments like "new," "next," or "modern." We've all witnessed today's hot project become next year's unloved albatross.</li>
<li>Choose a code name scheme that isn't directly related to your technology or business. A flower business using flower names is cute, but breaks down when you want to build a feature that <em>actually</em> is about tulips.</li>
<li>Everyone should be able to participate, so avoid industry lingo or obscure terminology. Funny story: I work at an art start-up but don't know enough artists to name my projects that way. I struggle even more to pronounce the few projects that are.</li>
<li>There should be lots of choices. You'll regret choosing to name your projects after "decathlon sports" or "days of the week" when your team inevitably transitions to microservices.</li>
<li>Names should be unique within a company and--ideally--beyond the company's scope. You wouldn't want your <code>marketing-site</code> repository to conflict with a contributor's <code>marketing-site</code> repository from another organization. Github projects, S3 buckets, Heroku application names, and published libraries all benefit from being globally unique.</li>
<li>Bonus points for choosing a rich enough scheme that names can subtly relate to each system's function. At Artsy, we use physics terms for code names, so our e-commerce back-end is called <a href="https://github.com/artsy/exchange">Exchange</a> and a command line utility for developers is called <a href="https://github.com/artsy/momentum">Momentum</a>. A shipping service might be called <em>Weight</em>.</li>
</ul>


<p>Example code name schemes: animals, movies, sea creatures, cartoon/TV characters, woodworking tools, celebrities (but get legal advice before borrowing living individuals' names). <a href="https://wiki.ubuntu.com/DevelopmentCodeNames">Ubuntu</a> gets extra mileage by combining adjectives with animal names. <a href="https://en.wikipedia.org/wiki/List_of_Apple_codenames">Apple</a> has used wine, cats, and California geography. <a href="https://en.wikipedia.org/wiki/Android_%28operating_system%29">Google</a> likes dessert.</p>

<a name="Finally"></a>
<h2>Finally</h2>

<p>These days, I've embraced Artsy's use of physics terms for project names. There continues to be some head-scratching as new engineers navigate codebases and encounter these terms or just struggle to identify the system responsible for a given site or feature. (This isn't shocking, since code names were probably adapted from more secretive environments like the military.) As your code names multiply and projects come and go, a glossary becomes essential. I suggest creating a simple document that maps projects' code names to descriptions, URL destinations, hosting environments, and teams.</p>

<p>See also:</p>

<ul>
<li><a href="https://blog.codinghorror.com/whats-in-a-project-name/">What's in a Project Name?</a></li>
<li><a href="https://royal.pingdom.com/the-developer-obsession-with-code-names-186-interesting-examples/">The Developer Obsession With Code Names, 186 Interesting Examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So You Want to Be an Engineer]]></title>
    <link href="http://artsy.github.io/blog/2019/03/12/so-you-want-to-be-an-engineer/"/>
    <updated>2019-03-12T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/12/so-you-want-to-be-an-engineer</id>
    <content type="html"><![CDATA[<p>First of all, that's very exciting! Software engineering is pretty darn cool—you get to learn lots of new things,
understand the technology you use every day better, and contribute to the mysterious maw known as "the internet".</p>

<p>Last February, I also decided that I wanted to pursue computer engineering. I'd been at Artsy for a bit less than
two years at that point, first as a marketing intern working on SEO and then as a coordinator on the CRM (read:
email) team. I'd consistently been working on small technical projects; first doing
<a href="https://github.com/artsy/positron/commit/3176282a3ea94c626e9d851b7c0dd27a1bb0fcb4">some work</a> on a tool for SEO
optimization for our Editorial team, then building
<a href="http://artsy.github.io/blog/2018/11/19/mjml/">emails with MJML</a>, and a few other bits and bobs. But I didn't think
of it as a serious pursuit.</p>

<p>Mostly, that was due to my experience programming in the past—I did about half a CS major in undergrad. At the
time, I felt that programming wasn't right for me, and I dropped the major during my third year.</p>

<p>It was Artsy's Engineering team that convinced me that programming was something that I both wanted to and could
do. Our engineers have always welcomed learners and been happy to answer questions and empower other teams to do
technical work. I eventually realized that the parts of my work where I was coding were the parts I enjoyed the
most, and that I would likely feel more fulfilled if I made programming my full-time occupation.</p>

<p>Here's what that journey looked like. Hopefully my experience proves helpful to you as you begin (or finish) yours!</p>

<!-- more -->


<a name="Step.One:.Tell.People.What.You.Want"></a>
<h1>Step One: Tell People What You Want</h1>

<p>This might've been the single biggest learning I took away from this experience: <em>if you tell people you want
something, you might just get it.</em></p>

<p>That may sound super obvious. It wasn't for me. I've usually been very passive in my career decisions, taking the
path of least resistance and considering myself lucky when I was able to keep progressing. In this case, I was
making a substantial departure from that idea by being proactive about what it was I wanted.
<a href="https://engineering.gusto.com/i-didnt-want-to-be-a-manager-anymore-and-the-world-didnt-end/">This post</a> by
<a href="https://twitter.com/NoaElad">Noa Elad</a> does a great job with this topic and is certainly worth a read.</p>

<p>The first person I told at Artsy was <a href="https://twitter.com/orta">Orta</a>. He'd often encouraged me to develop my
technical skills, and since he knows Artsy's engineering team and stack better than just about anyone, I figured
he'd be able to point me in the right direction when it came to learning resources and navigating company politics
to get to my eventual goal.</p>

<p>The second person I told was my manager on the CRM team. I fortunately had a very good relationship with my manager
and was confident that she would help me if she could. And by telling her early, I was giving her more opportunity
to advocate for me and making it easier for her to replace me in the event that I was able to switch teams.</p>

<p>The third person I told was Artsy's CTO, <a href="https://www.dblock.org/">dB</a>. This was Orta's recommendation—dB would be
able to tell me if and when a move might be possible, and he could suggest things I should do to improve my chances
of making the switch.</p>

<p>I also didn't keep it a secret from the rest of my team or the company. I didn't show up wearing a shirt that said
"ENGINEER" on it, but I told people, "I'm working on becoming an engineer. I'm really hoping to stay at Artsy, but
if there's not a role open for me, that's fine—I'll search elsewhere."</p>

<p>The net outcome of these conversations was that there wasn't a role open right then (and that I still had lot to
learn before I'd be ready when one became available), but I also left with a better idea of what I should learn and
what I could expect from the coming months.</p>

<a name="Step.Two:.Figure.Out.What.You.Want.to.Learn"></a>
<h1>Step Two: Figure Out What You Want to Learn</h1>

<p>The answer to that question really depends on who you are, where you work, and where you <em>want</em> to work.</p>

<p>I wanted to work at Artsy, and I felt that I was most interested in front-end work. So I asked a few of our
engineers to help me understand our stack and to recommend frameworks/languages I should learn.</p>

<p>If you're interested in changing companies as well as careers, it's worth seeing if your target company or
companies have open source code you can check out. See if you can find them on <a href="https://www.github.com">GitHub</a> and
look at some of their recently updated repos. If you already have some coding experience, see if you can contribute
a little bit—even fixing small bugs or typos is a good place to start, since you're both contributing to their
codebase (which will help you if you land an interview) and learning more about their stack. dB recommended that I
do this with Artsy's code.</p>

<p>As with most companies that have been around for more than a year or two, Artsy is home to projects with many
different stacks. However, most of our newer front-end stuff—things that are recently updated or currently in
development—is built on React using TypeScript. So my first question was "what do I need to know in order to write
TypeScript code in a React framework?"</p>

<p>Fortunately, a lot of other people have the same question.</p>

<a name="Step.Three:.Decide.How.You.Want.to.Learn.It"></a>
<h1>Step Three: Decide How You Want to Learn It</h1>

<p>First: <strong>there is no wrong way to go about learning to code</strong>. Whether it takes you 6 months or 6 years, whether
you learn one language or a dozen, whether you ask for a lot of help or do it all yourself, <strong>you are learning and
that is valuable</strong>. Learning to code is not a magical skill. Like just about everything, it's a matter of putting
in time. Just keep trying, even small things, and you <em>will</em> make progress.</p>

<p>Lots of people who want to become engineers go to coding bootcamps like <a href="https://flatironschool.com/">Flatiron</a> or
<a href="https://generalassemb.ly/">General Assembly</a>. That's a very reasonable thing to do! I had a decent grounding in CS
fundamentals thanks to my experience in undergrad, and as a result, I initially decided I wouldn't do a coding
bootcamp—I felt I had enough experience to benefit from the multitude of online courses and open source projects
out there.</p>

<p>However, there are definitely real and significant benefits do doing a bootcamp. Here are three that I can think
of:</p>

<ol>
<li>Clear curriculum. At times, I was overwhelmed by the possible ways to proceed and stopped making progress as a
result. Bootcamps take the guesswork out.</li>
<li>Timeline. Because I didn't have a hard date set for a transition or interview, it was up to me to determine how
fast/slow I worked on things, and I stagnated at times as a result.</li>
<li>Community. While the open source community is very much a real thing, and you can find lovely people on the
internet who want to help learners like yourself, it's not the same as having multiple people learning the same
thing at the same time in the same physical space.</li>
</ol>


<p>The downsides, of course, are that coding bootcamps are expensive and time-consuming. Most of us don't have the
luxury to leave a job, pay $10K – $15K in fees, and spend a couple months at a full-time bootcamp with no income.
There are other models, such as online-only bootcamps or after-hours classes, but those come with challenges of
their own.</p>

<p>I'd say that If you can afford a bootcamp and have the time, it's a great way to jumpstart a coding career, but you
don't have to attend one to become a good engineer.</p>

<p>If you decide to go the non-bootcamp route, you also have a lot of good options. I did courses through
<a href="https://www.udemy.com">Udemy</a>, which has a lot of courses that are literally always on sale for $10 - $20. There
are many other similar services out there as well, like <a href="https://www.udacity.com">Udacity</a>,
<a href="https://www.codecademy.com/">Codecademy</a>, and <a href="https://teamtreehouse.com/">Treehouse</a>.</p>

<p>I also highly recommend attending IRL meetups, because that's where you can make connections and learn from others
most easily. I'm a semi-regular attendee at the <a href="https://www.meetup.com/CocoaPods-NYC/">CocoaPods meetup</a> hosted by
<a href="https://twitter.com/ashfurrow">Ash</a> and Orta at Artsy HQ, and <a href="https://www.meetup.com/find/tech/">meetup.com</a> and
<a href="https://peerlab.community/">peerlab.community</a> are great places to find other events.</p>

<a name="Step.Four:.Get.Comfortable.Not.Knowing.Things"></a>
<h1>Step Four: Get Comfortable Not Knowing Things</h1>

<p>When learning engineering concepts (and practicalities), there's a lot you're not going to know.</p>

<p>This piece of advice is important both when learning and once you actually land an engineering job (it's been one
of the hardest parts of my first ~3 months on Artsy engineering).</p>

<p>Part of what makes engineering so cool is that you are always challenged to learn new things and solve new
problems. But especially at first, the mental toolbox you have is pretty limited. When you don't know a language or
framework, it's very hard to solve problems using it—your first problems are likely to be syntax errors and
misunderstandings.</p>

<p>One of the best things you can do is learn how to ask good questions and then ask them. You might be asking them on
a forum, in GitHub issues, in meetings, or in conversation with your
<a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">favorite rubber duck</a>. Regardless, just asking them will
help, and asking lots of questions is one of the best way to learn things fast—but it takes humility and
self-awareness. <a href="https://twitter.com/b0rk">Julia Evans</a> has a <a href="https://jvns.ca/wizard-zine.pdf">great zine</a> that
has good advice on asking questions, among many other things. For a few more fun and helpful resources, see
<a href="https://github.com/artsy/README/blob/master/resources/tech-learning.md">Artsy's README</a>.</p>

<a name="Step.Five:.Recognize.What.You.Bring.to.the.Table"></a>
<h1>Step Five: Recognize What You Bring to the Table</h1>

<p>Ok, so you're reconciled to the fact that you have a lot to learn—but what about all the things you already know?
Those are important too!</p>

<p>Even if your past work and/or life experience has nothing to do with computers or programming, it can still have
value as you work towards engineering (and after you become an engineer). That value can take a lot of different
forms, and since everyone's experiences are different, I can't say for sure what impact your prior knowledge will
have.</p>

<p>For me, there are a few experiences I brought to engineering that were particularly helpful. Because I was
transitioning from one team at Artsy to another (Marketing → Engineering), I brought with me a broad understanding
of Artsy's goals and needs, which helps with day-to-day prioritization. And when I'm in a sprint planning meeting
or a product review and someone has a question about email or marketing, I can often answer—or at least I know who
to talk to to get to the bottom of the issue quickly. Plus if at some point my team needs to code emails, my
<a href="http://artsy.github.io/blog/2018/11/19/mjml/">past experience</a> will come in very handy.</p>

<p>There are also life experiences that serve me well on the Engineering team. My work as a server and bartender made
me good at clear communication with stakeholders. Cooking for big groups of friends has made me better at
estimating how long I'll need for tasks. Don't underestimate the power of "soft skills"—even companies like Google
<a href="https://www.washingtonpost.com/news/answer-sheet/wp/2017/12/20/the-surprising-thing-google-learned-about-its-employees-and-what-it-means-for-todays-students">have come to recognize</a>
that it's often the non-technical skills that separate good engineers from great ones.</p>

<p>————</p>

<p>Moving to engineering has been a tricky process, but one I'm very grateful to have experienced. I'm lucky to work
at an organization where moving from email marketing to engineering is possible, and I'm even luckier to have had
the support of engineers, friends, and engineer-friends in making the move. If you end up pursuing this course as
well, I wish you the best of luck!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Engineering Highlights]]></title>
    <link href="http://artsy.github.io/blog/2018/10/18/long-term-highlights/"/>
    <updated>2018-10-18T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/10/18/long-term-highlights</id>
    <content type="html"><![CDATA[<p>Engineering is an inherently long-term process. The Artsy engineering team has been around for 7 years, and that's
quite a lot of time to get things done. We use software that keeps track of changes over time thanks to source
control, but tools like git only help keep track of small passages of time. I want to keep track of events that
could take months to ship.</p>

<p>We've been doing a lot of long-term introspection as a team in 2018. Externally, this has been visible through
things like opening our docs and creating our engineering principles. I'm expanding on this with an idea that I
took from my work in building large open source projects: <a href="https://github.com/artsy/README/blob/master/culture/highlights.md#readme">Highlight docs</a>.</p>

<!-- more -->


<p>I've been the main contributor for <a href="https://danger.systems/">Danger</a> and <a href="https://github.com/danger/peril">Peril</a> for about three years, working mostly solo, and it can
be hard to feel like you're actually getting things done. There's an infinite backlog of people's requests for
improvements, and polite mentions of the flaws in your work. So, as a counter-balance it's nice to take stock of
events you're proud of. I initially mocked this out as <a href="https://github.com/danger/peril/issues/235">an issue in the peril repo</a> but when I
re-applied the idea to the whole of Artsy I used our existing open documentation repo <a href="https://github.com/artsy/README/"><code>artsy/README</code></a>
instead.</p>

<p>The core idea isn't complicated, however it's somewhat time-consuming and requires collaborators. I used the best
method I know for getting a lot of people's attention: spamming slack threads asking folks what were some of their
highlights. I used these to fuel the main arcs of the doc.</p>

<p>A lot of the time, just starting something like this and putting some effort in up-front means others will start to
participate. The trickiest part was finding the right definitive links for a particular event. Ideally we have open
links (so people without private GitHub access (internally and externally) can enjoy them) but sometimes the right
link is private and that's ok. It's not open source by diktat.</p>

<p>Trying to find the right balance between an "Artsy" event vs an "Engineering" event can sometimes be a bit vague,
but I like to believe that more is more. It's about pointing out important events, so more is always a net
positive. With that in mind, here's a few of ours, the rest is a click away:</p>

<p><a href="https://github.com/artsy/README/blob/master/culture/highlights.md#readme"><img src="/images/highlights/highlights.png"></a></p>

<p>I think I'm going to make one of these with every new large scale project I work on, I kinda wish we had one for
the Artsy iOS app now. Maybe I'm going to need to do that now. Ergh, this is what I get for writing blog posts.</p>

<p>I'd love to see some other companies or OSS projects using this idea - let me know in the comments if you are!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defining Our Engineering Guiding Principles]]></title>
    <link href="http://artsy.github.io/blog/2018/08/22/engineering-guiding-principles/"/>
    <updated>2018-08-22T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/08/22/engineering-guiding-principles</id>
    <content type="html"><![CDATA[<p>The Artsy Engineering team recently underwent the process of defining our guiding principles; you can read through the pull request <a href="https://github.com/artsy/meta/pull/41">here</a> and the finished principles <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md">here</a>. In this blog post, I'd like to use our experience of defining these to answer the following questions:</p>

<ul>
<li>Why define engineering guiding principles?</li>
<li>What makes principles different from company values?</li>
<li>How to define guiding principles?</li>
</ul>


<p>Let's dive in.</p>

<!-- more -->


<a name="Why.Define.Engineering.Principles."></a>
<h2>Why Define Engineering Principles?</h2>

<p>Artsy's CEO has a <a href="https://www.artsy.net/article/carter-cleveland-why-define-company-values">blog post</a> that discusses why you should define company values and, unsurprisingly, a lot of the same rationale applies to an engineering team's guiding principles. In summary:</p>

<ul>
<li>Undefined principles lead to cultural debt (similar to technical debt, but in terms of a team's culture).</li>
<li>Defined values lead to greater empowerment (engineers feel safe making decisions on their own, based on the principles).</li>
<li>Defined values reduce the risk of unconscious bias (we help our decisions get made consistently).</li>
<li>Values are your brand (this is true for Artsy Engineering, but our <a href="https://github.com/artsy">contributions</a> to the software industry are also a significant part of brand).</li>
</ul>


<p>I think each of these reasons applies to defining guiding principles as well. Over the past four years, I've seen the Artsy Engineering team encounter situations related to the reasons outlined above and, while the company values have helped us navigate disagreement, they haven't been entirely satisfactory.</p>

<p>The two biggest shortcomings of the values have been an <strong>inconsistent practice</strong> and a <strong>difficulty making team-based decisions</strong>.</p>

<p>Artsy Engineering supports the business primarily through product teams, which each have their own responsibilities and KPIs. Over time, different teams have developed their own subculture. In earnest, I think this is really cool, but it <em>has</em> eventually led to two teams taking radically different approaches to similar problems, or even repeating work that another team is already working on.</p>

<p>That missing consistency also led to difficulties making team-based decisions: how can teams make decisions <em>as a team</em> without having a clear set of guidelines with which to evaluate a decision? As I'll explain in the next section, the Artsy company values often left us without a clear answer.</p>

<a name="What.Makes.Guiding.Principles.Different.from.Company.Values."></a>
<h2>What Makes Guiding Principles Different from Company Values?</h2>

<p>Artsy's <a href="https://github.com/artsy/README/blob/master/culture/what-is-artsy.md#artsy-values">five core values</a> are as follows:</p>

<ul>
<li>Art meets Science</li>
<li>People are Paramount</li>
<li>Quality Worthy of Art</li>
<li>Positive Energy</li>
<li>Openness</li>
</ul>


<p>Those have been an incredibly useful framework for guiding Artsy's growth, for three years now. They're good values. But they are <em>very</em> general, designed specifically to be inclusive of every member of, and every team in, our company.</p>

<p>That can lead to challenges when applying the values to specific teams, including engineering. In our day-to-day work, the values can help guide our general actions (being positive in pull request reviews, for example), but lack the specifics necessary to drive decision-making on a team level. The values also sometimes conflict with one another, and navigating those conflicts is difficult without a set of down-to-Earth guiding principles.</p>

<p>Let's take a look at an example. "Quality Worthy of Art" is a really great value – personally, it motivates me to build software that would be worthy of hanging in a studio or gallery. However, the process of <em>getting</em> to that quality is often very messy; we might try one approach, switch to another, ship with <code>TODO</code> comments left in, etc. Real artists ship, after all. When <a href="http://artsy.github.io/series/open-source-by-default/">developing software in the open</a>, which value wins? The openness value, or the quality value?</p>

<p>Our CEO has encouraged the company to lean into these tensions and use them to grow and learn together, which was a motivating factor in defining our guiding principles.</p>

<a name="How.to.Define.Guiding.Principles."></a>
<h2>How to Define Guiding Principles?</h2>

<p>This is a very tricky question, since so much of the answer for Artsy Engineering is specific to us at Artsy (your process will necessarily be different) and specific to our team <em>within</em> Artsy (engineers make up less than 15% of Artsy's employee headcount). Orta helped define the values by looking at <a href="https://www.objc.io/issues/22-scale/artsy/">artefact's of our mobile team's culture</a> (since our mobile team <em>did</em> have a strong culture) and by talking to engineers privately to ask them for input. That was only half the work, though.</p>

<p>Orta opened <a href="https://github.com/artsy/meta/pull/41">the pull request</a> with the guiding principles that he had synthesized from past documentation and from conversations with engineers, but explicitly marked the PR as a work-in-progress. The values he had were a good starting point, but we iterated extensively on them. We also added many more that had been missed by Orta's starting work (we had to start somewhere, after all). The whole process took about two weeks, and I learned a lot about how other engineers work at Artsy.</p>

<p>Most of my experience at Artsy has been engineering front-end systems, and through the process of defining these principles, I learned a lot about how our back-end engineers work. We don't always work in the same way (remember, tensions?) but I value those differences; we have so much to learn from each other! Now with the guidelines, I'll be able to appreciate the back-end perspective.</p>

<hr />

<p>So with all that said, what are the Artsy Engineering Guiding Principles? You can read the <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md">current principles here</a> (they are a living set of guidelines), but the principles we decided on are:</p>

<ul>
<li>Open Source by Default</li>
<li>Own Your Dependencies</li>
<li>Incremental Revolution</li>
<li>Being Nice is Nice</li>
<li>Minimum Viable Process</li>
<li>Leverage Your Impact</li>
<li>De-silo Engineers</li>
<li>Build for 10x</li>
<li>Done Means Done</li>
</ul>


<p>I encourage you to read the document for explanations of what each of these mean.</p>

<p>Day-to-day, I don't expect <em>that</em> much to change now that we have these defined. But the differences they make will be key to the longevity and growth of our engineering team's culture.</p>

<p>Remember that earlier example of openness-vs-quality? That is answered explicitly by the principles. The principles are <em>actionable</em>, they are <em>specific</em>, and they are <em>ours</em>.</p>
]]></content>
  </entry>
  
</feed>
